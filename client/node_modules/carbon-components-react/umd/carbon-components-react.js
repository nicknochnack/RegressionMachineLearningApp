(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('prop-types'), require('react'), require('react-dom'), require('carbon-icons')) :
  typeof define === 'function' && define.amd ? define(['exports', 'prop-types', 'react', 'react-dom', 'carbon-icons'], factory) :
  (global = global || self, factory(global.CarbonComponentsReact = {}, global.PropTypes, global.React, global.ReactDOM, global.CarbonIcons));
}(this, (function (exports, PropTypes, React, ReactDOM, icons) { 'use strict';

  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;
  var React__default = 'default' in React ? React['default'] : React;
  ReactDOM = ReactDOM && ReactDOM.hasOwnProperty('default') ? ReactDOM['default'] : ReactDOM;
  icons = icons && icons.hasOwnProperty('default') ? icons['default'] : icons;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  /**
   * Settings.
   * @exports CarbonComponents.settings
   * @type Object
   * @property {boolean} [disableAutoInit]
   *   Disables automatic instantiation of components.
   *   By default (`CarbonComponents.disableAutoInit` is `false`),
   *   carbon-components attempts to instantiate components automatically
   *   by searching for elements with `data-component-name` (e.g. `data-loading`) attribute
   *   or upon DOM events (e.g. clicking) on such elements.
   *   See each components' static `.init()` methods for details.
   * @property {string} [prefix=bx]
   *   Brand prefix. Should be in sync with `$prefix` Sass variable in carbon-components/src/globals/scss/_vars.scss.
   * // @todo given that the default value is so long, is it appropriate to put in the JSDoc?
   * @property {string} [selectorTabbable]
   *   A selector selecting tabbable/focusable nodes.
   *   By default selectorTabbable references links, areas, inputs, buttons, selects, textareas,
   *   iframes, objects, embeds, or elements explicitly using tabindex or contenteditable attributes
   *   as long as the element is not `disabled` or the `tabindex="-1"`.
   * @property {string} [selectorFocusable]
   *   CSS selector that selects major nodes that are click focusable
   *   This property is identical to selectorTabbable with the exception of
   *   the `:not([tabindex='-1'])` pseudo class
   */
  var settings = {
    prefix: 'bx',
    selectorTabbable: "\n    a[href], area[href], input:not([disabled]):not([tabindex='-1']),\n    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),\n    textarea:not([disabled]):not([tabindex='-1']),\n    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]\n  ",
    selectorFocusable: "\n    a[href], area[href], input:not([disabled]),\n    button:not([disabled]),select:not([disabled]),\n    textarea:not([disabled]),\n    iframe, object, embed, *[tabindex], *[contenteditable=true]\n  "
  };
  var settings_1 = settings;

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _iterableToArray$1(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * @param {Array} a An array.
   * @returns {Array} The flattened version of the given array.
   */


  function flatten(a) {
    return a.reduce(function (result, item) {
      if (Array.isArray(item)) {
        result.push.apply(result, _toConsumableArray$1(flatten(item)));
      } else {
        result.push(item);
      }

      return result;
    }, []);
  }
  /**
   * An interface for defining mix-in classes. Used with {@link mixin}.
   * @function mixinfn
   * @param {Class} ToMix The class to mix.
   * @returns {Class} The class mixed-in with the given ToMix class.
   */

  /**
   * @function mixin
   * @param {...mixinfn} mixinfns The functions generating mix-ins.
   * @returns {Class} The class generated with the given mix-ins.
   */


  function mixin() {
    for (var _len = arguments.length, mixinfns = new Array(_len), _key = 0; _key < _len; _key++) {
      mixinfns[_key] = arguments[_key];
    }

    return flatten(mixinfns).reduce(function (Class, mixinfn) {
      return mixinfn(Class);
    }, /*#__PURE__*/function () {
      function _class() {
        _classCallCheck$1(this, _class);
      }

      return _class;
    }());
  }

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$1 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$1 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$1(obj);
  }

  function _classCallCheck$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$1(subClass, superClass);
  }

  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$1(o, p);
  }

  function _createSuper$1(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$1(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$1(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$1(this, result);
    };
  }

  function _possibleConstructorReturn$1(self, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$1(self);
  }

  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$1(o);
  }
  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */


  function createComponent (ToMix) {
    var CreateComponent = /*#__PURE__*/function (_ToMix) {
      _inherits$1(CreateComponent, _ToMix);

      var _super = _createSuper$1(CreateComponent);
      /**
       * The component instances managed by this component.
       * Releasing this component also releases the components in `this.children`.
       * @type {Component[]}
       */

      /**
       * Mix-in class to manage lifecycle of component.
       * The constructor sets up this component's effective options,
       * and registers this component't instance associated to an element.
       * @implements Handle
       * @param {HTMLElement} element The element working as this component.
       * @param {object} [options] The component options.
       */


      function CreateComponent(element) {
        var _this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck$2(this, CreateComponent);

        _this = _super.call(this, element, options);
        _this.children = [];

        if (!element || element.nodeType !== Node.ELEMENT_NODE) {
          throw new TypeError('DOM element should be given to initialize this widget.');
        }
        /**
         * The element the component is of.
         * @type {Element}
         */


        _this.element = element;
        /**
         * The component options.
         * @type {object}
         */

        _this.options = Object.assign(Object.create(_this.constructor.options), options);

        _this.constructor.components.set(_this.element, _assertThisInitialized$1(_this));

        return _this;
      }
      /**
       * Instantiates this component of the given element.
       * @param {HTMLElement} element The element.
       */


      _createClass$1(CreateComponent, [{
        key: "release",

        /**
         * Releases this component's instance from the associated element.
         */
        value: function release() {
          for (var child = this.children.pop(); child; child = this.children.pop()) {
            child.release();
          }

          this.constructor.components.delete(this.element);
          return null;
        }
      }], [{
        key: "create",
        value: function create(element, options) {
          return this.components.get(element) || new this(element, options);
        }
      }]);

      return CreateComponent;
    }(ToMix);

    return CreateComponent;
  }

  function _typeof$2(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$2 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$2 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$2(obj);
  }

  function _classCallCheck$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$2(subClass, superClass);
  }

  function _setPrototypeOf$2(o, p) {
    _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$2(o, p);
  }

  function _createSuper$2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$2();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$2(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$2(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$2(this, result);
    };
  }

  function _possibleConstructorReturn$2(self, call) {
    if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$2(self);
  }

  function _assertThisInitialized$2(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$2() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$2(o) {
    _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$2(o);
  }
  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */


  function initComponentBySearch (ToMix) {
    /**
     * Mix-in class to instantiate components by searching for their root elements.
     * @class InitComponentBySearch
     */
    var InitComponentBySearch = /*#__PURE__*/function (_ToMix) {
      _inherits$2(InitComponentBySearch, _ToMix);

      var _super = _createSuper$2(InitComponentBySearch);

      function InitComponentBySearch() {
        _classCallCheck$3(this, InitComponentBySearch);

        return _super.apply(this, arguments);
      }

      _createClass$2(InitComponentBySearch, null, [{
        key: "init",

        /**
         * Instantiates component in the given node.
         * If the given element indicates that it's an component of this class, instantiates it.
         * Otherwise, instantiates components by searching for components in the given node.
         * @param {Node} target The DOM node to instantiate components in. Should be a document or an element.
         * @param {object} [options] The component options.
         * @param {boolean} [options.selectorInit] The CSS selector to find components.
         */
        value: function init() {
          var _this = this;

          var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var effectiveOptions = Object.assign(Object.create(this.options), options);

          if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
            throw new TypeError('DOM document or DOM element should be given to search for and initialize this widget.');
          }

          if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
            this.create(target, options);
          } else {
            Array.prototype.forEach.call(target.querySelectorAll(effectiveOptions.selectorInit), function (element) {
              return _this.create(element, options);
            });
          }
        }
      }]);

      return InitComponentBySearch;
    }(ToMix);

    return InitComponentBySearch;
  }

  function _typeof$3(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$3 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$3 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$3(obj);
  }

  function _classCallCheck$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$3(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$3(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$3(Constructor, staticProps);
    return Constructor;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$3(object);
      if (object === null) break;
    }

    return object;
  }

  function _inherits$3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$3(subClass, superClass);
  }

  function _setPrototypeOf$3(o, p) {
    _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$3(o, p);
  }

  function _createSuper$3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$3();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$3(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$3(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$3(this, result);
    };
  }

  function _possibleConstructorReturn$3(self, call) {
    if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$3(self);
  }

  function _assertThisInitialized$3(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$3() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$3(o) {
    _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$3(o);
  }
  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */


  function handles (ToMix) {
    /**
     * Mix-in class to manage handles in component.
     * Managed handles are automatically released when the component with this class mixed in is released.
     * @class Handles
     * @implements Handle
     */
    var Handles = /*#__PURE__*/function (_ToMix) {
      _inherits$3(Handles, _ToMix);

      var _super = _createSuper$3(Handles);

      function Handles() {
        var _this;

        _classCallCheck$4(this, Handles);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(args));
        _this.handles = new Set();
        return _this;
      }

      _createClass$3(Handles, [{
        key: "manage",

        /**
         * Manages the given handle.
         * @param {Handle} handle The handle to manage.
         * @returns {Handle} The given handle.
         */
        value: function manage(handle) {
          this.handles.add(handle);
          return handle;
        }
        /**
         * Stop managing the given handle.
         * @param {Handle} handle The handle to stop managing.
         * @returns {Handle} The given handle.
         */

      }, {
        key: "unmanage",
        value: function unmanage(handle) {
          this.handles.delete(handle);
          return handle;
        }
      }, {
        key: "release",
        value: function release() {
          var _this2 = this;

          this.handles.forEach(function (handle) {
            handle.release();

            _this2.handles.delete(handle);
          });
          return _get(_getPrototypeOf$3(Handles.prototype), "release", this).call(this);
        }
      }]);

      return Handles;
    }(ToMix);

    return Handles;
  }

  function on(element) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    element.addEventListener.apply(element, args);
    return {
      release: function release() {
        element.removeEventListener.apply(element, args);
        return null;
      }
    };
  }

  function _typeof$4(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$4 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$4 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$4(obj);
  }

  function _classCallCheck$5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$4(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$4(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$4(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$4(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$4(subClass, superClass);
  }

  function _setPrototypeOf$4(o, p) {
    _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$4(o, p);
  }

  function _createSuper$4(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$4();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$4(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$4(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$4(this, result);
    };
  }

  function _possibleConstructorReturn$4(self, call) {
    if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$4(self);
  }

  function _assertThisInitialized$4(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$4() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$4(o) {
    _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$4(o);
  }
  var stateChangeTypes = {
    true: 'true',
    false: 'false',
    mixed: 'mixed'
  };

  var Checkbox = /*#__PURE__*/function (_mixin) {
    _inherits$4(Checkbox, _mixin);

    var _super = _createSuper$4(Checkbox);
    /**
     * Checkbox UI.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a checkbox UI.
     */


    function Checkbox(element, options) {
      var _this;

      _classCallCheck$5(this, Checkbox);

      _this = _super.call(this, element, options);

      _this.manage(on(_this.element, 'click', function (event) {
        _this._handleClick(event);
      }));

      _this.manage(on(_this.element, 'focus', function (event) {
        _this._handleFocus(event);
      }));

      _this.manage(on(_this.element, 'blur', function (event) {
        _this._handleBlur(event);
      }));

      _this._indeterminateCheckbox();

      _this._initCheckbox();

      return _this;
    }

    _createClass$4(Checkbox, [{
      key: "_handleClick",
      value: function _handleClick() {
        if (this.element.checked === true) {
          this.element.setAttribute('checked', '');
          this.element.setAttribute('aria-checked', 'true');
          this.element.checked = true; // nested checkboxes inside labels

          if (this.element.parentElement.classList.contains(this.options.classLabel)) {
            this.element.parentElement.setAttribute(this.options.attribContainedCheckboxState, 'true');
          }
        } else if (this.element.checked === false) {
          this.element.removeAttribute('checked');
          this.element.setAttribute('aria-checked', 'false');
          this.element.checked = false; // nested checkboxes inside labels

          if (this.element.parentElement.classList.contains(this.options.classLabel)) {
            this.element.parentElement.setAttribute(this.options.attribContainedCheckboxState, 'false');
          }
        }
      }
    }, {
      key: "_handleFocus",
      value: function _handleFocus() {
        if (this.element.parentElement.classList.contains(this.options.classLabel)) {
          this.element.parentElement.classList.add(this.options.classLabelFocused);
        }
      }
    }, {
      key: "_handleBlur",
      value: function _handleBlur() {
        if (this.element.parentElement.classList.contains(this.options.classLabel)) {
          this.element.parentElement.classList.remove(this.options.classLabelFocused);
        }
      }
      /**
       * Sets the new checkbox state.
       * @param {boolean|string} [state]
       *   The new checkbox state to set. `mixed` to put checkbox in indeterminate state.
       *   If omitted, this method simply makes the style reflect `aria-checked` attribute.
       */

    }, {
      key: "setState",
      value: function setState(state) {
        if (state === undefined || stateChangeTypes[state] === undefined) {
          throw new TypeError('setState expects a value of true, false or mixed.');
        }

        this.element.setAttribute('aria-checked', state);
        this.element.indeterminate = state === stateChangeTypes.mixed;
        this.element.checked = state === stateChangeTypes.true;
        var container = this.element.closest(this.options.selectorContainedCheckboxState);

        if (container) {
          container.setAttribute(this.options.attribContainedCheckboxState, state);
        }
      }
    }, {
      key: "setDisabled",
      value: function setDisabled(value) {
        if (value === undefined) {
          throw new TypeError('setDisabled expects a boolean value of true or false');
        }

        if (value === true) {
          this.element.setAttribute('disabled', true);
        } else if (value === false) {
          this.element.removeAttribute('disabled');
        }

        var container = this.element.closest(this.options.selectorContainedCheckboxDisabled);

        if (container) {
          container.setAttribute(this.options.attribContainedCheckboxDisabled, value);
        }
      }
    }, {
      key: "_indeterminateCheckbox",
      value: function _indeterminateCheckbox() {
        if (this.element.getAttribute('aria-checked') === 'mixed') {
          this.element.indeterminate = true;
        }

        if (this.element.indeterminate === true) {
          this.element.setAttribute('aria-checked', 'mixed');
        }

        if (this.element.parentElement.classList.contains(this.options.classLabel) && this.element.indeterminate === true) {
          this.element.parentElement.setAttribute(this.options.attribContainedCheckboxState, 'mixed');
        }
      }
    }, {
      key: "_initCheckbox",
      value: function _initCheckbox() {
        if (this.element.checked === true) {
          this.element.setAttribute('aria-checked', 'true');
        }

        if (this.element.parentElement.classList.contains(this.options.classLabel) && this.element.checked) {
          this.element.parentElement.setAttribute(this.options.attribContainedCheckboxState, 'true');
        }

        if (this.element.parentElement.classList.contains(this.options.classLabel)) {
          this.element.parentElement.setAttribute(this.options.attribContainedCheckboxDisabled, 'false');
        }

        if (this.element.parentElement.classList.contains(this.options.classLabel) && this.element.disabled) {
          this.element.parentElement.setAttribute(this.options.attribContainedCheckboxDisabled, 'true');
        }
      }
      /**
       * The map associating DOM element and copy button UI instance.
       * @member Checkbox.components
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Checkbox.create .create()}, or {@linkcode Checkbox.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode Checkbox.init .init()} works.
       * @member Checkbox.options
       * @type {object}
       * @property {string} selectorInit The data attribute to find copy button UIs.
       * @property {string} selectorContainedCheckboxState The CSS selector to find a container of checkbox preserving checked state.
       * @property {string} selectorContainedCheckboxDisabled
       *   The CSS selector to find a container of checkbox preserving disabled state.
       * @property {string} classLabel The CSS class for the label.
       * @property {string} classLabelFocused The CSS class for the focused label.
       * @property {string} attribContainedCheckboxState The attribute name for the checked state of contained checkbox.
       * @property {string} attribContainedCheckboxDisabled The attribute name for the disabled state of contained checkbox.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: ".".concat(prefix, "--checkbox"),
          selectorContainedCheckboxState: '[data-contained-checkbox-state]',
          selectorContainedCheckboxDisabled: '[data-contained-checkbox-disabled]',
          classLabel: "".concat(prefix, "--checkbox-label"),
          classLabelFocused: "".concat(prefix, "--checkbox-label__focus"),
          attribContainedCheckboxState: 'data-contained-checkbox-state',
          attribContainedCheckboxDisabled: 'data-contained-checkbox-disabled'
        };
      }
    }]);

    Checkbox.components = new WeakMap();
    Checkbox.stateChangeTypes = stateChangeTypes;
    return Checkbox;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$5(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$5 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$5 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$5(obj);
  }

  function _toConsumableArray$2(arr) {
    return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();
  }

  function _nonIterableSpread$2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$2(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
  }

  function _iterableToArray$2(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$2(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
  }

  function _arrayLikeToArray$2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _classCallCheck$6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$5(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$5(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$5(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$5(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$5(subClass, superClass);
  }

  function _setPrototypeOf$5(o, p) {
    _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$5(o, p);
  }

  function _createSuper$5(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$5();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$5(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$5(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$5(this, result);
    };
  }

  function _possibleConstructorReturn$5(self, call) {
    if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$5(self);
  }

  function _assertThisInitialized$5(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$5() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$5(o) {
    _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$5(o);
  }
  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */


  function eventedState (ToMix) {
    /**
     * Mix-in class to manage events associated with states.
     * @class EventedState
     */
    var EventedState = /*#__PURE__*/function (_ToMix) {
      _inherits$5(EventedState, _ToMix);

      var _super = _createSuper$5(EventedState);

      function EventedState() {
        _classCallCheck$6(this, EventedState);

        return _super.apply(this, arguments);
      }

      _createClass$5(EventedState, [{
        key: "_changeState",

        /* eslint-disable jsdoc/check-param-names */

        /**
         * The internal implementation for {@link EventedState#changeState `.changeState()`}, performing actual change in state.
         * @param {string} [state] The new state. Can be an omitted, which means toggling.
         * @param {object} [detail]
         *   The object that should be put to event details that is fired before/after changing state.
         *   Can have a `group` property, which specifies what state to be changed.
         * @param {EventedState~changeStateCallback} callback The callback called once changing state is finished or is canceled.
         * @private
         */
        value: function _changeState() {
          throw new Error('_changeState() should be overriden to perform actual change in state.');
        }
        /**
         * Changes the state of this component.
         * @param {string} [state] The new state. Can be an omitted, which means toggling.
         * @param {object} [detail]
         *   The object that should be put to event details that is fired before/after changing state.
         *   Can have a `group` property, which specifies what state to be changed.
         * @param {EventedState~changeStateCallback} [callback] The callback called once changing state is finished or is canceled.
         */

      }, {
        key: "changeState",
        value: function changeState() {
          var _this = this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var state = typeof args[0] === 'string' ? args.shift() : undefined;
          var detail = Object(args[0]) === args[0] && typeof args[0] !== 'function' ? args.shift() : undefined;
          var callback = typeof args[0] === 'function' ? args.shift() : undefined;

          if (typeof this.shouldStateBeChanged === 'function' && !this.shouldStateBeChanged(state, detail)) {
            if (callback) {
              callback(null, true);
            }

            return;
          }

          var data = {
            group: detail && detail.group,
            state: state
          };
          var eventNameSuffix = [data.group, state].filter(Boolean).join('-').split('-') // Group or state may contain hyphen
          .map(function (item) {
            return item[0].toUpperCase() + item.substr(1);
          }).join('');
          var eventStart = new CustomEvent(this.options["eventBefore".concat(eventNameSuffix)], {
            bubbles: true,
            cancelable: true,
            detail: detail
          });
          var fireOnNode = detail && detail.delegatorNode || this.element;
          var canceled = !fireOnNode.dispatchEvent(eventStart);

          if (canceled) {
            if (callback) {
              var error = new Error("Changing state (".concat(JSON.stringify(data), ") has been canceled."));
              error.canceled = true;
              callback(error);
            }
          } else {
            var changeStateArgs = [state, detail].filter(Boolean);

            this._changeState.apply(this, _toConsumableArray$2(changeStateArgs).concat([function () {
              fireOnNode.dispatchEvent(new CustomEvent(_this.options["eventAfter".concat(eventNameSuffix)], {
                bubbles: true,
                cancelable: true,
                detail: detail
              }));

              if (callback) {
                callback();
              }
            }]));
          }
        }
        /* eslint-enable jsdoc/check-param-names */

        /**
         * Tests if change in state should happen or not.
         * Classes inheriting {@link EventedState `EventedState`} should override this function.
         * @function EventedState#shouldStateBeChanged
         * @param {string} [state] The new state. Can be an omitted, which means toggling.
         * @param {object} [detail]
         *   The object that should be put to event details that is fired before/after changing state.
         *   Can have a `group` property, which specifies what state to be changed.
         * @returns {boolean}
         *   `false` if change in state shouldn't happen, e.g. when the given new state is the same as the current one.
         */

      }]);

      return EventedState;
    }(ToMix);
    /**
     * The callback called once changing state is finished or is canceled.
     * @callback EventedState~changeStateCallback
     * @param {Error} error
     *   An error object with `true` in its `canceled` property if changing state is canceled.
     *   Cancellation happens if the handler of a custom event, that is fired before changing state happens,
     *   calls `.preventDefault()` against the event.
     * @param {boolean} keptState
     *   `true` if the call to {@link EventedState#changeState `.changeState()`} didn't cause actual change in state.
     */


    return EventedState;
  }

  /**
   * @param {Event} event The event.
   * @param {string} selector The selector.
   * @returns {Element}
   *   The closest ancestor of the event target (or the event target itself) which matches the selectors given in parameter.
   */
  function eventMatches(event, selector) {
    // <svg> in IE does not have `Element#msMatchesSelector()` (that should be copied to `Element#matches()` by a polyfill).
    // Also a weird behavior is seen in IE where DOM tree seems broken when `event.target` is on <svg>.
    // Therefore this function simply returns `undefined` when `event.target` is on <svg>.
    var target = event.target,
        currentTarget = event.currentTarget;

    if (typeof target.matches === 'function') {
      if (target.matches(selector)) {
        // If event target itself matches the given selector, return it
        return target;
      }

      if (target.matches("".concat(selector, " *"))) {
        var closest = target.closest(selector);

        if ((currentTarget.nodeType === Node.DOCUMENT_NODE ? currentTarget.documentElement : currentTarget).contains(closest)) {
          return closest;
        }
      }
    }

    return undefined;
  }

  function _typeof$6(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$6 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$6 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$6(obj);
  }

  function _classCallCheck$7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$6(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$6(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$6(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$6(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$6(subClass, superClass);
  }

  function _setPrototypeOf$6(o, p) {
    _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$6(o, p);
  }

  function _createSuper$6(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$6();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$6(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$6(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$6(this, result);
    };
  }

  function _possibleConstructorReturn$6(self, call) {
    if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$6(self);
  }

  function _assertThisInitialized$6(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$6() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$6(o) {
    _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$6(o);
  }

  var toArray = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var FileUploader = /*#__PURE__*/function (_mixin) {
    _inherits$6(FileUploader, _mixin);

    var _super = _createSuper$6(FileUploader);
    /**
     * File uploader.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends eventedState
     * @extends Handles
     * @param {HTMLElement} element The element working as a file uploader.
     * @param {object} [options] The component options. See static options.
     */


    function FileUploader(element) {
      var _this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck$7(this, FileUploader);

      _this = _super.call(this, element, options);

      _this._changeState = function (state, detail, callback) {
        if (state === 'delete-filename-fileuploader') {
          _this.container.removeChild(detail.filenameElement);
        }

        if (typeof callback === 'function') {
          callback();
        }
      };

      _this._handleDeleteButton = function (evt) {
        var target = eventMatches(evt, _this.options.selectorCloseButton);

        if (target) {
          _this.changeState('delete-filename-fileuploader', {
            initialEvt: evt,
            filenameElement: target.closest(_this.options.selectorSelectedFile)
          });
        }
      };

      _this._handleDragDrop = function (evt) {
        var isOfSelf = _this.element.contains(evt.target); // In IE11 `evt.dataTransfer.types` is a `DOMStringList` instead of an array


        if (Array.prototype.indexOf.call(evt.dataTransfer.types, 'Files') >= 0 && !eventMatches(evt, _this.options.selectorOtherDropContainers)) {
          var inArea = isOfSelf && eventMatches(evt, _this.options.selectorDropContainer);

          if (evt.type === 'dragover') {
            evt.preventDefault();
            var dropEffect = inArea ? 'copy' : 'none';

            if (Array.isArray(evt.dataTransfer.types)) {
              // IE11 throws a "permission denied" error accessing `.effectAllowed`
              evt.dataTransfer.effectAllowed = dropEffect;
            }

            evt.dataTransfer.dropEffect = dropEffect;

            _this.dropContainer.classList.toggle(_this.options.classDragOver, Boolean(inArea));
          }

          if (evt.type === 'dragleave') {
            _this.dropContainer.classList.toggle(_this.options.classDragOver, false);
          }

          if (inArea && evt.type === 'drop') {
            evt.preventDefault();

            _this._displayFilenames(evt.dataTransfer.files);

            _this.dropContainer.classList.remove(_this.options.classDragOver);
          }
        }
      };

      _this.input = _this.element.querySelector(_this.options.selectorInput);
      _this.container = _this.element.querySelector(_this.options.selectorContainer);
      _this.dropContainer = _this.element.querySelector(_this.options.selectorDropContainer);

      if (!_this.input) {
        throw new TypeError('Cannot find the file input box.');
      }

      if (!_this.container) {
        throw new TypeError('Cannot find the file names container.');
      }

      _this.inputId = _this.input.getAttribute('id');

      _this.manage(on(_this.input, 'change', function () {
        return _this._displayFilenames();
      }));

      _this.manage(on(_this.container, 'click', _this._handleDeleteButton));

      _this.manage(on(_this.element.ownerDocument, 'dragleave', _this._handleDragDrop));

      _this.manage(on(_this.dropContainer, 'dragover', _this._handleDragDrop));

      _this.manage(on(_this.dropContainer, 'drop', _this._handleDragDrop));

      return _this;
    }

    _createClass$6(FileUploader, [{
      key: "_filenamesHTML",
      value: function _filenamesHTML(name, id) {
        return "<span class=\"".concat(this.options.classSelectedFile, "\">\n      <p class=\"").concat(this.options.classFileName, "\">").concat(name, "</p>\n      <span data-for=\"").concat(id, "\" class=\"").concat(this.options.classStateContainer, "\"></span>\n    </span>");
      }
    }, {
      key: "_uploadHTML",
      value: function _uploadHTML() {
        return "\n      <div class=\"".concat(this.options.classLoadingAnimation, "\">\n        <div data-inline-loading-spinner class=\"").concat(this.options.classLoading, "\">\n          <svg class=\"").concat(this.options.classLoadingSvg, "\" viewBox=\"-75 -75 150 150\">\n            <circle class=\"").concat(this.options.classLoadingBackground, "\" cx=\"0\" cy=\"0\" r=\"37.5\" />\n            <circle class=\"").concat(this.options.classLoadingStroke, "\" cx=\"0\" cy=\"0\" r=\"37.5\" />\n          </svg>\n        </div>\n      </div>");
      }
    }, {
      key: "_closeButtonHTML",
      value: function _closeButtonHTML() {
        return "\n      <button class=\"".concat(this.options.classFileClose, "\" type=\"button\" aria-label=\"close\">\n      <svg aria-hidden=\"true\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\">\n      <path fill=\"#231F20\" d=\"M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z\"/>\n      </svg>\n      </button>");
      }
    }, {
      key: "_checkmarkHTML",
      value: function _checkmarkHTML() {
        return "\n      <svg focusable=\"false\"\n        preserveAspectRatio=\"xMidYMid meet\"\n        style=\"will-change: transform;\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        class=\"".concat(this.options.classFileComplete, "\"\n        width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"\n        aria-hidden=\"true\">\n        <path d=\"M8 1C4.1 1 1 4.1 1 8s3.1 7 7 7 7-3.1 7-7-3.1-7-7-7zM7 11L4.3 8.3l.9-.8L7 9.3l4-3.9.9.8L7 11z\"></path>\n        <path d=\"M7 11L4.3 8.3l.9-.8L7 9.3l4-3.9.9.8L7 11z\" data-icon-path=\"inner-path\" opacity=\"0\"></path>\n      </svg>\n    ");
      }
    }, {
      key: "_getStateContainers",
      value: function _getStateContainers() {
        var stateContainers = toArray(this.element.querySelectorAll("[data-for=".concat(this.inputId, "]")));

        if (stateContainers.length === 0) {
          throw new TypeError('State container elements not found; invoke _displayFilenames() first');
        }

        if (stateContainers[0].dataset.for !== this.inputId) {
          throw new TypeError('File input id must equal [data-for] attribute');
        }

        return stateContainers;
      }
      /**
       * Inject selected files into DOM. Invoked on change event.
       * @param {File[]} files The files to upload.
       */

    }, {
      key: "_displayFilenames",
      value: function _displayFilenames() {
        var _this2 = this;

        var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.input.files;
        var container = this.element.querySelector(this.options.selectorContainer);
        var HTMLString = toArray(files).map(function (file) {
          return _this2._filenamesHTML(file.name, _this2.inputId);
        }).join('');
        container.insertAdjacentHTML('afterbegin', HTMLString);
      }
    }, {
      key: "_removeState",
      value: function _removeState(element) {
        if (!element || element.nodeType !== Node.ELEMENT_NODE) {
          throw new TypeError('DOM element should be given to initialize this widget.');
        }

        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
    }, {
      key: "_handleStateChange",
      value: function _handleStateChange(elements, selectIndex, html) {
        var _this3 = this;

        if (selectIndex === undefined) {
          elements.forEach(function (el) {
            _this3._removeState(el);

            el.insertAdjacentHTML('beforeend', html);
          });
        } else {
          elements.forEach(function (el, index) {
            if (index === selectIndex) {
              _this3._removeState(el);

              el.insertAdjacentHTML('beforeend', html);
            }
          });
        }
      }
      /**
       * Handles delete button.
       * @param {Event} evt The event triggering this action.
       * @private
       */

    }, {
      key: "setState",
      value: function setState(state, selectIndex) {
        var stateContainers = this._getStateContainers();

        if (state === 'edit') {
          this._handleStateChange(stateContainers, selectIndex, this._closeButtonHTML());
        }

        if (state === 'upload') {
          this._handleStateChange(stateContainers, selectIndex, this._uploadHTML());
        }

        if (state === 'complete') {
          this._handleStateChange(stateContainers, selectIndex, this._checkmarkHTML());
        }
      }
      /**
       * The map associating DOM element and file uploader instance.
       * @member FileUploader.components
       * @type {WeakMap}
       */

    }], [{
      key: "options",
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-file]',
          selectorInput: "input[type=\"file\"].".concat(prefix, "--file-input"),
          selectorContainer: '[data-file-container]',
          selectorCloseButton: ".".concat(prefix, "--file-close"),
          selectorSelectedFile: ".".concat(prefix, "--file__selected-file"),
          selectorDropContainer: "[data-file-drop-container]",
          selectorOtherDropContainers: '[data-drop-container]',
          classLoading: "".concat(prefix, "--loading ").concat(prefix, "--loading--small"),
          classLoadingAnimation: "".concat(prefix, "--inline-loading__animation"),
          classLoadingSvg: "".concat(prefix, "--loading__svg"),
          classLoadingBackground: "".concat(prefix, "--loading__background"),
          classLoadingStroke: "".concat(prefix, "--loading__stroke"),
          classFileName: "".concat(prefix, "--file-filename"),
          classFileClose: "".concat(prefix, "--file-close"),
          classFileComplete: "".concat(prefix, "--file-complete"),
          classSelectedFile: "".concat(prefix, "--file__selected-file"),
          classStateContainer: "".concat(prefix, "--file__state-container"),
          classDragOver: "".concat(prefix, "--file__drop-container--drag-over"),
          eventBeforeDeleteFilenameFileuploader: 'fileuploader-before-delete-filename',
          eventAfterDeleteFilenameFileuploader: 'fileuploader-after-delete-filename'
        };
      }
    }]);

    FileUploader.components = new WeakMap();
    return FileUploader;
  }(mixin(createComponent, initComponentBySearch, eventedState, handles));

  function _typeof$7(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$7 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$7 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$7(obj);
  }

  function _classCallCheck$8(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$7(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$7(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$7(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$7(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$7(subClass, superClass);
  }

  function _setPrototypeOf$7(o, p) {
    _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$7(o, p);
  }

  function _createSuper$7(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$7();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$7(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$7(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$7(this, result);
    };
  }

  function _possibleConstructorReturn$7(self, call) {
    if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$7(self);
  }

  function _assertThisInitialized$7(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$7() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$7(o) {
    _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$7(o);
  }

  var toArray$1 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var ContentSwitcher = /*#__PURE__*/function (_mixin) {
    _inherits$7(ContentSwitcher, _mixin);

    var _super = _createSuper$7(ContentSwitcher);
    /**
     * Set of content switcher buttons.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends EventedState
     * @extends Handles
     * @param {HTMLElement} element The element working as a set of content switcher buttons.
     * @param {object} [options] The component options.
     * @param {string} [options.selectorButton] The CSS selector to find switcher buttons.
     * @param {string} [options.selectorButtonSelected] The CSS selector to find the selected switcher button.
     * @param {string} [options.classActive] The CSS class for switcher button's selected state.
     * @param {string} [options.eventBeforeSelected]
     *   The name of the custom event fired before a switcher button is selected.
     *   Cancellation of this event stops selection of content switcher button.
     * @param {string} [options.eventAfterSelected] The name of the custom event fired after a switcher button is selected.
     */


    function ContentSwitcher(element, options) {
      var _this;

      _classCallCheck$8(this, ContentSwitcher);

      _this = _super.call(this, element, options);

      _this.manage(on(_this.element, 'click', function (event) {
        _this._handleClick(event);
      }));

      return _this;
    }
    /**
     * Handles click on content switcher button set.
     * If the click is on a content switcher button, activates it.
     * @param {Event} event The event triggering this method.
     */


    _createClass$7(ContentSwitcher, [{
      key: "_handleClick",
      value: function _handleClick(event) {
        var button = eventMatches(event, this.options.selectorButton);

        if (button) {
          this.changeState({
            group: 'selected',
            item: button,
            launchingEvent: event
          });
        }
      }
      /**
       * Internal method of {@linkcode ContentSwitcher#setActive .setActive()}, to select a content switcher button.
       * @private
       * @param {object} detail The detail of the event trigging this action.
       * @param {HTMLElement} detail.item The button to be selected.
       * @param {Function} callback Callback called when change in state completes.
       */

    }, {
      key: "_changeState",
      value: function _changeState(_ref, callback) {
        var _this2 = this;

        var item = _ref.item; // `options.selectorLink` is not defined in this class itself, code here primary is for inherited classes

        var itemLink = item.querySelector(this.options.selectorLink);

        if (itemLink) {
          toArray$1(this.element.querySelectorAll(this.options.selectorLink)).forEach(function (link) {
            if (link !== itemLink) {
              link.setAttribute('aria-selected', 'false');
            }
          });
          itemLink.setAttribute('aria-selected', 'true');
        }

        var selectorButtons = toArray$1(this.element.querySelectorAll(this.options.selectorButton));
        selectorButtons.forEach(function (button) {
          if (button !== item) {
            button.setAttribute('aria-selected', false);
            button.classList.toggle(_this2.options.classActive, false);
            toArray$1(button.ownerDocument.querySelectorAll(button.dataset.target)).forEach(function (element) {
              element.setAttribute('hidden', '');
              element.setAttribute('aria-hidden', 'true');
            });
          }
        });
        item.classList.toggle(this.options.classActive, true);
        item.setAttribute('aria-selected', true);
        toArray$1(item.ownerDocument.querySelectorAll(item.dataset.target)).forEach(function (element) {
          element.removeAttribute('hidden');
          element.setAttribute('aria-hidden', 'false');
        });

        if (callback) {
          callback();
        }
      }
      /**
       * Selects a content switcher button.
       * If the selected button has `data-target` attribute, DOM elements it points to as a CSS selector will be shown.
       * DOM elements associated with unselected buttons in the same way will be hidden.
       * @param {HTMLElement} item The button to be selected.
       * @param {ChangeState~callback} callback The callback is called once selection is finished
       * or is canceled. Will only invoke callback if it's passed in.
       */

    }, {
      key: "setActive",
      value: function setActive(item, callback) {
        this.changeState({
          group: 'selected',
          item: item
        }, function (error) {
          if (error) {
            if (callback) {
              callback(Object.assign(error, {
                item: item
              }));
            }
          } else if (callback) {
            callback(null, item);
          }
        });
      }
      /**
       * The map associating DOM element and content switcher set instance.
       * @member ContentSwitcher.components
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode ContentSwitcher.create .create()}, or {@linkcode ContentSwitcher.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode ContentSwitcher.init .init()} works.
       * @member ContentSwitcher.options
       * @type {object}
       * @property {string} selectorInit The CSS selector to find content switcher button set.
       * @property {string} [selectorButton] The CSS selector to find switcher buttons.
       * @property {string} [selectorButtonSelected] The CSS selector to find the selected switcher button.
       * @property {string} [classActive] The CSS class for switcher button's selected state.
       * @property {string} [eventBeforeSelected]
       *   The name of the custom event fired before a switcher button is selected.
       *   Cancellation of this event stops selection of content switcher button.
       * @property {string} [eventAfterSelected] The name of the custom event fired after a switcher button is selected.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-content-switcher]',
          selectorButton: "input[type=\"radio\"], .".concat(prefix, "--content-switcher-btn"),
          classActive: "".concat(prefix, "--content-switcher--selected"),
          eventBeforeSelected: 'content-switcher-beingselected',
          eventAfterSelected: 'content-switcher-selected'
        };
      }
    }]);

    ContentSwitcher.components = new WeakMap();
    return ContentSwitcher;
  }(mixin(createComponent, initComponentBySearch, eventedState, handles));

  function getLaunchingDetails(evt) {
    if (!evt || typeof evt === 'function') {
      return {
        launchingElement: null,
        launchingEvent: null
      };
    }

    var launchingElement = evt.delegateTarget || evt.currentTarget || evt;
    var launchingEvent = evt.currentTarget && evt;

    if (launchingElement && !launchingElement.nodeType) {
      throw new TypeError('DOM Node should be given for launching element.');
    }

    if (launchingEvent && !launchingEvent.type) {
      throw new TypeError('DOM event should be given for launching event.');
    }

    return {
      launchingElement: launchingElement,
      launchingEvent: launchingEvent
    };
  }

  function _typeof$8(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$8 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$8 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$8(obj);
  }

  function _classCallCheck$9(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$8(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$8(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$8(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$8(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$8(subClass, superClass);
  }

  function _setPrototypeOf$8(o, p) {
    _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$8(o, p);
  }

  function _createSuper$8(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$8();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$8(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$8(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$8(this, result);
    };
  }

  function _possibleConstructorReturn$8(self, call) {
    if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$8(self);
  }

  function _assertThisInitialized$8(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$8() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$8(o) {
    _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$8(o);
  }

  function eventedShowHideState(ToMix) {
    /**
     * Mix-in class to launch a floating menu.
     * @class EventedShowHideState
     */
    var EventedShowHideState = /*#__PURE__*/function (_ToMix) {
      _inherits$8(EventedShowHideState, _ToMix);

      var _super = _createSuper$8(EventedShowHideState);

      function EventedShowHideState() {
        _classCallCheck$9(this, EventedShowHideState);

        return _super.apply(this, arguments);
      }

      _createClass$8(EventedShowHideState, [{
        key: "show",

        /**
         */

        /**
         * Switch to 'shown' state.
         * @param [evtOrElem] The launching event or element.
         * @param {EventedState~changeStateCallback} [callback] The callback.
         */
        value: function show(evtOrElem, callback) {
          if (!evtOrElem || typeof evtOrElem === 'function') {
            callback = evtOrElem; // eslint-disable-line no-param-reassign
          }

          this.changeState('shown', getLaunchingDetails(evtOrElem), callback);
        }
        /**
         * Switch to 'hidden' state.
         * @param [evtOrElem] The launching event or element.
         * @param {EventedState~changeStateCallback} [callback] The callback.
         */

      }, {
        key: "hide",
        value: function hide(evtOrElem, callback) {
          if (!evtOrElem || typeof evtOrElem === 'function') {
            callback = evtOrElem; // eslint-disable-line no-param-reassign
          }

          this.changeState('hidden', getLaunchingDetails(evtOrElem), callback);
        }
      }]);

      return EventedShowHideState;
    }(ToMix);

    return EventedShowHideState;
  }

  var exports$1 = [eventedState, eventedShowHideState];

  var warning = function warning() {};

  {
    warning = function warning(condition, format, args) {
      var len = arguments.length;
      args = new Array(len > 2 ? len - 2 : 0);

      for (var key = 2; key < len; key++) {
        args[key - 2] = arguments[key];
      }

      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.length < 10 || /^[s\W]*$/.test(format)) {
        throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
      }

      if (!condition) {
        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });

        if (typeof console !== 'undefined') {
          console.error(message);
        }

        try {
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      }
    };
  }

  var warning_1 = warning;

  function _typeof$9(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$9 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$9 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$9(obj);
  }

  function _classCallCheck$a(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$9(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$9(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$9(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$9(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$9(subClass, superClass);
  }

  function _setPrototypeOf$9(o, p) {
    _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$9(o, p);
  }

  function _createSuper$9(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$9();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$9(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$9(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$9(this, result);
    };
  }

  function _possibleConstructorReturn$9(self, call) {
    if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$9(self);
  }

  function _assertThisInitialized$9(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$9() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$9(o) {
    _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$9(o);
  }

  function trackBlur(ToMix) {
    var TrackBlur = /*#__PURE__*/function (_ToMix) {
      _inherits$9(TrackBlur, _ToMix);

      var _super = _createSuper$9(TrackBlur);
      /**
       * Mix-in class to add an handler for losing focus.
       * @extends Handles
       * @param {HTMLElement} element The element working as this component.
       * @param {object} [options] The component options.
       */


      function TrackBlur(element, options) {
        var _this;

        _classCallCheck$a(this, TrackBlur);

        _this = _super.call(this, element, options);
        var hasFocusin = ('onfocusin' in window);
        var focusinEventName = hasFocusin ? 'focusin' : 'focus';
        var focusoutEventName = hasFocusin ? 'focusout' : 'blur';

        _this.manage(on(_this.element.ownerDocument, focusinEventName, function (event) {
          if (!(_this.options.contentNode || _this.element).contains(event.target)) {
            _this.handleBlur(event);
          }
        }, !hasFocusin));

        _this.manage(on(_this.element.ownerDocument, focusoutEventName, function (event) {
          if (!event.relatedTarget) {
            _this.handleBlur(event);
          }
        }, !hasFocusin));

        return _this;
      }
      /**
       * The method called when this component loses focus.
       * @abstract
       */


      _createClass$9(TrackBlur, [{
        key: "handleBlur",
        value: function handleBlur() {
          throw new Error('Components inheriting TrackBlur mix-in must implement handleBlur() method.');
        }
      }]);

      return TrackBlur;
    }(ToMix);

    return TrackBlur;
  }

  var exports$2 = [handles, trackBlur];

  // mdn resize function
  var optimizedResize = /* #__PURE__ */function optimizedResize() {
    var callbacks = [];
    var running = false; // run the actual callbacks

    function runCallbacks() {
      callbacks.forEach(function (callback) {
        callback();
      });
      running = false;
    } // fired on resize event


    function resize() {
      if (!running) {
        running = true;
        window.requestAnimationFrame(runCallbacks);
      }
    } // adds callback to loop


    function addCallback(callback) {
      if (callback) {
        var index = callbacks.indexOf(callback);

        if (index < 0) {
          callbacks.push(callback);
        }
      }
    }

    return {
      // public method to add additional callback
      add: function add(callback) {
        if (!callbacks.length) {
          window.addEventListener('resize', resize);
        }

        addCallback(callback);
        return {
          release: function release() {
            var index = callbacks.indexOf(callback);

            if (index >= 0) {
              callbacks.splice(index, 1);
            }
          }
        };
      }
    };
  }();

  function _typeof$a(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$a = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$a = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$a(obj);
  }

  function _classCallCheck$b(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$a(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$a(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$a(Constructor, staticProps);
    return Constructor;
  }

  function _get$1(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get$1 = Reflect.get;
    } else {
      _get$1 = function _get(target, property, receiver) {
        var base = _superPropBase$1(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get$1(target, property, receiver || target);
  }

  function _superPropBase$1(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$a(object);
      if (object === null) break;
    }

    return object;
  }

  function _inherits$a(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$a(subClass, superClass);
  }

  function _setPrototypeOf$a(o, p) {
    _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$a(o, p);
  }

  function _createSuper$a(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$a();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$a(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$a(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$a(this, result);
    };
  }

  function _possibleConstructorReturn$a(self, call) {
    if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$a(self);
  }

  function _assertThisInitialized$a(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$a() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$a(o) {
    _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$a(o);
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /**
   * The structure for the position of floating menu.
   * @typedef {object} FloatingMenu~position
   * @property {number} left The left position.
   * @property {number} top The top position.
   * @property {number} right The right position.
   * @property {number} bottom The bottom position.
   */

  /**
   * The structure for the size of floating menu.
   * @typedef {object} FloatingMenu~size
   * @property {number} width The width.
   * @property {number} height The height.
   */

  /**
   * The structure for the position offset of floating menu.
   * @typedef {object} FloatingMenu~offset
   * @property {number} top The top position.
   * @property {number} left The left position.
   */

  var DIRECTION_LEFT = 'left';
  var DIRECTION_TOP = 'top';
  var DIRECTION_RIGHT = 'right';
  var DIRECTION_BOTTOM = 'bottom';
  /**
   * @param {object} params The parameters.
   * @param {FloatingMenu~size} params.menuSize The size of the menu.
   * @param {FloatingMenu~position} params.refPosition The position of the triggering element.
   * @param {FloatingMenu~offset} [params.offset={ left: 0, top: 0 }] The position offset of the menu.
   * @param {string} [params.direction=bottom] The menu direction.
   * @param {number} [params.scrollX=0] The scroll position of the viewport.
   * @param {number} [params.scrollY=0] The scroll position of the viewport.
   * @returns {FloatingMenu~offset} The position of the menu, relative to the top-left corner of the viewport.
   * @private
   */

  var getFloatingPosition = function getFloatingPosition(_ref) {
    var _DIRECTION_LEFT$DIREC;

    var menuSize = _ref.menuSize,
        refPosition = _ref.refPosition,
        _ref$offset = _ref.offset,
        offset = _ref$offset === void 0 ? {} : _ref$offset,
        _ref$direction = _ref.direction,
        direction = _ref$direction === void 0 ? DIRECTION_BOTTOM : _ref$direction,
        _ref$scrollX = _ref.scrollX,
        scrollX = _ref$scrollX === void 0 ? 0 : _ref$scrollX,
        _ref$scrollY = _ref.scrollY,
        scrollY = _ref$scrollY === void 0 ? 0 : _ref$scrollY;
    var _refPosition$left = refPosition.left,
        refLeft = _refPosition$left === void 0 ? 0 : _refPosition$left,
        _refPosition$top = refPosition.top,
        refTop = _refPosition$top === void 0 ? 0 : _refPosition$top,
        _refPosition$right = refPosition.right,
        refRight = _refPosition$right === void 0 ? 0 : _refPosition$right,
        _refPosition$bottom = refPosition.bottom,
        refBottom = _refPosition$bottom === void 0 ? 0 : _refPosition$bottom;
    var width = menuSize.width,
        height = menuSize.height;
    var _offset$top = offset.top,
        top = _offset$top === void 0 ? 0 : _offset$top,
        _offset$left = offset.left,
        left = _offset$left === void 0 ? 0 : _offset$left;
    var refCenterHorizontal = (refLeft + refRight) / 2;
    var refCenterVertical = (refTop + refBottom) / 2;
    return (_DIRECTION_LEFT$DIREC = {}, _defineProperty$1(_DIRECTION_LEFT$DIREC, DIRECTION_LEFT, {
      left: refLeft - width + scrollX - left,
      top: refCenterVertical - height / 2 + scrollY + top
    }), _defineProperty$1(_DIRECTION_LEFT$DIREC, DIRECTION_TOP, {
      left: refCenterHorizontal - width / 2 + scrollX + left,
      top: refTop - height + scrollY - top
    }), _defineProperty$1(_DIRECTION_LEFT$DIREC, DIRECTION_RIGHT, {
      left: refRight + scrollX + left,
      top: refCenterVertical - height / 2 + scrollY + top
    }), _defineProperty$1(_DIRECTION_LEFT$DIREC, DIRECTION_BOTTOM, {
      left: refCenterHorizontal - width / 2 + scrollX + left,
      top: refBottom + scrollY + top
    }), _DIRECTION_LEFT$DIREC)[direction];
  };

  var FloatingMenu = /*#__PURE__*/function (_mixin) {
    _inherits$a(FloatingMenu, _mixin);

    var _super = _createSuper$a(FloatingMenu);
    /**
     * Floating menu.
     * @extends CreateComponent
     * @extends EventedShowHideState
     * @param {HTMLElement} element The element working as a modal dialog.
     * @param {object} [options] The component options.
     * @param {string} [options.selectorContainer] The CSS selector to find the container to put this menu in.
     * @param {string} [options.attribDirection] The attribute name to specify menu placement direction (top/right/bottom/left).
     * @param {string} [options.classShown] The CSS class for shown state, for the menu.
     * @param {string} [options.classRefShown] The CSS class for shown state, for the trigger button.
     * @param {string} [options.eventBeforeShown]
     *   The name of the custom event fired before this menu is shown.
     *   Cancellation of this event stops hiding the menu.
     * @param {string} [options.eventAfterShown]
     *   The name of the custom event telling that menu is sure shown
     *   without being canceled by the event handler named by `eventBeforeShown` option (`floating-menu-beingshown`).
     * @param {string} [options.eventBeforeHidden]
     *   The name of the custom event fired before this menu is hidden.
     *   Cancellation of this event stops hiding the menu.
     * @param {string} [options.eventAfterHidden]
     *   The name of the custom event telling that menu is sure hidden
     *   without being canceled by the event handler named by `eventBeforeHidden` option (`floating-menu-beinghidden`).
     * @param {Element} [options.refNode] The launching element of the menu. Used for calculating the geometry of the menu.
     * @param {object} [options.offset] The offset to adjust the geometry of the menu. Should have `top`/`left` properties.
     */


    function FloatingMenu(element, options) {
      var _this;

      _classCallCheck$b(this, FloatingMenu);

      _this = _super.call(this, element, options);

      var attribDirectionValue = _this.element.getAttribute(_this.options.attribDirection);

      if (!_this.options.direction) {
        _this.options.direction = attribDirectionValue || 'bottom';
      }

      if (!attribDirectionValue) {
        // Update attribute for styling
        _this.element.setAttribute(_this.options.attribDirection, _this.options.direction);
      }

      _this.manage(on(_this.element.ownerDocument, 'keydown', function (event) {
        _this._handleKeydown(event);
      }));

      return _this;
    }
    /**
     * Handles key press on document.
     * @param {Event} event The triggering event.
     * @private
     */


    _createClass$a(FloatingMenu, [{
      key: "_handleKeydown",
      value: function _handleKeydown(event) {
        var key = event.which;
        var _this$options = this.options,
            triggerNode = _this$options.triggerNode,
            refNode = _this$options.refNode;
        var isOfMenu = this.element.contains(event.target);

        switch (key) {
          // Esc
          case 27:
            this.changeState('hidden', getLaunchingDetails(event), function () {
              if (isOfMenu) {
                (triggerNode || refNode).focus();
              }
            });
            break;
        }
      }
      /**
       * Focuses back on the trigger button if this component loses focus.
       */

    }, {
      key: "handleBlur",
      value: function handleBlur(event) {
        if (this.element.classList.contains(this.options.classShown)) {
          this.changeState('hidden', getLaunchingDetails(event));
          var _this$options2 = this.options,
              refNode = _this$options2.refNode,
              triggerNode = _this$options2.triggerNode;

          if ((event.relatedTarget === null || this.element.contains(event.relatedTarget)) && refNode && event.target !== refNode) {
            HTMLElement.prototype.focus.call(triggerNode || refNode); // SVGElement in IE11 does not have `.focus()` method
          }
        }
      }
      /**
       * @private
       * @returns {Element} The element that this menu should be placed to.
       */

    }, {
      key: "_getContainer",
      value: function _getContainer() {
        return this.element.closest(this.options.selectorContainer) || this.element.ownerDocument.body;
      }
      /**
       * @private
       * @returns {object} The menu position, with `top` and `left` properties.
       */

    }, {
      key: "_getPos",
      value: function _getPos() {
        var element = this.element;
        var _this$options3 = this.options,
            refNode = _this$options3.refNode,
            offset = _this$options3.offset,
            direction = _this$options3.direction;

        if (!refNode) {
          throw new Error('Cannot find the reference node for positioning floating menu.');
        }

        return getFloatingPosition({
          menuSize: element.getBoundingClientRect(),
          refPosition: refNode.getBoundingClientRect(),
          offset: typeof offset !== 'function' ? offset : offset(element, direction, refNode),
          direction: direction,
          scrollX: refNode.ownerDocument.defaultView.pageXOffset,
          scrollY: refNode.ownerDocument.defaultView.pageYOffset
        });
      }
      /**
       * Sees if the computed style is what this floating menu expects.
       * @private
       */

    }, {
      key: "_testStyles",
      value: function _testStyles() {
        if (!this.options.debugStyle) {
          return;
        }

        var element = this.element;
        var computedStyle = element.ownerDocument.defaultView.getComputedStyle(element);
        var styles = {
          position: 'absolute',
          right: 'auto',
          margin: 0
        };
        Object.keys(styles).forEach(function (key) {
          var expected = typeof styles[key] === 'number' ? parseFloat(styles[key]) : styles[key];
          var actual = computedStyle.getPropertyValue(key);

          if (expected !== actual) {
            // eslint-disable-next-line no-console
            console.warn("Floating menu component expects ".concat(key, ": ").concat(styles[key], " style."));
          }
        });
      }
      /**
       * Places the menu.
       * @private
       */

    }, {
      key: "_place",
      value: function _place() {
        var element = this.element;

        var _this$_getPos = this._getPos(),
            left = _this$_getPos.left,
            top = _this$_getPos.top;

        element.style.left = "".concat(left, "px");
        element.style.top = "".concat(top, "px");

        this._testStyles();
      }
      /**
       * @param {string} state The new state.
       * @returns {boolean} `true` of the current state is different from the given new state.
       */

    }, {
      key: "shouldStateBeChanged",
      value: function shouldStateBeChanged(state) {
        return (state === 'shown' || state === 'hidden') && state !== (this.element.classList.contains(this.options.classShown) ? 'shown' : 'hidden');
      }
      /**
       * Changes the shown/hidden state.
       * @private
       * @param {string} state The new state.
       * @param {object} detail The detail of the event trigging this action.
       * @param {Function} callback Callback called when change in state completes.
       */

    }, {
      key: "_changeState",
      value: function _changeState(state, detail, callback) {
        var _this2 = this;

        var shown = state === 'shown';
        var _this$options4 = this.options,
            refNode = _this$options4.refNode,
            classShown = _this$options4.classShown,
            classRefShown = _this$options4.classRefShown,
            triggerNode = _this$options4.triggerNode;

        if (!refNode) {
          throw new TypeError('Cannot find the reference node for changing the style.');
        }

        if (state === 'shown') {
          if (!this.hResize) {
            this.hResize = optimizedResize.add(function () {
              _this2._place();
            });
          }

          this._getContainer().appendChild(this.element);
        }

        this.element.setAttribute('aria-hidden', (!shown).toString());
        (triggerNode || refNode).setAttribute('aria-expanded', shown.toString());
        this.element.classList.toggle(classShown, shown);

        if (classRefShown) {
          refNode.classList.toggle(classRefShown, shown);
        }

        if (state === 'shown') {
          this._place(); // IE11 puts focus on elements with `.focus()`, even ones without `tabindex` attribute


          if (!this.element.hasAttribute(this.options.attribAvoidFocusOnOpen)) {
            var primaryFocusNode = this.element.querySelector(this.options.selectorPrimaryFocus);
            var contentNode = this.options.contentNode || this.element;
            var tabbableNode = contentNode.querySelector(settings_1.selectorTabbable); // The programmatically focusable element may be (and typically will be) the content node itself;

            var focusableNode = contentNode.matches(settings_1.selectorFocusable) ? contentNode : contentNode.querySelector(settings_1.selectorFocusable);

            if (primaryFocusNode) {
              // User defined focusable node
              primaryFocusNode.focus();
            } else if (tabbableNode) {
              // First sequentially focusable node
              tabbableNode.focus();
            } else if (focusableNode) {
              // First programmatic focusable node
              focusableNode.focus();
            } else {
              this.element.focus();

              {
                  warning_1(focusableNode === null, 'Floating Menus must have at least a programmatically focusable child. ' + 'This can be accomplished by adding tabindex="-1" to the content element.')  ;
              }
            }
          }
        }

        if (state === 'hidden' && this.hResize) {
          this.hResize.release();
          this.hResize = null;
        }

        callback();
      }
    }, {
      key: "release",
      value: function release() {
        if (this.hResize) {
          this.hResize.release();
          this.hResize = null;
        }

        _get$1(_getPrototypeOf$a(FloatingMenu.prototype), "release", this).call(this);
      }
    }]);

    FloatingMenu.options = {
      selectorContainer: '[data-floating-menu-container]',
      selectorPrimaryFocus: '[data-floating-menu-primary-focus]',
      attribDirection: 'data-floating-menu-direction',
      attribAvoidFocusOnOpen: 'data-avoid-focus-on-open',
      classShown: '',
      // Should be provided from options arg in constructor
      classRefShown: '',
      // Should be provided from options arg in constructor
      eventBeforeShown: 'floating-menu-beingshown',
      eventAfterShown: 'floating-menu-shown',
      eventBeforeHidden: 'floating-menu-beinghidden',
      eventAfterHidden: 'floating-menu-hidden',
      refNode: null,
      // Should be provided from options arg in constructor
      offset: {
        left: 0,
        top: 0
      }
    };
    FloatingMenu.components = new WeakMap();
    return FloatingMenu;
  }(mixin(createComponent, exports$1, exports$2, handles));

  function _typeof$b(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$b = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$b = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$b(obj);
  }

  function _toConsumableArray$3(arr) {
    return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$3();
  }

  function _nonIterableSpread$3() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$3(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
  }

  function _iterableToArray$3(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$3(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$3(arr);
  }

  function _arrayLikeToArray$3(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _classCallCheck$c(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$b(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$b(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$b(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$b(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$b(subClass, superClass);
  }

  function _setPrototypeOf$b(o, p) {
    _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$b(o, p);
  }

  function _createSuper$b(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$b();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$b(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$b(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$b(this, result);
    };
  }

  function _possibleConstructorReturn$b(self, call) {
    if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$b(self);
  }

  function _assertThisInitialized$b(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$b() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$b(o) {
    _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$b(o);
  }

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /**
   * The CSS property names of the arrow keyed by the floating menu direction.
   * @type {object<string, string>}
   */

  var triggerButtonPositionProps = /* #__PURE__ */function () {
    var _ref;

    return _ref = {}, _defineProperty$2(_ref, DIRECTION_TOP, 'bottom'), _defineProperty$2(_ref, DIRECTION_BOTTOM, 'top'), _defineProperty$2(_ref, DIRECTION_LEFT, 'left'), _defineProperty$2(_ref, DIRECTION_RIGHT, 'right'), _ref;
  }();
  /**
   * Determines how the position of arrow should affect the floating menu position.
   * @type {object<string, number>}
   */


  var triggerButtonPositionFactors = /* #__PURE__ */function () {
    var _ref2;

    return _ref2 = {}, _defineProperty$2(_ref2, DIRECTION_TOP, -2), _defineProperty$2(_ref2, DIRECTION_BOTTOM, -1), _defineProperty$2(_ref2, DIRECTION_LEFT, -2), _defineProperty$2(_ref2, DIRECTION_RIGHT, -1), _ref2;
  }();
  /**
   * @param {Element} menuBody The menu body with the menu arrow.
   * @param {string} direction The floating menu direction.
   * @param {Element} trigger The trigger button.
   * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
   * @private
   */


  var getMenuOffset = function getMenuOffset(menuBody, direction, trigger) {
    var triggerButtonPositionProp = triggerButtonPositionProps[direction];
    var triggerButtonPositionFactor = triggerButtonPositionFactors[direction];

    if (!triggerButtonPositionProp || !triggerButtonPositionFactor) {
      console.warn('Wrong floating menu direction:', direction); // eslint-disable-line no-console
    }

    var menuWidth = menuBody.offsetWidth;
    var menuHeight = menuBody.offsetHeight; // eslint-disable-next-line no-use-before-define

    var menu = OverflowMenu.components.get(trigger);

    if (!menu) {
      throw new TypeError('Overflow menu instance cannot be found.');
    }

    var flip = menuBody.classList.contains(menu.options.classMenuFlip);

    if (triggerButtonPositionProp === 'top' || triggerButtonPositionProp === 'bottom') {
      var triggerWidth = trigger.offsetWidth;
      return {
        left: (!flip ? 1 : -1) * (menuWidth / 2 - triggerWidth / 2),
        top: 0
      };
    }

    if (triggerButtonPositionProp === 'left' || triggerButtonPositionProp === 'right') {
      var triggerHeight = trigger.offsetHeight;
      return {
        left: 0,
        top: (!flip ? 1 : -1) * (menuHeight / 2 - triggerHeight / 2)
      };
    }

    return undefined;
  };

  var OverflowMenu = /*#__PURE__*/function (_mixin) {
    _inherits$b(OverflowMenu, _mixin);

    var _super = _createSuper$b(OverflowMenu);
    /**
     * Overflow menu.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a modal dialog.
     * @param {object} [options] The component options.
     * @param {string} [options.selectorOptionMenu] The CSS selector to find the menu.
     * @param {string} [options.selectorTrigger] The CSS selector to find the trigger button.
     * @param {string} [options.classShown] The CSS class for the shown state, for the trigger UI.
     * @param {string} [options.classMenuShown] The CSS class for the shown state, for the menu.
     * @param {string} [options.classMenuFlip] The CSS class for the flipped state of the menu.
     * @param {object} [options.objMenuOffset] The offset locating the menu for the non-flipped state.
     * @param {object} [options.objMenuOffsetFlip] The offset locating the menu for the flipped state.
     */


    function OverflowMenu(element, options) {
      var _this;

      _classCallCheck$c(this, OverflowMenu);

      _this = _super.call(this, element, options);

      _this.getCurrentNavigation = function () {
        var focused = _this.element.ownerDocument.activeElement;
        return focused.nodeType === Node.ELEMENT_NODE && focused.matches(_this.options.selectorItem) ? focused : null;
      };

      _this.navigate = function (direction) {
        var items = _toConsumableArray$3(_this.element.ownerDocument.querySelectorAll(_this.options.selectorItem));

        var start = _this.getCurrentNavigation() || _this.element.querySelector(_this.options.selectorItemSelected);

        var getNextItem = function getNextItem(old) {
          var handleUnderflow = function handleUnderflow(index, length) {
            return index + (index >= 0 ? 0 : length);
          };

          var handleOverflow = function handleOverflow(index, length) {
            return index - (index < length ? 0 : length);
          }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


          var index = Math.max(items.indexOf(old) + direction, -1);
          return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
        };

        for (var current = getNextItem(start); current && current !== start; current = getNextItem(current)) {
          if (!current.matches(_this.options.selectorItemHidden) && !current.parentNode.matches(_this.options.selectorItemHidden) && !current.matches(_this.options.selectorItemSelected)) {
            current.focus();
            break;
          }
        }
      };

      if (_this.element.getAttribute('role') !== 'button') {
        // Would prefer to use the aria-controls with a specific ID but we
        // don't have the menuOptions list at this point to pull the ID from
        _this.triggerNode = _this.element.querySelector(_this.options.selectorTrigger);
      }

      _this.manage(on(_this.element.ownerDocument, 'click', function (event) {
        _this._handleDocumentClick(event);

        _this.wasOpenBeforeClick = undefined;
      }));

      _this.manage(on(_this.element.ownerDocument, 'keydown', function (event) {
        _this._handleKeyPress(event);
      }));

      _this.manage(on(_this.element, 'mousedown', function () {
        _this.wasOpenBeforeClick = element.classList.contains(_this.options.classShown);
      }));

      return _this;
    }
    /**
     * Changes the shown/hidden state.
     * @param {string} state The new state.
     * @param {object} detail The detail of the event trigging this action.
     * @param {Function} callback Callback called when change in state completes.
     */


    _createClass$b(OverflowMenu, [{
      key: "changeState",
      value: function changeState(state, detail, callback) {
        if (!this.optionMenu) {
          var optionMenu = this.element.querySelector(this.options.selectorOptionMenu);

          if (!optionMenu) {
            throw new Error('Cannot find the target menu.');
          } // Lazily create a component instance for menu


          this.optionMenu = FloatingMenu.create(optionMenu, {
            refNode: this.element,
            classShown: this.options.classMenuShown,
            classRefShown: this.options.classShown,
            offset: this.options.objMenuOffset,
            triggerNode: this.triggerNode,
            contentNode: this.element.querySelector(this.options.selectorContent)
          });
          this.children.push(this.optionMenu);
        }

        if (this.optionMenu.element.classList.contains(this.options.classMenuFlip)) {
          this.optionMenu.options.offset = this.options.objMenuOffsetFlip;
        } // Delegates the action of changing state to the menu.
        // (And thus the before/after shown/hidden events are fired from the menu)


        this.optionMenu.changeState(state, Object.assign(detail, {
          delegatorNode: this.element
        }), callback);
      }
      /**
       * Handles click on document.
       * @param {Event} event The triggering event.
       * @private
       */

    }, {
      key: "_handleDocumentClick",
      value: function _handleDocumentClick(event) {
        var _this2 = this;

        var element = this.element,
            optionMenu = this.optionMenu,
            wasOpenBeforeClick = this.wasOpenBeforeClick,
            triggerNode = this.triggerNode;
        var isOfSelf = element.contains(event.target);
        var isOfMenu = optionMenu && optionMenu.element.contains(event.target);
        var shouldBeOpen = isOfSelf && !wasOpenBeforeClick;
        var state = shouldBeOpen ? 'shown' : 'hidden';

        if (isOfSelf) {
          if (element.tagName === 'A') {
            event.preventDefault();
          }

          event.delegateTarget = element; // eslint-disable-line no-param-reassign
        }

        if (!isOfMenu || eventMatches(event, this.options.selectorItem)) {
          this.changeState(state, getLaunchingDetails(event), function () {
            if (state === 'hidden' && isOfMenu) {
              // @todo Can clean up to use `this.triggerNode` once non-compliant code is deprecated
              _this2[triggerNode ? 'triggerNode' : 'element'].focus();
            }
          });
        }
      }
      /**
       * Provides the element to move focus from
       * @returns {Element} Currently highlighted element.
       */

    }, {
      key: "_handleKeyPress",

      /**
       * Handles key press on document.
       * @param {Event} event The triggering event.
       * @private
       */
      value: function _handleKeyPress(event) {
        var _this3 = this;

        var key = event.which;
        var element = this.element,
            optionMenu = this.optionMenu,
            options = this.options,
            triggerNode = this.triggerNode;
        var isOfMenu = optionMenu && optionMenu.element.contains(event.target);
        var isExpanded = this.element.classList.contains(this.options.classShown); // @todo Can clean up to use `this.triggerNode` once non-compliant code is deprecated

        var triggerElement = triggerNode ? 'triggerNode' : 'element';

        switch (key) {
          // Enter || Space bar
          case 13:
          case 32:
            {
              if (!isExpanded && this.element.ownerDocument.activeElement !== this.element) {
                return;
              }

              var isOfSelf = element.contains(event.target);
              var shouldBeOpen = isOfSelf && !element.classList.contains(options.classShown);
              var state = shouldBeOpen ? 'shown' : 'hidden';

              if (isOfSelf) {
                event.delegateTarget = element; // eslint-disable-line no-param-reassign

                event.preventDefault(); // prevent scrolling

                this.changeState(state, getLaunchingDetails(event), function () {
                  if (state === 'hidden' && isOfMenu) {
                    _this3[triggerElement].focus();
                  }
                });
              }

              break;
            }

          case 38: // up arrow

          case 40:
            // down arrow
            {
              if (!isExpanded) {
                return;
              }

              event.preventDefault(); // prevent scrolling

              var direction = {
                38: -1,
                40: 1
              }[event.which];
              this.navigate(direction);
            }
            break;
        }
      }
    }], [{
      key: "options",
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-overflow-menu]',
          selectorOptionMenu: ".".concat(prefix, "--overflow-menu-options"),
          selectorTrigger: 'button[aria-haspopup]',
          selectorContent: ".".concat(prefix, "--overflow-menu-options__content"),
          selectorItem: "\n        .".concat(prefix, "--overflow-menu-options--open\n        .").concat(prefix, "--overflow-menu-options__option:not(.").concat(prefix, "--overflow-menu-options__option--disabled) >\n        .").concat(prefix, "--overflow-menu-options__btn\n      "),
          classShown: "".concat(prefix, "--overflow-menu--open"),
          classMenuShown: "".concat(prefix, "--overflow-menu-options--open"),
          classMenuFlip: "".concat(prefix, "--overflow-menu--flip"),
          objMenuOffset: getMenuOffset,
          objMenuOffsetFlip: getMenuOffset
        };
      }
    }]);

    OverflowMenu.components = new WeakMap();
    return OverflowMenu;
  }(mixin(createComponent, initComponentBySearch, exports$1, handles));

  function _typeof$c(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$c = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$c = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$c(obj);
  }

  function _classCallCheck$d(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$c(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$c(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$c(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$c(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$c(subClass, superClass);
  }

  function _setPrototypeOf$c(o, p) {
    _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$c(o, p);
  }

  function _createSuper$c(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$c();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$c(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$c(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$c(this, result);
    };
  }

  function _possibleConstructorReturn$c(self, call) {
    if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$c(self);
  }

  function _assertThisInitialized$c(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$c() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$c(o) {
    _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$c(o);
  }
  function initComponentByLauncher (ToMix) {
    /**
     * Mix-in class to instantiate components events on launcher button.
     * @class InitComponentByLauncher
     */
    var InitComponentByLauncher = /*#__PURE__*/function (_ToMix) {
      _inherits$c(InitComponentByLauncher, _ToMix);

      var _super = _createSuper$c(InitComponentByLauncher);

      function InitComponentByLauncher() {
        _classCallCheck$d(this, InitComponentByLauncher);

        return _super.apply(this, arguments);
      }

      _createClass$c(InitComponentByLauncher, null, [{
        key: "init",

        /**
         * `true` suggests that this component is lazily initialized upon an action/event, etc.
         * @type {boolean}
         */

        /**
         * Instantiates this component in the given element.
         * If the given element indicates that it's an component of this class, instantiates it.
         * Otherwise, instantiates this component by clicking on launcher buttons
         * (buttons with attribute that `options.attribInitTarget` points to) of this component in the given node.
         * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
         * @param {object} [options] The component options.
         * @param {string} [options.selectorInit] The CSS selector to find this component.
         * @param {string} [options.attribInitTarget] The attribute name in the launcher buttons to find target component.
         * @returns {Handle} The handle to remove the event listener to handle clicking.
         */
        value: function init() {
          var _this = this;

          var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var effectiveOptions = Object.assign(Object.create(this.options), options);

          if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
            throw new TypeError('DOM document or DOM element should be given to search for and initialize this widget.');
          }

          if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
            this.create(target, options);
          } else {
            var handles = effectiveOptions.initEventNames.map(function (name) {
              return on(target, name, function (event) {
                var launcher = eventMatches(event, "[".concat(effectiveOptions.attribInitTarget, "]"));

                if (launcher) {
                  event.delegateTarget = launcher; // eslint-disable-line no-param-reassign

                  var elements = launcher.ownerDocument.querySelectorAll(launcher.getAttribute(effectiveOptions.attribInitTarget));

                  if (elements.length > 1) {
                    throw new Error('Target widget must be unique.');
                  }

                  if (elements.length === 1) {
                    if (launcher.tagName === 'A') {
                      event.preventDefault();
                    }

                    var component = _this.create(elements[0], options);

                    if (typeof component.createdByLauncher === 'function') {
                      component.createdByLauncher(event);
                    }
                  }
                }
              });
            });
            return {
              release: function release() {
                for (var handle = handles.pop(); handle; handle = handles.pop()) {
                  handle.release();
                }
              }
            };
          }

          return '';
        }
      }]);

      InitComponentByLauncher.forLazyInit = true;
      return InitComponentByLauncher;
    }(ToMix);

    return InitComponentByLauncher;
  }

  function _typeof$d(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$d = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$d = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$d(obj);
  }

  function _classCallCheck$e(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$d(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$d(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$d(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$d(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$d(subClass, superClass);
  }

  function _setPrototypeOf$d(o, p) {
    _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$d(o, p);
  }

  function _createSuper$d(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$d();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$d(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$d(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$d(this, result);
    };
  }

  function _possibleConstructorReturn$d(self, call) {
    if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$d(self);
  }

  function _assertThisInitialized$d(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$d() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$d(o) {
    _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$d(o);
  }

  var Modal = /*#__PURE__*/function (_mixin) {
    _inherits$d(Modal, _mixin);

    var _super = _createSuper$d(Modal);
    /**
     * Modal dialog.
     * @extends CreateComponent
     * @extends InitComponentByLauncher
     * @extends EventedShowHideState
     * @extends Handles
     * @param {HTMLElement} element The element working as a modal dialog.
     * @param {object} [options] The component options.
     * @param {string} [options.classVisible] The CSS class for the visible state.
     * @param {string} [options.classBody] The CSS class for `<body>` with open modal.
     * @param {string} [options.eventBeforeShown]
     *   The name of the custom event fired before this modal is shown.
     *   Cancellation of this event stops showing the modal.
     * @param {string} [options.eventAfterShown]
     *   The name of the custom event telling that modal is sure shown
     *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
     * @param {string} [options.eventBeforeHidden]
     *   The name of the custom event fired before this modal is hidden.
     *   Cancellation of this event stops hiding the modal.
     * @param {string} [options.eventAfterHidden]
     *   The name of the custom event telling that modal is sure hidden
     *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
     */


    function Modal(element, options) {
      var _this;

      _classCallCheck$e(this, Modal);

      _this = _super.call(this, element, options);
      _this._handleFocusinListener = void 0;
      _this._handleKeydownListener = void 0;

      _this._handleFocusin = function (evt) {
        var focusWrapNode = _this.element.querySelector(_this.options.selectorModalContainer) || _this.element;

        if (_this.element.classList.contains(_this.options.classVisible) && !focusWrapNode.contains(evt.target) && _this.options.selectorsFloatingMenus.every(function (selector) {
          return !eventMatches(evt, selector);
        })) {
          _this.element.querySelector(settings_1.selectorTabbable).focus();
        }
      };

      _this._hookCloseActions();

      return _this;
    }
    /**
     * The handle for `focusin` event listener.
     * Used for "focus-wrap" feature.
     * @type {Handle}
     * @private
     */


    _createClass$d(Modal, [{
      key: "createdByLauncher",

      /**
       * A method that runs when `.init()` is called from `initComponentByLauncher`.
       * @param {Event} evt The event fired on the launcher button.
       */
      value: function createdByLauncher(evt) {
        this.show(evt);
      }
      /**
       * Determines whether or not to emit events and callback function when `.changeState()` is called from `eventedState`.
       * @param {string} state The new state.
       * @returns {boolean} `true` if the given `state` is different from current state.
       */

    }, {
      key: "shouldStateBeChanged",
      value: function shouldStateBeChanged(state) {
        if (state === 'shown') {
          return !this.element.classList.contains(this.options.classVisible);
        }

        return this.element.classList.contains(this.options.classVisible);
      }
      /**
       * Changes the shown/hidden state.
       * @private
       * @param {string} state The new state.
       * @param {object} detail The detail data to be included in the event that will be fired.
       * @param {Function} callback Callback called when change in state completes.
       */

    }, {
      key: "_changeState",
      value: function _changeState(state, detail, callback) {
        var _this2 = this;

        var handleTransitionEnd;

        var transitionEnd = function transitionEnd() {
          if (handleTransitionEnd) {
            handleTransitionEnd = _this2.unmanage(handleTransitionEnd).release();
          }

          if (state === 'shown' && _this2.element.offsetWidth > 0 && _this2.element.offsetHeight > 0) {
            _this2.previouslyFocusedNode = _this2.element.ownerDocument.activeElement;

            var focusableItem = _this2.element.querySelector(_this2.options.selectorPrimaryFocus) || _this2.element.querySelector(settings_1.selectorTabbable);

            focusableItem.focus();

            {
                warning_1(focusableItem, "Modals need to contain a focusable element by either using " + "`".concat(_this2.options.selectorPrimaryFocus, "` or settings.selectorTabbable."))  ;
            }
          }

          callback();
        };

        if (this._handleFocusinListener) {
          this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release();
        }

        if (state === 'shown') {
          var hasFocusin = ('onfocusin' in this.element.ownerDocument.defaultView);
          var focusinEventName = hasFocusin ? 'focusin' : 'focus';
          this._handleFocusinListener = this.manage(on(this.element.ownerDocument, focusinEventName, this._handleFocusin, !hasFocusin));
        }

        if (state === 'hidden') {
          this.element.classList.toggle(this.options.classVisible, false);
          this.element.ownerDocument.body.classList.toggle(this.options.classBody, false);

          if (this.options.selectorFocusOnClose || this.previouslyFocusedNode) {
            (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus();
          }
        } else if (state === 'shown') {
          this.element.classList.toggle(this.options.classVisible, true);
          this.element.ownerDocument.body.classList.toggle(this.options.classBody, true);
        }

        handleTransitionEnd = this.manage(on(this.element, 'transitionend', transitionEnd));
      }
    }, {
      key: "_hookCloseActions",
      value: function _hookCloseActions() {
        var _this3 = this;

        this.manage(on(this.element, 'click', function (evt) {
          var closeButton = eventMatches(evt, _this3.options.selectorModalClose);

          if (closeButton) {
            evt.delegateTarget = closeButton; // eslint-disable-line no-param-reassign
          }

          if (closeButton || evt.target === _this3.element) {
            _this3.hide(evt);
          }
        }));

        if (this._handleKeydownListener) {
          this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release();
        }

        this._handleKeydownListener = this.manage(on(this.element.ownerDocument.body, 'keydown', function (evt) {
          // Avoid running `evt.stopPropagation()` only when modal is shown
          if (evt.which === 27 && _this3.shouldStateBeChanged('hidden')) {
            evt.stopPropagation();

            _this3.hide(evt);
          }
        }));
      }
      /**
       * Handles `focusin` (or `focus` depending on browser support of `focusin`) event to do wrap-focus behavior.
       * @param {Event} evt The event.
       * @private
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Modal.create .create()}, or {@linkcode Modal.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode Modal.init .init()} works.
       * @member Modal.options
       * @type {object}
       * @property {string} selectorInit The CSS class to find modal dialogs.
       * @property {string} [selectorModalClose] The selector to find elements that close the modal.
       * @property {string} [selectorPrimaryFocus] The CSS selector to determine the element to put focus when modal gets open.
       * @property {string} [selectorFocusOnClose] The CSS selector to determine the element to put focus when modal closes.
       *   If undefined, focus returns to the previously focused element prior to the modal opening.
       * @property {string} [selectorModalContainer] The CSS selector for the content container of the modal for focus wrap feature.
       * @property {string} attribInitTarget The attribute name in the launcher buttons to find target modal dialogs.
       * @property {string[]} [selectorsFloatingMenu]
       *   The CSS selectors of floating menus.
       *   Used for detecting if focus-wrap behavior should be disabled temporarily.
       * @property {string} [classVisible] The CSS class for the visible state.
       * @property {string} [classBody] The CSS class for `<body>` with open modal.
       * @property {string} [classNoScroll] The CSS class for hiding scroll bar in body element while modal is shown.
       * @property {string} [eventBeforeShown]
       *   The name of the custom event fired before this modal is shown.
       *   Cancellation of this event stops showing the modal.
       * @property {string} [eventAfterShown]
       *   The name of the custom event telling that modal is sure shown
       *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
       * @property {string} [eventBeforeHidden]
       *   The name of the custom event fired before this modal is hidden.
       *   Cancellation of this event stops hiding the modal.
       * @property {string} [eventAfterHidden]
       *   The name of the custom event telling that modal is sure hidden
       *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-modal]',
          selectorModalClose: '[data-modal-close]',
          selectorPrimaryFocus: '[data-modal-primary-focus]',
          selectorsFloatingMenus: [".".concat(prefix, "--overflow-menu-options"), ".".concat(prefix, "--tooltip"), '.flatpickr-calendar'],
          selectorModalContainer: ".".concat(prefix, "--modal-container"),
          classVisible: 'is-visible',
          classBody: "".concat(prefix, "--body--with-modal-open"),
          attribInitTarget: 'data-modal-target',
          initEventNames: ['click'],
          eventBeforeShown: 'modal-beingshown',
          eventAfterShown: 'modal-shown',
          eventBeforeHidden: 'modal-beinghidden',
          eventAfterHidden: 'modal-hidden'
        };
      }
    }]);

    Modal.components = new WeakMap();
    return Modal;
  }(mixin(createComponent, initComponentByLauncher, exports$1, handles));

  function _typeof$e(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$e = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$e = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$e(obj);
  }

  function _classCallCheck$f(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$e(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$e(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$e(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$e(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$e(subClass, superClass);
  }

  function _setPrototypeOf$e(o, p) {
    _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$e(o, p);
  }

  function _createSuper$e(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$e();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$e(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$e(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$e(this, result);
    };
  }

  function _possibleConstructorReturn$e(self, call) {
    if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$e(self);
  }

  function _assertThisInitialized$e(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$e() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$e(o) {
    _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$e(o);
  }

  var Loading = /*#__PURE__*/function (_mixin) {
    _inherits$e(Loading, _mixin);

    var _super = _createSuper$e(Loading);
    /**
     * Spinner indicating loading state.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a spinner.
     * @param {object} [options] The component options.
     * @param {boolean} [options.active] `true` if this spinner should roll.
     */


    function Loading(element, options) {
      var _this;

      _classCallCheck$f(this, Loading);

      _this = _super.call(this, element, options);
      _this.active = _this.options.active; // Initialize spinner

      _this.set(_this.active);

      return _this;
    }
    /**
     * Sets active/inactive state.
     * @param {boolean} active `true` if this spinner should roll.
     */


    _createClass$e(Loading, [{
      key: "set",
      value: function set(active) {
        if (typeof active !== 'boolean') {
          throw new TypeError('set expects a boolean.');
        }

        this.active = active;
        this.element.classList.toggle(this.options.classLoadingStop, !this.active);
        /**
         * If overlay is the parentNode then toggle it too.
         */

        var parentNode = this.element.parentNode;

        if (parentNode && parentNode.classList.contains(this.options.classLoadingOverlay)) {
          parentNode.classList.toggle(this.options.classLoadingOverlayStop, !this.active);
        }

        return this;
      }
      /**
       * Toggles active/inactive state.
       */

    }, {
      key: "toggle",
      value: function toggle() {
        return this.set(!this.active);
      }
      /**
       * @returns {boolean} `true` if this spinner is rolling.
       */

    }, {
      key: "isActive",
      value: function isActive() {
        return this.active;
      }
      /**
       * Sets state to inactive and deletes the loading element.
       */

    }, {
      key: "end",
      value: function end() {
        var _this2 = this;

        this.set(false);
        var handleAnimationEnd = this.manage(on(this.element, 'animationend', function (evt) {
          if (handleAnimationEnd) {
            handleAnimationEnd = _this2.unmanage(handleAnimationEnd).release();
          }

          if (evt.animationName === 'rotate-end-p2') {
            _this2._deleteElement();
          }
        }));
      }
      /**
       * Delete component from the DOM.
       */

    }, {
      key: "_deleteElement",
      value: function _deleteElement() {
        var parentNode = this.element.parentNode;
        parentNode.removeChild(this.element);

        if (parentNode.classList.contains(this.options.selectorLoadingOverlay)) {
          parentNode.remove();
        }
      }
      /**
       * The map associating DOM element and spinner instance.
       * @member Loading.components
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Loading.create .create()}, or {@linkcode Loading.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode Loading.init .init()} works.
       * @member Loading.options
       * @type {object}
       * @property {string} selectorInit The CSS selector to find spinners.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-loading]',
          selectorLoadingOverlay: ".".concat(prefix, "--loading-overlay"),
          classLoadingOverlay: "".concat(prefix, "--loading-overlay"),
          classLoadingStop: "".concat(prefix, "--loading--stop"),
          classLoadingOverlayStop: "".concat(prefix, "--loading-overlay--stop"),
          active: true
        };
      }
    }]);

    Loading.components = new WeakMap();
    return Loading;
  }(mixin(createComponent, initComponentBySearch, handles));

  /**
   * Toggles the given attribute of the given element.
   * @param {Element} elem The element.
   * @param {string} name The attribute name.
   * @param {boolean} add `true` to set the attribute.
   */
  function toggleAttribute(elem, name, add) {
    if (add) {
      elem.setAttribute(name, '');
    } else {
      elem.removeAttribute(name);
    }
  }

  function _typeof$f(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$f = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$f = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$f(obj);
  }

  function _classCallCheck$g(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$f(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$f(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$f(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$f(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$f(subClass, superClass);
  }

  function _setPrototypeOf$f(o, p) {
    _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$f(o, p);
  }

  function _createSuper$f(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$f();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$f(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$f(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$f(this, result);
    };
  }

  function _possibleConstructorReturn$f(self, call) {
    if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$f(self);
  }

  function _assertThisInitialized$f(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$f() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$f(o) {
    _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$f(o);
  }

  var InlineLoading = /*#__PURE__*/function (_mixin) {
    _inherits$f(InlineLoading, _mixin);

    var _super = _createSuper$f(InlineLoading);
    /**
     * Spinner indicating loading state.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a spinner.
     * @param {object} [options] The component options.
     * @param {string} [options.initialState] The initial state, should be `inactive`, `active` or `finished`.
     */


    function InlineLoading(element, options) {
      var _this;

      _classCallCheck$g(this, InlineLoading);

      _this = _super.call(this, element, options); // Sets the initial state

      var initialState = _this.options.initialState;

      if (initialState) {
        _this.setState(initialState);
      }

      return _this;
    }
    /**
     * Sets active/inactive state.
     * @param {string} state The new state, should be `inactive`, `active` or `finished`.
     */


    _createClass$f(InlineLoading, [{
      key: "setState",
      value: function setState(state) {
        var states = this.constructor.states;
        var values = Object.keys(states).map(function (key) {
          return states[key];
        });

        if (values.indexOf(state) < 0) {
          throw new Error("One of the following value should be given as the state: ".concat(values.join(', ')));
        }

        var elem = this.element;
        var _this$options = this.options,
            selectorSpinner = _this$options.selectorSpinner,
            selectorFinished = _this$options.selectorFinished,
            selectorError = _this$options.selectorError,
            selectorTextActive = _this$options.selectorTextActive,
            selectorTextFinished = _this$options.selectorTextFinished,
            selectorTextError = _this$options.selectorTextError;
        var spinner = elem.querySelector(selectorSpinner);
        var finished = elem.querySelector(selectorFinished);
        var error = elem.querySelector(selectorError);
        var textActive = elem.querySelector(selectorTextActive);
        var textFinished = elem.querySelector(selectorTextFinished);
        var textError = elem.querySelector(selectorTextError);

        if (spinner) {
          spinner.classList.toggle(this.options.classLoadingStop, state !== states.ACTIVE);
          toggleAttribute(spinner, 'hidden', state !== states.INACTIVE && state !== states.ACTIVE);
        }

        if (finished) {
          toggleAttribute(finished, 'hidden', state !== states.FINISHED);
        }

        if (error) {
          toggleAttribute(error, 'hidden', state !== states.ERROR);
        }

        if (textActive) {
          toggleAttribute(textActive, 'hidden', state !== states.ACTIVE);
        }

        if (textFinished) {
          toggleAttribute(textFinished, 'hidden', state !== states.FINISHED);
        }

        if (textError) {
          toggleAttribute(textError, 'hidden', state !== states.ERROR);
        }

        return this;
      }
      /**
       * The list of states.
       * @type {object<string, string>}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode InlineLoading.create .create()},
       * or {@linkcode InlineLoading.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode InlineLoading.init .init()} works.
       * @member InlineLoading.options
       * @type {object}
       * @property {string} selectorInit The CSS selector to find inline loading components.
       * @property {string} selectorSpinner The CSS selector to find the spinner.
       * @property {string} selectorFinished The CSS selector to find the "finished" icon.
       * @property {string} selectorError The CSS selector to find the "error" icon.
       * @property {string} selectorTextActive The CSS selector to find the text describing the active state.
       * @property {string} selectorTextFinished The CSS selector to find the text describing the finished state.
       * @property {string} selectorTextError The CSS selector to find the text describing the error state.
       * @property {string} classLoadingStop The CSS class for spinner's stopped state.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-inline-loading]',
          selectorSpinner: '[data-inline-loading-spinner]',
          selectorFinished: '[data-inline-loading-finished]',
          selectorError: '[data-inline-loading-error]',
          selectorTextActive: '[data-inline-loading-text-active]',
          selectorTextFinished: '[data-inline-loading-text-finished]',
          selectorTextError: '[data-inline-loading-text-error]',
          classLoadingStop: "".concat(prefix, "--loading--stop")
        };
      }
    }]);

    InlineLoading.states = {
      INACTIVE: 'inactive',
      ACTIVE: 'active',
      FINISHED: 'finished',
      ERROR: 'error'
    };
    InlineLoading.components = new WeakMap();
    return InlineLoading;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$g(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$g = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$g = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$g(obj);
  }

  function _classCallCheck$h(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$g(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$g(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$g(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$g(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$g(subClass, superClass);
  }

  function _setPrototypeOf$g(o, p) {
    _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$g(o, p);
  }

  function _createSuper$g(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$g();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$g(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$g(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$g(this, result);
    };
  }

  function _possibleConstructorReturn$g(self, call) {
    if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$g(self);
  }

  function _assertThisInitialized$g(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$g() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$g(o) {
    _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$g(o);
  }

  var toArray$2 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var Dropdown = /*#__PURE__*/function (_mixin) {
    _inherits$g(Dropdown, _mixin);

    var _super = _createSuper$g(Dropdown);
    /**
     * A selector with drop downs.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends TrackBlur
     * @param {HTMLElement} element The element working as a selector.
     * @param {object} [options] The component options.
     * @param {string} [options.selectorItem] The CSS selector to find clickable areas in dropdown items.
     * @param {string} [options.selectorItemSelected] The CSS selector to find the clickable area in the selected dropdown item.
     * @param {string} [options.classSelected] The CSS class for the selected dropdown item.
     * @param {string} [options.classOpen] The CSS class for the open state.
     * @param {string} [options.classDisabled] The CSS class for the disabled state.
     * @param {string} [options.eventBeforeSelected]
     *   The name of the custom event fired before a drop down item is selected.
     *   Cancellation of this event stops selection of drop down item.
     * @param {string} [options.eventAfterSelected] The name of the custom event fired after a drop down item is selected.
     */


    function Dropdown(element, options) {
      var _this;

      _classCallCheck$h(this, Dropdown);

      _this = _super.call(this, element, options);

      _this.manage(on(_this.element.ownerDocument, 'click', function (event) {
        _this._toggle(event);
      }));

      _this.manage(on(_this.element, 'keydown', function (event) {
        _this._handleKeyDown(event);
      }));

      _this.manage(on(_this.element, 'click', function (event) {
        var item = eventMatches(event, _this.options.selectorItem);

        if (item) {
          _this.select(item);
        }
      })); // When using the active descendant approach we use a class to give focus styles during keyboard (up/down arrows)
      // navigation instead of relying on the :focus selector. This leaves the potential to have multiple items when
      // switching interactions between keyboard and mouse users. To more closely align with Carbon React implementation,
      // we want the focus class to move as the user hovers over items. This also updates the location of focus based on
      // the last hovered item if the user switches back to using the keyboard.


      if ( // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
      _this.element.querySelector(_this.options.selectorTrigger) && _this.element.querySelector(_this.options.selectorMenu)) {
        // Using the latest HTML structure that supports the aria-activedescendant attribute
        _this.manage(on(_this.element, 'mouseover', function (event) {
          var item = eventMatches(event, _this.options.selectorItem);

          if (item) {
            _this._updateFocus(item);
          }
        }));
      }

      return _this;
    }
    /**
     * Handles keydown event.
     * @param {Event} event The event triggering this method.
     */


    _createClass$g(Dropdown, [{
      key: "_handleKeyDown",
      value: function _handleKeyDown(event) {
        var isOpen = this.element.classList.contains(this.options.classOpen);
        var direction = {
          38: this.constructor.NAVIGATE.BACKWARD,
          40: this.constructor.NAVIGATE.FORWARD
        }[event.which];

        if (isOpen && direction !== undefined) {
          this.navigate(direction);
          event.preventDefault(); // Prevents up/down keys from scrolling container
        } else {
          // get selected item
          // in v10.0, the anchor elements fire click events on Enter keypress when a dropdown item is selected
          // in v10.5 (#3586), focus is no longer placed on the dropdown items and is instead kept fixed on the ul menu
          // so we need to manually call getCurrentNavigation and select the item
          var item = this.getCurrentNavigation();

          if (item && isOpen && (event.which === 13 || event.which === 32) && !this.element.ownerDocument.activeElement.matches(this.options.selectorItem)) {
            event.preventDefault();
            this.select(item);
          }

          this._toggle(event);
        }
      }
      /**
       * When using aria-activedescendant we want to make sure attributes and classes
       * are properly cleaned up when the dropdown is closed
       * @private
       */

    }, {
      key: "_focusCleanup",
      value: function _focusCleanup() {
        // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
        var triggerNode = this.element.querySelector(this.options.selectorTrigger); // only want to grab the listNode IF it's using the latest a11y HTML structure

        var listNode = triggerNode ? this.element.querySelector(this.options.selectorMenu) : null;

        if (listNode) {
          listNode.removeAttribute('aria-activedescendant');
          var focusedItem = this.element.querySelector(this.options.selectorItemFocused);

          if (focusedItem) {
            focusedItem.classList.remove(this.options.classFocused);
          }
        }
      }
      /**
       * Update focus using aria-activedescendant HTML structure
       * @param {HTMLElement} itemToFocus The element to be focused.
       */

    }, {
      key: "_updateFocus",
      value: function _updateFocus(itemToFocus) {
        // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
        var triggerNode = this.element.querySelector(this.options.selectorTrigger); // only want to grab the listNode IF it's using the latest a11y HTML structure

        var listNode = triggerNode ? this.element.querySelector(this.options.selectorMenu) : null;
        var previouslyFocused = listNode.querySelector(this.options.selectorItemFocused);
        itemToFocus.classList.add(this.options.classFocused);
        listNode.setAttribute('aria-activedescendant', itemToFocus.id);

        if (previouslyFocused) {
          previouslyFocused.classList.remove(this.options.classFocused);
        }
      }
      /**
       * Opens and closes the dropdown menu.
       * @param {Event} [event] The event triggering this method.
       *
       * @todo https://github.com/carbon-design-system/carbon/issues/3641
       */

    }, {
      key: "_toggle",
      value: function _toggle(event) {
        var _this2 = this;

        var isDisabled = this.element.classList.contains(this.options.classDisabled);

        if (isDisabled) {
          return;
        } // NOTE: `selectorTrigger` does NOT match the trigger button in older markup


        var triggerNode = this.element.querySelector(this.options.selectorTrigger);

        if ( // User presses down arrow
        event.which === 40 && !event.target.matches(this.options.selectorItem) || // User presses space or enter and the trigger is not a button OR event is not fired by trigger
        (!triggerNode || !triggerNode.contains(event.target)) && [13, 32].indexOf(event.which) >= 0 && !event.target.matches(this.options.selectorItem) || // User presses esc
        event.which === 27 || // User clicks
        event.type === 'click') {
          var isOpen = this.element.classList.contains(this.options.classOpen);
          var isOfSelf = this.element.contains(event.target); // Determine if the open className should be added, removed, or toggled

          var actions = {
            add: isOfSelf && event.which === 40 && !isOpen,
            remove: (!isOfSelf || event.which === 27) && isOpen,
            toggle: isOfSelf && event.which !== 27 && event.which !== 40
          };
          var changedState = false;
          Object.keys(actions).forEach(function (action) {
            if (actions[action]) {
              changedState = true;

              _this2.element.classList[action](_this2.options.classOpen);
            }
          });
          var listItems = toArray$2(this.element.querySelectorAll(this.options.selectorItem)); // only want to grab the listNode IF it's using the latest a11y HTML structure

          var listNode = triggerNode ? this.element.querySelector(this.options.selectorMenu) : null; // @todo remove conditionals for elements existing once legacy structure is depreciated

          if (changedState && this.element.classList.contains(this.options.classOpen)) {
            // toggled open
            if (triggerNode) {
              triggerNode.setAttribute('aria-expanded', 'true');
            }

            (listNode || this.element).focus();

            if (listNode) {
              var selectedNode = listNode.querySelector(this.options.selectorLinkSelected);
              listNode.setAttribute('aria-activedescendant', (selectedNode || listItems[0]).id);
              (selectedNode || listItems[0]).classList.add(this.options.classFocused);
            }
          } else if (changedState && (isOfSelf || actions.remove)) {
            // toggled close
            // timer is used to call focus AFTER the click event on
            // trigger button (which is caused by keypress e.g. during keyboard navigation)
            setTimeout(function () {
              return (triggerNode || _this2.element).focus();
            }, 0);

            if (triggerNode) {
              triggerNode.setAttribute('aria-expanded', 'false');
            }

            this._focusCleanup();
          } // @todo remove once legacy structure is depreciated


          if (!triggerNode) {
            listItems.forEach(function (item) {
              if (_this2.element.classList.contains(_this2.options.classOpen)) {
                item.tabIndex = 0;
              } else {
                item.tabIndex = -1;
              }
            });
          }

          var menuListNode = this.element.querySelector(this.options.selectorMenu);

          if (menuListNode) {
            menuListNode.tabIndex = this.element.classList.contains(this.options.classOpen) ? '0' : '-1';
          }
        }
      }
      /**
       * @returns {Element} Currently highlighted element.
       */

    }, {
      key: "getCurrentNavigation",
      value: function getCurrentNavigation() {
        var focusedNode; // Using the latest semantic markup structure where trigger is a button
        // @todo remove conditional once legacy structure is depreciated
        // NOTE: `selectorTrigger` does NOT match the trigger button in older markup

        if (this.element.querySelector(this.options.selectorTrigger)) {
          var listNode = this.element.querySelector(this.options.selectorMenu);
          var focusedId = listNode.getAttribute('aria-activedescendant');
          focusedNode = focusedId ? listNode.querySelector("#".concat(focusedId)) : null;
        } else {
          var focused = this.element.ownerDocument.activeElement;
          focusedNode = focused.nodeType === Node.ELEMENT_NODE && focused.matches(this.options.selectorItem) ? focused : null;
        }

        return focusedNode;
      }
      /**
       * Moves up/down the focus.
       * @param {number} direction The direction of navigating.
       */
      // @todo create issue it's a better UX to move the focus when the user hovers so they stay in sync

    }, {
      key: "navigate",
      value: function navigate(direction) {
        var items = toArray$2(this.element.querySelectorAll(this.options.selectorItem));
        var start = this.getCurrentNavigation() || this.element.querySelector(this.options.selectorLinkSelected);

        var getNextItem = function getNextItem(old) {
          var handleUnderflow = function handleUnderflow(i, l) {
            return i + (i >= 0 ? 0 : l);
          };

          var handleOverflow = function handleOverflow(i, l) {
            return i - (i < l ? 0 : l);
          }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


          var index = Math.max(items.indexOf(old) + direction, -1);
          return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
        };

        var isShowSelected = this.element.classList.contains(this.options.classShowSelected);

        for (var current = getNextItem(start); current && current !== start; current = getNextItem(current)) {
          if (!current.matches(this.options.selectorItemHidden) && !current.parentNode.matches(this.options.selectorItemHidden) && (isShowSelected || !isShowSelected && !current.parentElement.matches(this.options.selectorItemSelected))) {
            // Using the latest semantic markup structure where trigger is a button
            // @todo remove conditional once legacy structure is depreciated
            // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
            if (this.element.querySelector(this.options.selectorTrigger)) {
              this._updateFocus(current);
            } else {
              current.focus();
            }

            break;
          }
        }
      }
      /**
       * Handles clicking on the dropdown options, doing the following:
       * * Change Dropdown text to selected option.
       * * Remove selected option from options when selected.
       * * Emit custom events.
       * @param {HTMLElement} itemToSelect The element to be activated.
       */

    }, {
      key: "select",
      value: function select(itemToSelect) {
        var _this3 = this;

        var eventStart = new CustomEvent(this.options.eventBeforeSelected, {
          bubbles: true,
          cancelable: true,
          detail: {
            item: itemToSelect
          }
        });

        if (this.element.dispatchEvent(eventStart)) {
          if (this.element.dataset.dropdownType !== 'navigation') {
            // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
            var selectorText = !this.element.querySelector(this.options.selectorTrigger) && this.element.dataset.dropdownType !== 'inline' ? this.options.selectorText : this.options.selectorTextInner;
            var text = this.element.querySelector(selectorText);

            if (text) {
              text.innerHTML = itemToSelect.innerHTML;
            }

            itemToSelect.parentElement.classList.add(this.options.classSelected);
          }

          this.element.dataset.value = itemToSelect.parentElement.dataset.value;
          toArray$2(this.element.querySelectorAll(this.options.selectorLinkSelected)).forEach(function (item) {
            if (itemToSelect !== item) {
              item.parentElement.classList.remove(_this3.options.classSelected);
            }
          });
          this.element.dispatchEvent(new CustomEvent(this.options.eventAfterSelected, {
            bubbles: true,
            cancelable: true,
            detail: {
              item: itemToSelect
            }
          }));
        }
      }
      /**
       * Closes the dropdown menu if this component loses focus.
       */

    }, {
      key: "handleBlur",
      value: function handleBlur() {
        this.element.classList.remove(this.options.classOpen);

        this._focusCleanup();
      }
      /**
       * The map associating DOM element and selector instance.
       * @member Dropdown.components
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Dropdown.create .create()}, or {@linkcode Dropdown.init .init()},
       * properties in this object are overridden for the instance being create and how {@linkcode Dropdown.init .init()} works.
       * @member Dropdown.options
       * @type {object}
       * @property {string} selectorInit The CSS selector to find selectors.
       * @property {string} [selectorTrigger]
       *   The CSS selector to find the trigger button when using a11y compliant markup.
       *   NOTE: Does NOT match the trigger button in older markup.
       * @property {string} [selectorMenu] The CSS selector to find menu list when using a11y compliant markup.
       * @property {string} [selectorText] The CSS selector to find the element showing the selected item.
       * @property {string} [selectorTextInner] The CSS selector to find the element showing the selected item, used for inline mode.
       * @property {string} [selectorItem] The CSS selector to find clickable areas in dropdown items.
       * @property {string} [selectorItemHidden]
       *   The CSS selector to find hidden dropdown items.
       *   Used to skip dropdown items for keyboard navigation.
       * @property {string} [selectorItemSelected] The CSS selector to find the clickable area in the selected dropdown item.
       * @property {string} [selectorItemFocused] The CSS selector to find the clickable area in the focused dropdown item.
       * @property {string} [selectorLinkSelected] The CSS selector to target the link node of the selected dropdown item.
       * @property {string} [classShowSelected] The CSS class for the show selected modifier of the dropdown.
       * @property {string} [classSelected] The CSS class for the selected dropdown item.
       * @property {string} [classFocused] The CSS class for the focused dropdown item.
       * @property {string} [classOpen] The CSS class for the open state.
       * @property {string} [classDisabled] The CSS class for the disabled state.
       * @property {string} [eventBeforeSelected]
       *   The name of the custom event fired before a drop down item is selected.
       *   Cancellation of this event stops selection of drop down item.
       * @property {string} [eventAfterSelected] The name of the custom event fired after a drop down item is selected.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-dropdown]',
          selectorTrigger: "button.".concat(prefix, "--dropdown-text"),
          // NOTE: Does NOT match the trigger button in older markup.
          selectorMenu: ".".concat(prefix, "--dropdown-list"),
          selectorText: ".".concat(prefix, "--dropdown-text"),
          selectorTextInner: ".".concat(prefix, "--dropdown-text__inner"),
          selectorItem: ".".concat(prefix, "--dropdown-link"),
          selectorItemSelected: ".".concat(prefix, "--dropdown--selected"),
          selectorItemFocused: ".".concat(prefix, "--dropdown--focused"),
          selectorItemHidden: "[hidden],[aria-hidden=\"true\"]",
          selectorLinkSelected: ".".concat(prefix, "--dropdown--selected .").concat(prefix, "--dropdown-link"),
          classShowSelected: "".concat(prefix, "--dropdown--show-selected"),
          classSelected: "".concat(prefix, "--dropdown--selected"),
          classFocused: "".concat(prefix, "--dropdown--focused"),
          classOpen: "".concat(prefix, "--dropdown--open"),
          classDisabled: "".concat(prefix, "--dropdown--disabled"),
          eventBeforeSelected: 'dropdown-beingselected',
          eventAfterSelected: 'dropdown-selected'
        };
      }
      /**
       * Enum for navigating backward/forward.
       * @readonly
       * @member Dropdown.NAVIGATE
       * @type {object}
       * @property {number} BACKWARD Navigating backward.
       * @property {number} FORWARD Navigating forward.
       */

    }]);

    Dropdown.components = new WeakMap();
    Dropdown.NAVIGATE = {
      BACKWARD: -1,
      FORWARD: 1
    };
    return Dropdown;
  }(mixin(createComponent, initComponentBySearch, exports$2));

  function _typeof$h(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$h = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$h = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$h(obj);
  }

  function _classCallCheck$i(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$h(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$h(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$h(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$h(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$h(subClass, superClass);
  }

  function _setPrototypeOf$h(o, p) {
    _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$h(o, p);
  }

  function _createSuper$h(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$h();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$h(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$h(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$h(this, result);
    };
  }

  function _possibleConstructorReturn$h(self, call) {
    if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$h(self);
  }

  function _assertThisInitialized$h(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$h() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$h(o) {
    _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$h(o);
  }

  var NumberInput = /*#__PURE__*/function (_mixin) {
    _inherits$h(NumberInput, _mixin);

    var _super = _createSuper$h(NumberInput);
    /**
     * Number input UI.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a number input UI.
     */


    function NumberInput(element, options) {
      var _this;

      _classCallCheck$i(this, NumberInput);

      _this = _super.call(this, element, options); // Broken DOM tree is seen with up/down arrows <svg> in IE, which breaks event delegation.
      // <svg> does not have `Element.classList` in IE11

      _this.manage(on(_this.element.querySelector('.up-icon'), 'click', function (event) {
        _this._handleClick(event);
      }));

      _this.manage(on(_this.element.querySelector('.down-icon'), 'click', function (event) {
        _this._handleClick(event);
      }));

      return _this;
    }
    /**
     * Increase/decrease number by clicking on up/down icons.
     * @param {Event} event The event triggering this method.
     */


    _createClass$h(NumberInput, [{
      key: "_handleClick",
      value: function _handleClick(event) {
        var numberInput = this.element.querySelector(this.options.selectorInput);
        var target = event.currentTarget.getAttribute('class').split(' ');
        var min = Number(numberInput.min);
        var max = Number(numberInput.max);
        var step = Number(numberInput.step) || 1;

        if (target.indexOf('up-icon') >= 0) {
          var nextValue = Number(numberInput.value) + step;

          if (numberInput.max === '') {
            numberInput.value = nextValue;
          } else if (numberInput.value < max) {
            if (nextValue > max) {
              numberInput.value = max;
            } else if (nextValue < min) {
              numberInput.value = min;
            } else {
              numberInput.value = nextValue;
            }
          }
        } else if (target.indexOf('down-icon') >= 0) {
          var _nextValue = Number(numberInput.value) - step;

          if (numberInput.min === '') {
            numberInput.value = _nextValue;
          } else if (numberInput.value > min) {
            if (_nextValue < min) {
              numberInput.value = min;
            } else if (_nextValue > max) {
              numberInput.value = max;
            } else {
              numberInput.value = _nextValue;
            }
          }
        } // Programmatic change in value (including `stepUp()`/`stepDown()`) won't fire change event


        numberInput.dispatchEvent(new CustomEvent('change', {
          bubbles: true,
          cancelable: false
        }));
      }
      /**
       * The map associating DOM element and number input UI instance.
       * @member NumberInput.components
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode NumberInput.create .create()}, or {@linkcode NumberInput.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode NumberInput.init .init()} works.
       * @member NumberInput.options
       * @type {object}
       * @property {string} selectorInit The CSS selector to find number input UIs.
       * @property {string} [selectorInput] The CSS selector to find the `<input>` element.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-numberinput]',
          selectorInput: ".".concat(prefix, "--number input")
        };
      }
    }]);

    NumberInput.components = new WeakMap();
    return NumberInput;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$i(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$i = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$i = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$i(obj);
  }

  function _toConsumableArray$4(arr) {
    return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$4();
  }

  function _nonIterableSpread$4() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$4(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
  }

  function _iterableToArray$4(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$4(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$4(arr);
  }

  function _arrayLikeToArray$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _classCallCheck$j(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$i(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$i(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$i(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$i(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$i(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$i(subClass, superClass);
  }

  function _setPrototypeOf$i(o, p) {
    _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$i(o, p);
  }

  function _createSuper$i(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$i();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$i(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$i(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$i(this, result);
    };
  }

  function _possibleConstructorReturn$i(self, call) {
    if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$i(self);
  }

  function _assertThisInitialized$i(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$i() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$i(o) {
    _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$i(o);
  }

  var toArray$3 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var DataTable = /*#__PURE__*/function (_mixin) {
    _inherits$i(DataTable, _mixin);

    var _super = _createSuper$i(DataTable);
    /**
     * Data Table
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends   EventedState
     * @param {HTMLElement} element The root element of tables
     * @param {object} [options] the... options
     * @param {string} [options.selectorInit] selector initialization
     * @param {string} [options.selectorExpandCells] css selector for expand
     * @param {string} [options.expandableRow] css selector for expand
     * @param {string} [options.selectorParentRows] css selector for rows housing expansion
     * @param {string} [options.selectorTableBody] root css for table body
     * @param {string} [options.eventTrigger] selector for event bubble capture points
     * @param {string} [options.eventParentContainer] used find the bubble container
     */


    function DataTable(_element, options) {
      var _this;

      _classCallCheck$j(this, DataTable);

      _this = _super.call(this, _element, options);

      _this._sortToggle = function (detail) {
        var element = detail.element,
            previousValue = detail.previousValue;
        toArray$3(_this.tableHeaders).forEach(function (header) {
          var sortEl = header.querySelector(_this.options.selectorTableSort);

          if (sortEl !== null && sortEl !== element) {
            sortEl.classList.remove(_this.options.classTableSortActive);
            sortEl.classList.remove(_this.options.classTableSortAscending);
          }
        });

        if (!previousValue) {
          element.dataset.previousValue = 'ascending';
          element.classList.add(_this.options.classTableSortActive);
          element.classList.add(_this.options.classTableSortAscending);
        } else if (previousValue === 'ascending') {
          element.dataset.previousValue = 'descending';
          element.classList.add(_this.options.classTableSortActive);
          element.classList.remove(_this.options.classTableSortAscending);
        } else if (previousValue === 'descending') {
          element.removeAttribute('data-previous-value');
          element.classList.remove(_this.options.classTableSortActive);
          element.classList.remove(_this.options.classTableSortAscending);
        }
      };

      _this._selectToggle = function (detail) {
        var element = detail.element;
        var checked = element.checked; // increment the  count

        _this.state.checkboxCount += checked ? 1 : -1;
        _this.countEl.textContent = _this.state.checkboxCount;
        var row = element.parentNode.parentNode;
        row.classList.toggle(_this.options.classTableSelected); // toggle on/off batch action bar

        _this._actionBarToggle(_this.state.checkboxCount > 0);
      };

      _this._selectAllToggle = function (_ref) {
        var element = _ref.element;
        var checked = element.checked;
        var inputs = toArray$3(_this.element.querySelectorAll(_this.options.selectorCheckbox));
        _this.state.checkboxCount = checked ? inputs.length - 1 : 0;
        inputs.forEach(function (item) {
          item.checked = checked;
          var row = item.parentNode.parentNode;

          if (checked && row) {
            row.classList.add(_this.options.classTableSelected);
          } else {
            row.classList.remove(_this.options.classTableSelected);
          }
        });

        _this._actionBarToggle(_this.state.checkboxCount > 0);

        if (_this.batchActionEl) {
          _this.countEl.textContent = _this.state.checkboxCount;
        }
      };

      _this._actionBarCancel = function () {
        var inputs = toArray$3(_this.element.querySelectorAll(_this.options.selectorCheckbox));
        var row = toArray$3(_this.element.querySelectorAll(_this.options.selectorTableSelected));
        row.forEach(function (item) {
          item.classList.remove(_this.options.classTableSelected);
        });
        inputs.forEach(function (item) {
          item.checked = false;
        });
        _this.state.checkboxCount = 0;

        _this._actionBarToggle(false);

        if (_this.batchActionEl) {
          _this.countEl.textContent = _this.state.checkboxCount;
        }
      };

      _this._actionBarToggle = function (toggleOn) {
        var handleTransitionEnd;

        var transition = function transition(evt) {
          if (handleTransitionEnd) {
            handleTransitionEnd = _this.unmanage(handleTransitionEnd).release();
          }

          if (evt.target.matches(_this.options.selectorActions)) {
            if (_this.batchActionEl.dataset.active === 'false') {
              _this.batchActionEl.setAttribute('tabIndex', -1);
            } else {
              _this.batchActionEl.setAttribute('tabIndex', 0);
            }
          }
        };

        if (toggleOn) {
          _this.batchActionEl.dataset.active = true;

          _this.batchActionEl.classList.add(_this.options.classActionBarActive);
        } else if (_this.batchActionEl) {
          _this.batchActionEl.dataset.active = false;

          _this.batchActionEl.classList.remove(_this.options.classActionBarActive);
        }

        if (_this.batchActionEl) {
          handleTransitionEnd = _this.manage(on(_this.batchActionEl, 'transitionend', transition));
        }
      };

      _this._rowExpandToggle = function (_ref2) {
        var element = _ref2.element,
            forceExpand = _ref2.forceExpand;
        var parent = element.closest(_this.options.eventParentContainer); // NOTE: `data-previous-value` keeps UI state before this method makes change in style
        // eslint-disable-next-line eqeqeq

        var shouldExpand = forceExpand != null ? forceExpand : element.dataset.previousValue === undefined || element.dataset.previousValue === 'expanded';

        if (shouldExpand) {
          element.dataset.previousValue = 'collapsed';
          parent.classList.add(_this.options.classExpandableRow);
        } else {
          parent.classList.remove(_this.options.classExpandableRow);
          element.dataset.previousValue = 'expanded';

          var expandHeader = _this.element.querySelector(_this.options.selectorExpandHeader);

          if (expandHeader) {
            expandHeader.dataset.previousValue = 'expanded';
          }
        }
      };

      _this._rowExpandToggleAll = function (_ref3) {
        var element = _ref3.element; // NOTE: `data-previous-value` keeps UI state before this method makes change in style

        var shouldExpand = element.dataset.previousValue === undefined || element.dataset.previousValue === 'expanded';
        element.dataset.previousValue = shouldExpand ? 'collapsed' : 'expanded';

        var expandCells = _this.element.querySelectorAll(_this.options.selectorExpandCells);

        Array.prototype.forEach.call(expandCells, function (cell) {
          _this._rowExpandToggle({
            element: cell,
            forceExpand: shouldExpand
          });
        });
      };

      _this._expandableHoverToggle = function (evt) {
        var element = eventMatches(evt, _this.options.selectorChildRow);

        if (element) {
          element.previousElementSibling.classList.toggle(_this.options.classExpandableRowHover, evt.type === 'mouseover');
        }
      };

      _this._toggleState = function (element, evt) {
        var data = element.dataset;
        var label = data.label ? data.label : '';
        var previousValue = data.previousValue ? data.previousValue : '';
        var initialEvt = evt;

        _this.changeState({
          group: data.event,
          element: element,
          label: label,
          previousValue: previousValue,
          initialEvt: initialEvt
        });
      };

      _this._keydownHandler = function (evt) {
        var searchContainer = _this.element.querySelector(_this.options.selectorToolbarSearchContainer);

        var searchEvent = eventMatches(evt, _this.options.selectorSearchMagnifier);
        var activeSearch = searchContainer.classList.contains(_this.options.classToolbarSearchActive);

        if (evt.which === 27) {
          _this._actionBarCancel();
        }

        if (searchContainer && searchEvent && evt.which === 13) {
          _this.activateSearch(searchContainer);
        }

        if (activeSearch && evt.which === 27) {
          _this.deactivateSearch(searchContainer, evt);
        }
      };

      _this.refreshRows = function () {
        var newExpandCells = toArray$3(_this.element.querySelectorAll(_this.options.selectorExpandCells));
        var newExpandableRows = toArray$3(_this.element.querySelectorAll(_this.options.selectorExpandableRows));
        var newParentRows = toArray$3(_this.element.querySelectorAll(_this.options.selectorParentRows)); // check if this is a refresh or the first time

        if (_this.parentRows.length > 0) {
          var diffParentRows = newParentRows.filter(function (newRow) {
            return !_this.parentRows.some(function (oldRow) {
              return oldRow === newRow;
            });
          }); // check if there are expandable rows

          if (newExpandableRows.length > 0) {
            var diffExpandableRows = diffParentRows.map(function (newRow) {
              return newRow.nextElementSibling;
            });
            var mergedExpandableRows = [].concat(_toConsumableArray$4(toArray$3(_this.expandableRows)), _toConsumableArray$4(toArray$3(diffExpandableRows)));
            _this.expandableRows = mergedExpandableRows;
          }
        } else if (newExpandableRows.length > 0) {
          _this.expandableRows = newExpandableRows;
        }

        _this.expandCells = newExpandCells;
        _this.parentRows = newParentRows;
      };

      _this.container = _element.parentNode;
      _this.toolbarEl = _this.element.querySelector(_this.options.selectorToolbar);
      _this.batchActionEl = _this.element.querySelector(_this.options.selectorActions);
      _this.countEl = _this.element.querySelector(_this.options.selectorCount);
      _this.cancelEl = _this.element.querySelector(_this.options.selectorActionCancel);
      _this.tableHeaders = _this.element.querySelectorAll('th');
      _this.tableBody = _this.element.querySelector(_this.options.selectorTableBody);
      _this.expandCells = [];
      _this.expandableRows = [];
      _this.parentRows = [];

      _this.refreshRows();

      _this.manage(on(_this.element, 'mouseover', _this._expandableHoverToggle));

      _this.manage(on(_this.element, 'mouseout', _this._expandableHoverToggle));

      _this.manage(on(_this.element, 'click', function (evt) {
        var eventElement = eventMatches(evt, _this.options.eventTrigger);

        var searchContainer = _this.element.querySelector(_this.options.selectorToolbarSearchContainer);

        if (eventElement) {
          _this._toggleState(eventElement, evt);
        }

        if (searchContainer) {
          _this._handleDocumentClick(evt);
        }
      }));

      _this.manage(on(_this.element, 'keydown', _this._keydownHandler));

      _this.state = {
        checkboxCount: 0
      };
      return _this;
    }

    _createClass$i(DataTable, [{
      key: "_handleDocumentClick",
      value: function _handleDocumentClick(evt) {
        var searchContainer = this.element.querySelector(this.options.selectorToolbarSearchContainer);
        var searchEvent = eventMatches(evt, this.options.selectorSearchMagnifier);
        var activeSearch = searchContainer.classList.contains(this.options.classToolbarSearchActive);

        if (searchContainer && searchEvent) {
          this.activateSearch(searchContainer);
        }

        if (activeSearch) {
          this.deactivateSearch(searchContainer, evt);
        }
      }
    }, {
      key: "activateSearch",
      value: function activateSearch(container) {
        var input = container.querySelector(this.options.selectorSearchInput);
        container.classList.add(this.options.classToolbarSearchActive);
        input.focus();
      }
    }, {
      key: "deactivateSearch",
      value: function deactivateSearch(container, evt) {
        var trigger = container.querySelector(this.options.selectorSearchMagnifier);
        var input = container.querySelector(this.options.selectorSearchInput);
        var svg = trigger.querySelector('svg');

        if (input.value.length === 0 && evt.target !== input && evt.target !== trigger && evt.target !== svg) {
          container.classList.remove(this.options.classToolbarSearchActive);
          trigger.focus();
        }

        if (evt.which === 27 && evt.target === input) {
          container.classList.remove(this.options.classToolbarSearchActive);
          trigger.focus();
        }
      }
    }, {
      key: "_changeState",
      value: function _changeState(detail, callback) {
        this[this.constructor.eventHandlers[detail.group]](detail);
        callback();
      }
    }], [{
      key: "options",
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: "[data-table]",
          selectorToolbar: ".".concat(prefix, "--table--toolbar"),
          selectorActions: ".".concat(prefix, "--batch-actions"),
          selectorCount: '[data-items-selected]',
          selectorActionCancel: ".".concat(prefix, "--batch-summary__cancel"),
          selectorCheckbox: ".".concat(prefix, "--checkbox"),
          selectorExpandHeader: "th.".concat(prefix, "--table-expand"),
          selectorExpandCells: "td.".concat(prefix, "--table-expand"),
          selectorExpandableRows: ".".concat(prefix, "--expandable-row"),
          selectorParentRows: ".".concat(prefix, "--parent-row"),
          selectorChildRow: '[data-child-row]',
          selectorTableBody: 'tbody',
          selectorTableSort: ".".concat(prefix, "--table-sort"),
          selectorTableSelected: ".".concat(prefix, "--data-table--selected"),
          selectorToolbarSearchContainer: ".".concat(prefix, "--toolbar-search-container-expandable"),
          selectorSearchMagnifier: ".".concat(prefix, "--search-magnifier"),
          selectorSearchInput: ".".concat(prefix, "--search-input"),
          classExpandableRow: "".concat(prefix, "--expandable-row"),
          classExpandableRowHidden: "".concat(prefix, "--expandable-row--hidden"),
          classExpandableRowHover: "".concat(prefix, "--expandable-row--hover"),
          classTableSortAscending: "".concat(prefix, "--table-sort--ascending"),
          classTableSortActive: "".concat(prefix, "--table-sort--active"),
          classToolbarSearchActive: "".concat(prefix, "--toolbar-search-container-active"),
          classActionBarActive: "".concat(prefix, "--batch-actions--active"),
          classTableSelected: "".concat(prefix, "--data-table--selected"),
          eventBeforeExpand: "data-table-beforetoggleexpand",
          eventAfterExpand: "data-table-aftertoggleexpand",
          eventBeforeExpandAll: "data-table-beforetoggleexpandall",
          eventAfterExpandAll: "data-table-aftertoggleexpandall",
          eventBeforeSort: "data-table-beforetogglesort",
          eventAfterSort: "data-table-aftertogglesort",
          eventTrigger: '[data-event]',
          eventParentContainer: '[data-parent-row]'
        };
      }
    }]);

    DataTable.components = new WeakMap();
    DataTable.eventHandlers = {
      expand: '_rowExpandToggle',
      expandAll: '_rowExpandToggleAll',
      sort: '_sortToggle',
      select: '_selectToggle',
      'select-all': '_selectAllToggle',
      'action-bar-cancel': '_actionBarCancel'
    };
    return DataTable;
  }(mixin(createComponent, initComponentBySearch, eventedState, handles));

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var flatpickr = createCommonjsModule(function (module, exports) {
    /* flatpickr v4.6.1, @license MIT */
    (function (global, factory) {
       module.exports = factory() ;
    })(commonjsGlobal, function () {
      /*! *****************************************************************************
      Copyright (c) Microsoft Corporation. All rights reserved.
      Licensed under the Apache License, Version 2.0 (the "License"); you may not use
      this file except in compliance with the License. You may obtain a copy of the
      License at http://www.apache.org/licenses/LICENSE-2.0
        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
      WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
      MERCHANTABLITY OR NON-INFRINGEMENT.
        See the Apache Version 2.0 License for specific language governing permissions
      and limitations under the License.
      ***************************************************************************** */

      var _assign = function __assign() {
        _assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];

            for (var p in s) {
              if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
          }

          return t;
        };

        return _assign.apply(this, arguments);
      };

      var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
      var defaults = {
        _disable: [],
        _enable: [],
        allowInput: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enable: [],
        enableSeconds: false,
        enableTime: false,
        errorHandler: function errorHandler(err) {
          return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function getWeek(givenDate) {
          var date = new Date(givenDate.getTime());
          date.setHours(0, 0, 0, 0); // Thursday in current week decides the year.

          date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7); // January 4 is always in week 1.

          var week1 = new Date(date.getFullYear(), 0, 4); // Adjust to Thursday in week 1 and count number of weeks from date to week1.

          return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: undefined,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
      };
      var english = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function ordinal(nth) {
          var s = nth % 100;
          if (s > 3 && s < 21) return "th";

          switch (s % 10) {
            case 1:
              return "st";

            case 2:
              return "nd";

            case 3:
              return "rd";

            default:
              return "th";
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        time_24hr: false
      };

      var pad = function pad(number) {
        return ("0" + number).slice(-2);
      };

      var int = function int(bool) {
        return bool === true ? 1 : 0;
      };
      /* istanbul ignore next */


      function debounce(func, wait, immediate) {
        if (immediate === void 0) {
          immediate = false;
        }

        var timeout;
        return function () {
          var context = this,
              args = arguments;
          timeout !== null && clearTimeout(timeout);
          timeout = window.setTimeout(function () {
            timeout = null;
            if (!immediate) func.apply(context, args);
          }, wait);
          if (immediate && !timeout) func.apply(context, args);
        };
      }

      var arrayify = function arrayify(obj) {
        return obj instanceof Array ? obj : [obj];
      };

      function toggleClass(elem, className, bool) {
        if (bool === true) return elem.classList.add(className);
        elem.classList.remove(className);
      }

      function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== undefined) e.textContent = content;
        return e;
      }

      function clearNode(node) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      }

      function findParent(node, condition) {
        if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);
        return undefined; // nothing found
      }

      function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"),
            numInput = createElement("input", "numInput " + inputClassName),
            arrowUp = createElement("span", "arrowUp"),
            arrowDown = createElement("span", "arrowDown");

        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
          numInput.type = "number";
        } else {
          numInput.type = "text";
          numInput.pattern = "\\d*";
        }

        if (opts !== undefined) for (var key in opts) {
          numInput.setAttribute(key, opts[key]);
        }
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
      }

      function getEventTarget(event) {
        if (typeof event.composedPath === "function") {
          var path = event.composedPath();
          return path[0];
        }

        return event.target;
      }

      var doNothing = function doNothing() {
        return undefined;
      };

      var monthToStr = function monthToStr(monthNumber, shorthand, locale) {
        return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
      };

      var revFormat = {
        D: doNothing,
        F: function F(dateObj, monthName, locale) {
          dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function G(dateObj, hour) {
          dateObj.setHours(parseFloat(hour));
        },
        H: function H(dateObj, hour) {
          dateObj.setHours(parseFloat(hour));
        },
        J: function J(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        K: function K(dateObj, amPM, locale) {
          dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function M(dateObj, shortMonth, locale) {
          dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function S(dateObj, seconds) {
          dateObj.setSeconds(parseFloat(seconds));
        },
        U: function U(_, unixSeconds) {
          return new Date(parseFloat(unixSeconds) * 1000);
        },
        W: function W(dateObj, weekNum, locale) {
          var weekNumber = parseInt(weekNum);
          var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
          date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
          return date;
        },
        Y: function Y(dateObj, year) {
          dateObj.setFullYear(parseFloat(year));
        },
        Z: function Z(_, ISODate) {
          return new Date(ISODate);
        },
        d: function d(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        h: function h(dateObj, hour) {
          dateObj.setHours(parseFloat(hour));
        },
        i: function i(dateObj, minutes) {
          dateObj.setMinutes(parseFloat(minutes));
        },
        j: function j(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        l: doNothing,
        m: function m(dateObj, month) {
          dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function n(dateObj, month) {
          dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function s(dateObj, seconds) {
          dateObj.setSeconds(parseFloat(seconds));
        },
        u: function u(_, unixMillSeconds) {
          return new Date(parseFloat(unixMillSeconds));
        },
        w: doNothing,
        y: function y(dateObj, year) {
          dateObj.setFullYear(2000 + parseFloat(year));
        }
      };
      var tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
      };
      var formats = {
        // get the date in UTC
        Z: function Z(date) {
          return date.toISOString();
        },
        // weekday name, short, e.g. Thu
        D: function D(date, locale, options) {
          return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        // full month name e.g. January
        F: function F(date, locale, options) {
          return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        // padded hour 1-12
        G: function G(date, locale, options) {
          return pad(formats.h(date, locale, options));
        },
        // hours with leading zero e.g. 03
        H: function H(date) {
          return pad(date.getHours());
        },
        // day (1-30) with ordinal suffix e.g. 1st, 2nd
        J: function J(date, locale) {
          return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
        },
        // AM/PM
        K: function K(date, locale) {
          return locale.amPM[int(date.getHours() > 11)];
        },
        // shorthand month e.g. Jan, Sep, Oct, etc
        M: function M(date, locale) {
          return monthToStr(date.getMonth(), true, locale);
        },
        // seconds 00-59
        S: function S(date) {
          return pad(date.getSeconds());
        },
        // unix timestamp
        U: function U(date) {
          return date.getTime() / 1000;
        },
        W: function W(date, _, options) {
          return options.getWeek(date);
        },
        // full year e.g. 2016
        Y: function Y(date) {
          return date.getFullYear();
        },
        // day in month, padded (01-30)
        d: function d(date) {
          return pad(date.getDate());
        },
        // hour from 1-12 (am/pm)
        h: function h(date) {
          return date.getHours() % 12 ? date.getHours() % 12 : 12;
        },
        // minutes, padded with leading zero e.g. 09
        i: function i(date) {
          return pad(date.getMinutes());
        },
        // day in month (1-30)
        j: function j(date) {
          return date.getDate();
        },
        // weekday name, full, e.g. Thursday
        l: function l(date, locale) {
          return locale.weekdays.longhand[date.getDay()];
        },
        // padded month number (01-12)
        m: function m(date) {
          return pad(date.getMonth() + 1);
        },
        // the month number (1-12)
        n: function n(date) {
          return date.getMonth() + 1;
        },
        // seconds 0-59
        s: function s(date) {
          return date.getSeconds();
        },
        // Unix Milliseconds
        u: function u(date) {
          return date.getTime();
        },
        // number of the day of the week
        w: function w(date) {
          return date.getDay();
        },
        // last two digits of year e.g. 16 for 2016
        y: function y(date) {
          return String(date.getFullYear()).substring(2);
        }
      };

      var createDateFormatter = function createDateFormatter(_a) {
        var _b = _a.config,
            config = _b === void 0 ? defaults : _b,
            _c = _a.l10n,
            l10n = _c === void 0 ? english : _c;
        return function (dateObj, frmt, overrideLocale) {
          var locale = overrideLocale || l10n;

          if (config.formatDate !== undefined) {
            return config.formatDate(dateObj, frmt, locale);
          }

          return frmt.split("").map(function (c, i, arr) {
            return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
          }).join("");
        };
      };

      var createDateParser = function createDateParser(_a) {
        var _b = _a.config,
            config = _b === void 0 ? defaults : _b,
            _c = _a.l10n,
            l10n = _c === void 0 ? english : _c;
        return function (date, givenFormat, timeless, customLocale) {
          if (date !== 0 && !date) return undefined;
          var locale = customLocale || l10n;
          var parsedDate;
          var dateOrig = date;
          if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== "string" && date.toFixed !== undefined // timestamp
          ) // create a copy
            parsedDate = new Date(date);else if (typeof date === "string") {
            // date string
            var format = givenFormat || (config || defaults).dateFormat;
            var datestr = String(date).trim();

            if (datestr === "today") {
              parsedDate = new Date();
              timeless = true;
            } else if (/Z$/.test(datestr) || /GMT$/.test(datestr) // datestrings w/ timezone
            ) parsedDate = new Date(date);else if (config && config.parseDate) parsedDate = config.parseDate(date, format);else {
              parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
              var matched = void 0,
                  ops = [];

              for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                var token_1 = format[i];
                var isBackSlash = token_1 === "\\";
                var escaped = format[i - 1] === "\\" || isBackSlash;

                if (tokenRegex[token_1] && !escaped) {
                  regexStr += tokenRegex[token_1];
                  var match = new RegExp(regexStr).exec(date);

                  if (match && (matched = true)) {
                    ops[token_1 !== "Y" ? "push" : "unshift"]({
                      fn: revFormat[token_1],
                      val: match[++matchIndex]
                    });
                  }
                } else if (!isBackSlash) regexStr += "."; // don't really care


                ops.forEach(function (_a) {
                  var fn = _a.fn,
                      val = _a.val;
                  return parsedDate = fn(parsedDate, val, locale) || parsedDate;
                });
              }

              parsedDate = matched ? parsedDate : undefined;
            }
          }
          /* istanbul ignore next */

          if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
            config.errorHandler(new Error("Invalid date provided: " + dateOrig));
            return undefined;
          }

          if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
          return parsedDate;
        };
      };
      /**
       * Compute the difference in dates, measured in ms
       */


      function compareDates(date1, date2, timeless) {
        if (timeless === void 0) {
          timeless = true;
        }

        if (timeless !== false) {
          return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
        }

        return date1.getTime() - date2.getTime();
      }

      var isBetween = function isBetween(ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
      };

      var duration = {
        DAY: 86400000
      };

      if (typeof Object.assign !== "function") {
        Object.assign = function (target) {
          var args = [];

          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }

          if (!target) {
            throw TypeError("Cannot convert undefined or null to object");
          }

          var _loop_1 = function _loop_1(source) {
            if (source) {
              Object.keys(source).forEach(function (key) {
                return target[key] = source[key];
              });
            }
          };

          for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var source = args_1[_a];

            _loop_1(source);
          }

          return target;
        };
      }

      var DEBOUNCED_CHANGE_MS = 300;

      function FlatpickrInstance(element, instanceConfig) {
        var self = {
          config: _assign({}, defaults, flatpickr.defaultConfig),
          l10n: english
        };
        self.parseDate = createDateParser({
          config: self.config,
          l10n: self.l10n
        });
        self._handlers = [];
        self.pluginElements = [];
        self.loadedPlugins = [];
        self._bind = bind;
        self._setHoursFromDate = setHoursFromDate;
        self._positionCalendar = positionCalendar;
        self.changeMonth = changeMonth;
        self.changeYear = changeYear;
        self.clear = clear;
        self.close = close;
        self._createElement = createElement;
        self.destroy = destroy;
        self.isEnabled = isEnabled;
        self.jumpToDate = jumpToDate;
        self.open = open;
        self.redraw = redraw;
        self.set = set;
        self.setDate = setDate;
        self.toggle = toggle;

        function setupHelperFunctions() {
          self.utils = {
            getDaysInMonth: function getDaysInMonth(month, yr) {
              if (month === void 0) {
                month = self.currentMonth;
              }

              if (yr === void 0) {
                yr = self.currentYear;
              }

              if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
              return self.l10n.daysInMonth[month];
            }
          };
        }

        function init() {
          self.element = self.input = element;
          self.isOpen = false;
          parseConfig();
          setupLocale();
          setupInputs();
          setupDates();
          setupHelperFunctions();
          if (!self.isMobile) build();
          bindEvents();

          if (self.selectedDates.length || self.config.noCalendar) {
            if (self.config.enableTime) {
              setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : undefined);
            }

            updateValue(false);
          }

          setCalendarWidth();
          self.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;
          var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          /* TODO: investigate this further
                     Currently, there is weird positioning behavior in safari causing pages
            to scroll up. https://github.com/chmln/flatpickr/issues/563
                     However, most browsers are not Safari and positioning is expensive when used
            in scale. https://github.com/chmln/flatpickr/issues/1096
          */

          if (!self.isMobile && isSafari) {
            positionCalendar();
          }

          triggerEvent("onReady");
        }

        function bindToInstance(fn) {
          return fn.bind(self);
        }

        function setCalendarWidth() {
          var config = self.config;
          if (config.weekNumbers === false && config.showMonths === 1) return;else if (config.noCalendar !== true) {
            window.requestAnimationFrame(function () {
              if (self.calendarContainer !== undefined) {
                self.calendarContainer.style.visibility = "hidden";
                self.calendarContainer.style.display = "block";
              }

              if (self.daysContainer !== undefined) {
                var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                self.daysContainer.style.width = daysWidth + "px";
                self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
                self.calendarContainer.style.removeProperty("visibility");
                self.calendarContainer.style.removeProperty("display");
              }
            });
          }
        }
        /**
         * The handler for all events targeting the time inputs
         */


        function updateTime(e) {
          if (self.selectedDates.length === 0) {
            setDefaultTime();
          }

          if (e !== undefined && e.type !== "blur") {
            timeWrapper(e);
          }

          var prevValue = self._input.value;
          setHoursFromInputs();
          updateValue();

          if (self._input.value !== prevValue) {
            self._debouncedChange();
          }
        }

        function ampm2military(hour, amPM) {
          return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
        }

        function military2ampm(hour) {
          switch (hour % 24) {
            case 0:
            case 12:
              return 12;

            default:
              return hour % 12;
          }
        }
        /**
         * Syncs the selected date object time with user's time input
         */


        function setHoursFromInputs() {
          if (self.hourElement === undefined || self.minuteElement === undefined) return;
          var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
              minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
              seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;

          if (self.amPM !== undefined) {
            hours = ampm2military(hours, self.amPM.textContent);
          }

          var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
          var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;

          if (limitMaxHours) {
            var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
            hours = Math.min(hours, maxTime.getHours());
            if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
            if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
          }

          if (limitMinHours) {
            var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
            hours = Math.max(hours, minTime.getHours());
            if (hours === minTime.getHours()) minutes = Math.max(minutes, minTime.getMinutes());
            if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
          }

          setHours(hours, minutes, seconds);
        }
        /**
         * Syncs time input values with a date
         */


        function setHoursFromDate(dateObj) {
          var date = dateObj || self.latestSelectedDateObj;
          if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }

        function setDefaultHours() {
          var hours = self.config.defaultHour;
          var minutes = self.config.defaultMinute;
          var seconds = self.config.defaultSeconds;

          if (self.config.minDate !== undefined) {
            var minHr = self.config.minDate.getHours();
            var minMinutes = self.config.minDate.getMinutes();
            hours = Math.max(hours, minHr);
            if (hours === minHr) minutes = Math.max(minMinutes, minutes);
            if (hours === minHr && minutes === minMinutes) seconds = self.config.minDate.getSeconds();
          }

          if (self.config.maxDate !== undefined) {
            var maxHr = self.config.maxDate.getHours();
            var maxMinutes = self.config.maxDate.getMinutes();
            hours = Math.min(hours, maxHr);
            if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
            if (hours === maxHr && minutes === maxMinutes) seconds = self.config.maxDate.getSeconds();
          }

          setHours(hours, minutes, seconds);
        }
        /**
         * Sets the hours, minutes, and optionally seconds
         * of the latest selected date object and the
         * corresponding time inputs
         * @param {Number} hours the hour. whether its military
         *                 or am-pm gets inferred from config
         * @param {Number} minutes the minutes
         * @param {Number} seconds the seconds (optional)
         */


        function setHours(hours, minutes, seconds) {
          if (self.latestSelectedDateObj !== undefined) {
            self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
          }

          if (!self.hourElement || !self.minuteElement || self.isMobile) return;
          self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
          self.minuteElement.value = pad(minutes);
          if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
          if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);
        }
        /**
         * Handles the year input and incrementing events
         * @param {Event} event the keyup or increment event
         */


        function onYearInput(event) {
          var year = parseInt(event.target.value) + (event.delta || 0);

          if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
            changeYear(year);
          }
        }
        /**
         * Essentially addEventListener + tracking
         * @param {Element} element the element to addEventListener to
         * @param {String} event the event name
         * @param {Function} handler the event handler
         */


        function bind(element, event, handler, options) {
          if (event instanceof Array) return event.forEach(function (ev) {
            return bind(element, ev, handler, options);
          });
          if (element instanceof Array) return element.forEach(function (el) {
            return bind(el, event, handler, options);
          });
          element.addEventListener(event, handler, options);

          self._handlers.push({
            element: element,
            event: event,
            handler: handler,
            options: options
          });
        }
        /**
         * A mousedown handler which mimics click.
         * Minimizes latency, since we don't need to wait for mouseup in most cases.
         * Also, avoids handling right clicks.
         *
         * @param {Function} handler the event handler
         */


        function onClick(handler) {
          return function (evt) {
            evt.which === 1 && handler(evt);
          };
        }

        function triggerChange() {
          triggerEvent("onChange");
        }
        /**
         * Adds all the necessary event listeners
         */


        function bindEvents() {
          if (self.config.wrap) {
            ["open", "close", "toggle", "clear"].forEach(function (evt) {
              Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                return bind(el, "click", self[evt]);
              });
            });
          }

          if (self.isMobile) {
            setupMobile();
            return;
          }

          var debouncedResize = debounce(onResize, 50);
          self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
          if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function (e) {
            if (self.config.mode === "range") onMouseOver(e.target);
          });
          bind(window.document.body, "keydown", onKeyDown);
          if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
          if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);else bind(window.document, "mousedown", onClick(documentClick));
          bind(window.document, "focus", documentClick, {
            capture: true
          });

          if (self.config.clickOpens === true) {
            bind(self._input, "focus", self.open);
            bind(self._input, "mousedown", onClick(self.open));
          }

          if (self.daysContainer !== undefined) {
            bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
            bind(self.monthNav, ["keyup", "increment"], onYearInput);
            bind(self.daysContainer, "mousedown", onClick(selectDate));
          }

          if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
            var selText = function selText(e) {
              return e.target.select();
            };

            bind(self.timeContainer, ["increment"], updateTime);
            bind(self.timeContainer, "blur", updateTime, {
              capture: true
            });
            bind(self.timeContainer, "mousedown", onClick(timeIncrement));
            bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
            if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
              return self.secondElement && self.secondElement.select();
            });

            if (self.amPM !== undefined) {
              bind(self.amPM, "mousedown", onClick(function (e) {
                updateTime(e);
                triggerChange();
              }));
            }
          }
        }
        /**
         * Set the calendar view to a particular date.
         * @param {Date} jumpDate the date to set the view to
         * @param {boolean} triggerChange if change events should be triggered
         */


        function jumpToDate(jumpDate, triggerChange) {
          var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
          var oldYear = self.currentYear;
          var oldMonth = self.currentMonth;

          try {
            if (jumpTo !== undefined) {
              self.currentYear = jumpTo.getFullYear();
              self.currentMonth = jumpTo.getMonth();
            }
          } catch (e) {
            /* istanbul ignore next */
            e.message = "Invalid date supplied: " + jumpTo;
            self.config.errorHandler(e);
          }

          if (triggerChange && self.currentYear !== oldYear) {
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }

          if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
            triggerEvent("onMonthChange");
          }

          self.redraw();
        }
        /**
         * The up/down arrow handler for time inputs
         * @param {Event} e the click event
         */


        function timeIncrement(e) {
          if (~e.target.className.indexOf("arrow")) incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
        }
        /**
         * Increments/decrements the value of input associ-
         * ated with the up/down arrow by dispatching an
         * "increment" event on the input.
         *
         * @param {Event} e the click event
         * @param {Number} delta the diff (usually 1 or -1)
         * @param {Element} inputElem the input element
         */


        function incrementNumInput(e, delta, inputElem) {
          var target = e && e.target;
          var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
          var event = createEvent("increment");
          event.delta = delta;
          input && input.dispatchEvent(event);
        }

        function build() {
          var fragment = window.document.createDocumentFragment();
          self.calendarContainer = createElement("div", "flatpickr-calendar");
          self.calendarContainer.tabIndex = -1;

          if (!self.config.noCalendar) {
            fragment.appendChild(buildMonthNav());
            self.innerContainer = createElement("div", "flatpickr-innerContainer");

            if (self.config.weekNumbers) {
              var _a = buildWeeks(),
                  weekWrapper = _a.weekWrapper,
                  weekNumbers = _a.weekNumbers;

              self.innerContainer.appendChild(weekWrapper);
              self.weekNumbers = weekNumbers;
              self.weekWrapper = weekWrapper;
            }

            self.rContainer = createElement("div", "flatpickr-rContainer");
            self.rContainer.appendChild(buildWeekdays());

            if (!self.daysContainer) {
              self.daysContainer = createElement("div", "flatpickr-days");
              self.daysContainer.tabIndex = -1;
            }

            buildDays();
            self.rContainer.appendChild(self.daysContainer);
            self.innerContainer.appendChild(self.rContainer);
            fragment.appendChild(self.innerContainer);
          }

          if (self.config.enableTime) {
            fragment.appendChild(buildTime());
          }

          toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
          toggleClass(self.calendarContainer, "animate", self.config.animate === true);
          toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
          self.calendarContainer.appendChild(fragment);
          var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;

          if (self.config.inline || self.config.static) {
            self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");

            if (self.config.inline) {
              if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
            }

            if (self.config.static) {
              var wrapper = createElement("div", "flatpickr-wrapper");
              if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
              wrapper.appendChild(self.element);
              if (self.altInput) wrapper.appendChild(self.altInput);
              wrapper.appendChild(self.calendarContainer);
            }
          }

          if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
        }

        function createDay(className, date, dayNumber, i) {
          var dateIsEnabled = isEnabled(date, true),
              dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
          dayElement.dateObj = date;
          dayElement.$i = i;
          dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));

          if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
            self.todayDateElem = dayElement;
            dayElement.classList.add("today");
            dayElement.setAttribute("aria-current", "date");
          }

          if (dateIsEnabled) {
            dayElement.tabIndex = -1;

            if (isDateSelected(date)) {
              dayElement.classList.add("selected");
              self.selectedDateElem = dayElement;

              if (self.config.mode === "range") {
                toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
                toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
                if (className === "nextMonthDay") dayElement.classList.add("inRange");
              }
            }
          } else {
            dayElement.classList.add("flatpickr-disabled");
          }

          if (self.config.mode === "range") {
            if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
          }

          if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
            self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
          }

          triggerEvent("onDayCreate", dayElement);
          return dayElement;
        }

        function focusOnDayElem(targetNode) {
          targetNode.focus();
          if (self.config.mode === "range") onMouseOver(targetNode);
        }

        function getFirstAvailableDay(delta) {
          var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
          var endMonth = delta > 0 ? self.config.showMonths : -1;

          for (var m = startMonth; m != endMonth; m += delta) {
            var month = self.daysContainer.children[m];
            var startIndex = delta > 0 ? 0 : month.children.length - 1;
            var endIndex = delta > 0 ? month.children.length : -1;

            for (var i = startIndex; i != endIndex; i += delta) {
              var c = month.children[i];
              if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
            }
          }

          return undefined;
        }

        function getNextAvailableDay(current, delta) {
          var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
          var endMonth = delta > 0 ? self.config.showMonths : -1;
          var loopDelta = delta > 0 ? 1 : -1;

          for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
            var month = self.daysContainer.children[m];
            var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
            var numMonthDays = month.children.length;

            for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
              var c = month.children[i];
              if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
            }
          }

          self.changeMonth(loopDelta);
          focusOnDay(getFirstAvailableDay(loopDelta), 0);
          return undefined;
        }

        function focusOnDay(current, offset) {
          var dayFocused = isInView(document.activeElement || document.body);
          var startElem = current !== undefined ? current : dayFocused ? document.activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
          if (startElem === undefined) return self._input.focus();
          if (!dayFocused) return focusOnDayElem(startElem);
          getNextAvailableDay(startElem, offset);
        }

        function buildMonthDays(year, month) {
          var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
          var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
          var daysInMonth = self.utils.getDaysInMonth(month),
              days = window.document.createDocumentFragment(),
              isMultiMonth = self.config.showMonths > 1,
              prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay",
              nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
          var dayNumber = prevMonthDays + 1 - firstOfMonth,
              dayIndex = 0; // prepend days from the ending of previous month

          for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
            days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
          } // Start at 1 since there is no 0th day


          for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
            days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
          } // append days from the next month


          for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
            days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
          } //updateNavigationCurrentMonth();


          var dayContainer = createElement("div", "dayContainer");
          dayContainer.appendChild(days);
          return dayContainer;
        }

        function buildDays() {
          if (self.daysContainer === undefined) {
            return;
          }

          clearNode(self.daysContainer); // TODO: week numbers for each month

          if (self.weekNumbers) clearNode(self.weekNumbers);
          var frag = document.createDocumentFragment();

          for (var i = 0; i < self.config.showMonths; i++) {
            var d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i);
            frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
          }

          self.daysContainer.appendChild(frag);
          self.days = self.daysContainer.firstChild;

          if (self.config.mode === "range" && self.selectedDates.length === 1) {
            onMouseOver();
          }
        }

        function buildMonthSwitch() {
          if (self.config.showMonths > 1) return;

          var shouldBuildMonth = function shouldBuildMonth(month) {
            if (self.config.minDate !== undefined && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) {
              return false;
            }

            return !(self.config.maxDate !== undefined && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
          };

          self.monthsDropdownContainer.tabIndex = -1;
          self.monthsDropdownContainer.innerHTML = "";

          for (var i = 0; i < 12; i++) {
            if (!shouldBuildMonth(i)) continue;
            var month = createElement("option", "flatpickr-monthDropdown-month");
            month.value = new Date(self.currentYear, i).getMonth().toString();
            month.textContent = monthToStr(i, false, self.l10n);
            month.tabIndex = -1;

            if (self.currentMonth === i) {
              month.selected = true;
            }

            self.monthsDropdownContainer.appendChild(month);
          }
        }

        function buildMonth() {
          var container = createElement("div", "flatpickr-month");
          var monthNavFragment = window.document.createDocumentFragment();
          var monthElement;

          if (self.config.showMonths > 1) {
            monthElement = createElement("span", "cur-month");
          } else {
            self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
            bind(self.monthsDropdownContainer, "change", function (e) {
              var target = e.target;
              var selectedMonth = parseInt(target.value, 10);
              self.changeMonth(selectedMonth - self.currentMonth);
              triggerEvent("onMonthChange");
            });
            buildMonthSwitch();
            monthElement = self.monthsDropdownContainer;
          }

          var yearInput = createNumberInput("cur-year", {
            tabindex: "-1"
          });
          var yearElement = yearInput.getElementsByTagName("input")[0];
          yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);

          if (self.config.minDate) {
            yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
          }

          if (self.config.maxDate) {
            yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
            yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
          }

          var currentMonth = createElement("div", "flatpickr-current-month");
          currentMonth.appendChild(monthElement);
          currentMonth.appendChild(yearInput);
          monthNavFragment.appendChild(currentMonth);
          container.appendChild(monthNavFragment);
          return {
            container: container,
            yearElement: yearElement,
            monthElement: monthElement
          };
        }

        function buildMonths() {
          clearNode(self.monthNav);
          self.monthNav.appendChild(self.prevMonthNav);

          if (self.config.showMonths) {
            self.yearElements = [];
            self.monthElements = [];
          }

          for (var m = self.config.showMonths; m--;) {
            var month = buildMonth();
            self.yearElements.push(month.yearElement);
            self.monthElements.push(month.monthElement);
            self.monthNav.appendChild(month.container);
          }

          self.monthNav.appendChild(self.nextMonthNav);
        }

        function buildMonthNav() {
          self.monthNav = createElement("div", "flatpickr-months");
          self.yearElements = [];
          self.monthElements = [];
          self.prevMonthNav = createElement("span", "flatpickr-prev-month");
          self.prevMonthNav.innerHTML = self.config.prevArrow;
          self.nextMonthNav = createElement("span", "flatpickr-next-month");
          self.nextMonthNav.innerHTML = self.config.nextArrow;
          buildMonths();
          Object.defineProperty(self, "_hidePrevMonthArrow", {
            get: function get() {
              return self.__hidePrevMonthArrow;
            },
            set: function set(bool) {
              if (self.__hidePrevMonthArrow !== bool) {
                toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                self.__hidePrevMonthArrow = bool;
              }
            }
          });
          Object.defineProperty(self, "_hideNextMonthArrow", {
            get: function get() {
              return self.__hideNextMonthArrow;
            },
            set: function set(bool) {
              if (self.__hideNextMonthArrow !== bool) {
                toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                self.__hideNextMonthArrow = bool;
              }
            }
          });
          self.currentYearElement = self.yearElements[0];
          updateNavigationCurrentMonth();
          return self.monthNav;
        }

        function buildTime() {
          self.calendarContainer.classList.add("hasTime");
          if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
          self.timeContainer = createElement("div", "flatpickr-time");
          self.timeContainer.tabIndex = -1;
          var separator = createElement("span", "flatpickr-time-separator", ":");
          var hourInput = createNumberInput("flatpickr-hour");
          self.hourElement = hourInput.getElementsByTagName("input")[0];
          var minuteInput = createNumberInput("flatpickr-minute");
          self.minuteElement = minuteInput.getElementsByTagName("input")[0];
          self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
          self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? self.config.defaultHour : military2ampm(self.config.defaultHour));
          self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);
          self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
          self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
          self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
          self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
          self.minuteElement.setAttribute("min", "0");
          self.minuteElement.setAttribute("max", "59");
          self.timeContainer.appendChild(hourInput);
          self.timeContainer.appendChild(separator);
          self.timeContainer.appendChild(minuteInput);
          if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

          if (self.config.enableSeconds) {
            self.timeContainer.classList.add("hasSeconds");
            var secondInput = createNumberInput("flatpickr-second");
            self.secondElement = secondInput.getElementsByTagName("input")[0];
            self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds);
            self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
            self.secondElement.setAttribute("min", "0");
            self.secondElement.setAttribute("max", "59");
            self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
            self.timeContainer.appendChild(secondInput);
          }

          if (!self.config.time_24hr) {
            // add self.amPM if appropriate
            self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
            self.amPM.title = self.l10n.toggleTitle;
            self.amPM.tabIndex = -1;
            self.timeContainer.appendChild(self.amPM);
          }

          return self.timeContainer;
        }

        function buildWeekdays() {
          if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");else clearNode(self.weekdayContainer);

          for (var i = self.config.showMonths; i--;) {
            var container = createElement("div", "flatpickr-weekdaycontainer");
            self.weekdayContainer.appendChild(container);
          }

          updateWeekdays();
          return self.weekdayContainer;
        }

        function updateWeekdays() {
          var firstDayOfWeek = self.l10n.firstDayOfWeek;
          var weekdays = self.l10n.weekdays.shorthand.slice();

          if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
            weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
          }

          for (var i = self.config.showMonths; i--;) {
            self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
          }
        }
        /* istanbul ignore next */


        function buildWeeks() {
          self.calendarContainer.classList.add("hasWeeks");
          var weekWrapper = createElement("div", "flatpickr-weekwrapper");
          weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
          var weekNumbers = createElement("div", "flatpickr-weeks");
          weekWrapper.appendChild(weekNumbers);
          return {
            weekWrapper: weekWrapper,
            weekNumbers: weekNumbers
          };
        }

        function changeMonth(value, isOffset) {
          if (isOffset === void 0) {
            isOffset = true;
          }

          var delta = isOffset ? value : value - self.currentMonth;
          if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
          self.currentMonth += delta;

          if (self.currentMonth < 0 || self.currentMonth > 11) {
            self.currentYear += self.currentMonth > 11 ? 1 : -1;
            self.currentMonth = (self.currentMonth + 12) % 12;
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }

          buildDays();
          triggerEvent("onMonthChange");
          updateNavigationCurrentMonth();
        }

        function clear(triggerChangeEvent, toInitial) {
          if (triggerChangeEvent === void 0) {
            triggerChangeEvent = true;
          }

          if (toInitial === void 0) {
            toInitial = true;
          }

          self.input.value = "";
          if (self.altInput !== undefined) self.altInput.value = "";
          if (self.mobileInput !== undefined) self.mobileInput.value = "";
          self.selectedDates = [];
          self.latestSelectedDateObj = undefined;

          if (toInitial === true) {
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
          }

          self.showTimeInput = false;

          if (self.config.enableTime === true) {
            setDefaultHours();
          }

          self.redraw();
          if (triggerChangeEvent) // triggerChangeEvent is true (default) or an Event
            triggerEvent("onChange");
        }

        function close() {
          self.isOpen = false;

          if (!self.isMobile) {
            if (self.calendarContainer !== undefined) {
              self.calendarContainer.classList.remove("open");
            }

            if (self._input !== undefined) {
              self._input.classList.remove("active");
            }
          }

          triggerEvent("onClose");
        }

        function destroy() {
          if (self.config !== undefined) triggerEvent("onDestroy");

          for (var i = self._handlers.length; i--;) {
            var h = self._handlers[i];
            h.element.removeEventListener(h.event, h.handler, h.options);
          }

          self._handlers = [];

          if (self.mobileInput) {
            if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
            self.mobileInput = undefined;
          } else if (self.calendarContainer && self.calendarContainer.parentNode) {
            if (self.config.static && self.calendarContainer.parentNode) {
              var wrapper = self.calendarContainer.parentNode;
              wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);

              if (wrapper.parentNode) {
                while (wrapper.firstChild) {
                  wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                }

                wrapper.parentNode.removeChild(wrapper);
              }
            } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
          }

          if (self.altInput) {
            self.input.type = "text";
            if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
            delete self.altInput;
          }

          if (self.input) {
            self.input.type = self.input._type;
            self.input.classList.remove("flatpickr-input");
            self.input.removeAttribute("readonly");
            self.input.value = "";
          }

          ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
            try {
              delete self[k];
            } catch (_) {}
          });
        }

        function isCalendarElem(elem) {
          if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;
          return self.calendarContainer.contains(elem);
        }

        function documentClick(e) {
          if (self.isOpen && !self.config.inline) {
            var eventTarget_1 = getEventTarget(e);
            var isCalendarElement = isCalendarElem(eventTarget_1);
            var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || // web components
            // e.path is not present in all browsers. circumventing typechecks
            e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
            var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
            var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
              return elem.contains(eventTarget_1);
            });

            if (lostFocus && isIgnored) {
              self.close();

              if (self.config.mode === "range" && self.selectedDates.length === 1) {
                self.clear(false);
                self.redraw();
              }
            }
          }
        }

        function changeYear(newYear) {
          if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
          var newYearNum = newYear,
              isNewYear = self.currentYear !== newYearNum;
          self.currentYear = newYearNum || self.currentYear;

          if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
            self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
          } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
            self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
          }

          if (isNewYear) {
            self.redraw();
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }
        }

        function isEnabled(date, timeless) {
          if (timeless === void 0) {
            timeless = true;
          }

          var dateToCheck = self.parseDate(date, undefined, timeless); // timeless

          if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
          if (self.config.enable.length === 0 && self.config.disable.length === 0) return true;
          if (dateToCheck === undefined) return false;
          var bool = self.config.enable.length > 0,
              array = bool ? self.config.enable : self.config.disable;

          for (var i = 0, d = void 0; i < array.length; i++) {
            d = array[i];
            if (typeof d === "function" && d(dateToCheck) // disabled by function
            ) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) // disabled by date
              return bool;else if (typeof d === "string" && dateToCheck !== undefined) {
              // disabled by date string
              var parsed = self.parseDate(d, undefined, true);
              return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
            } else if ( // disabled by range
            _typeof(d) === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
          }

          return !bool;
        }

        function isInView(elem) {
          if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && self.daysContainer.contains(elem);
          return false;
        }

        function onKeyDown(e) {
          // e.key                      e.keyCode
          // "Backspace"                        8
          // "Tab"                              9
          // "Enter"                           13
          // "Escape"     (IE "Esc")           27
          // "ArrowLeft"  (IE "Left")          37
          // "ArrowUp"    (IE "Up")            38
          // "ArrowRight" (IE "Right")         39
          // "ArrowDown"  (IE "Down")          40
          // "Delete"     (IE "Del")           46
          var isInput = e.target === self._input;
          var allowInput = self.config.allowInput;
          var allowKeydown = self.isOpen && (!allowInput || !isInput);
          var allowInlineKeydown = self.config.inline && isInput && !allowInput;

          if (e.keyCode === 13 && isInput) {
            if (allowInput) {
              self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
              return e.target.blur();
            } else {
              self.open();
            }
          } else if (isCalendarElem(e.target) || allowKeydown || allowInlineKeydown) {
            var isTimeObj = !!self.timeContainer && self.timeContainer.contains(e.target);

            switch (e.keyCode) {
              case 13:
                if (isTimeObj) {
                  e.preventDefault();
                  updateTime();
                  focusAndClose();
                } else selectDate(e);

                break;

              case 27:
                // escape
                e.preventDefault();
                focusAndClose();
                break;

              case 8:
              case 46:
                if (isInput && !self.config.allowInput) {
                  e.preventDefault();
                  self.clear();
                }

                break;

              case 37:
              case 39:
                if (!isTimeObj && !isInput) {
                  e.preventDefault();

                  if (self.daysContainer !== undefined && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
                    var delta_1 = e.keyCode === 39 ? 1 : -1;
                    if (!e.ctrlKey) focusOnDay(undefined, delta_1);else {
                      e.stopPropagation();
                      changeMonth(delta_1);
                      focusOnDay(getFirstAvailableDay(1), 0);
                    }
                  }
                } else if (self.hourElement) self.hourElement.focus();

                break;

              case 38:
              case 40:
                e.preventDefault();
                var delta = e.keyCode === 40 ? 1 : -1;

                if (self.daysContainer && e.target.$i !== undefined || e.target === self.input) {
                  if (e.ctrlKey) {
                    e.stopPropagation();
                    changeYear(self.currentYear - delta);
                    focusOnDay(getFirstAvailableDay(1), 0);
                  } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
                } else if (e.target === self.currentYearElement) {
                  changeYear(self.currentYear - delta);
                } else if (self.config.enableTime) {
                  if (!isTimeObj && self.hourElement) self.hourElement.focus();
                  updateTime(e);

                  self._debouncedChange();
                }

                break;

              case 9:
                if (isTimeObj) {
                  var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].concat(self.pluginElements).filter(function (x) {
                    return x;
                  });
                  var i = elems.indexOf(e.target);

                  if (i !== -1) {
                    var target = elems[i + (e.shiftKey ? -1 : 1)];
                    e.preventDefault();

                    (target || self._input).focus();
                  }
                } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(e.target) && e.shiftKey) {
                  e.preventDefault();

                  self._input.focus();
                }

                break;
            }
          }

          if (self.amPM !== undefined && e.target === self.amPM) {
            switch (e.key) {
              case self.l10n.amPM[0].charAt(0):
              case self.l10n.amPM[0].charAt(0).toLowerCase():
                self.amPM.textContent = self.l10n.amPM[0];
                setHoursFromInputs();
                updateValue();
                break;

              case self.l10n.amPM[1].charAt(0):
              case self.l10n.amPM[1].charAt(0).toLowerCase():
                self.amPM.textContent = self.l10n.amPM[1];
                setHoursFromInputs();
                updateValue();
                break;
            }
          }

          if (isInput || isCalendarElem(e.target)) {
            triggerEvent("onKeyDown", e);
          }
        }

        function onMouseOver(elem) {
          if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled"))) return;
          var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(),
              initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),
              rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),
              rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
          var containsDisabled = false;
          var minRange = 0,
              maxRange = 0;

          for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
            if (!isEnabled(new Date(t), true)) {
              containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
              if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
            }
          }

          for (var m = 0; m < self.config.showMonths; m++) {
            var month = self.daysContainer.children[m];

            var _loop_1 = function _loop_1(i, l) {
              var dayElem = month.children[i],
                  date = dayElem.dateObj;
              var timestamp = date.getTime();
              var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;

              if (outOfRange) {
                dayElem.classList.add("notAllowed");
                ["inRange", "startRange", "endRange"].forEach(function (c) {
                  dayElem.classList.remove(c);
                });
                return "continue";
              } else if (containsDisabled && !outOfRange) return "continue";

              ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                dayElem.classList.remove(c);
              });

              if (elem !== undefined) {
                elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
                if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
                if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
              }
            };

            for (var i = 0, l = month.children.length; i < l; i++) {
              _loop_1(i, l);
            }
          }
        }

        function onResize() {
          if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
        }

        function setDefaultTime() {
          self.setDate(self.config.minDate !== undefined ? new Date(self.config.minDate.getTime()) : new Date(), true);
          setDefaultHours();
          updateValue();
        }

        function open(e, positionElement) {
          if (positionElement === void 0) {
            positionElement = self._positionElement;
          }

          if (self.isMobile === true) {
            if (e) {
              e.preventDefault();
              e.target && e.target.blur();
            }

            if (self.mobileInput !== undefined) {
              self.mobileInput.focus();
              self.mobileInput.click();
            }

            triggerEvent("onOpen");
            return;
          }

          if (self._input.disabled || self.config.inline) return;
          var wasOpen = self.isOpen;
          self.isOpen = true;

          if (!wasOpen) {
            self.calendarContainer.classList.add("open");

            self._input.classList.add("active");

            triggerEvent("onOpen");
            positionCalendar(positionElement);
          }

          if (self.config.enableTime === true && self.config.noCalendar === true) {
            if (self.selectedDates.length === 0) {
              setDefaultTime();
            }

            if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) {
              setTimeout(function () {
                return self.hourElement.select();
              }, 50);
            }
          }
        }

        function minMaxDateSetter(type) {
          return function (date) {
            var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
            var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];

            if (dateObj !== undefined) {
              self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
            }

            if (self.selectedDates) {
              self.selectedDates = self.selectedDates.filter(function (d) {
                return isEnabled(d);
              });
              if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
              updateValue();
            }

            if (self.daysContainer) {
              redraw();
              if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);
              self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
            }
          };
        }

        function parseConfig() {
          var boolOpts = ["wrap", "weekNumbers", "allowInput", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];

          var userConfig = _assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));

          var formats = {};
          self.config.parseDate = userConfig.parseDate;
          self.config.formatDate = userConfig.formatDate;
          Object.defineProperty(self.config, "enable", {
            get: function get() {
              return self.config._enable;
            },
            set: function set(dates) {
              self.config._enable = parseDateRules(dates);
            }
          });
          Object.defineProperty(self.config, "disable", {
            get: function get() {
              return self.config._disable;
            },
            set: function set(dates) {
              self.config._disable = parseDateRules(dates);
            }
          });
          var timeMode = userConfig.mode === "time";

          if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
            var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
            formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
          }

          if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
            var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
            formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
          }

          if (!userConfig.altInputClass) {
            self.config.altInputClass = self.input.className + " " + self.config.altInputClass;
          }

          Object.defineProperty(self.config, "minDate", {
            get: function get() {
              return self.config._minDate;
            },
            set: minMaxDateSetter("min")
          });
          Object.defineProperty(self.config, "maxDate", {
            get: function get() {
              return self.config._maxDate;
            },
            set: minMaxDateSetter("max")
          });

          var minMaxTimeSetter = function minMaxTimeSetter(type) {
            return function (val) {
              self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
            };
          };

          Object.defineProperty(self.config, "minTime", {
            get: function get() {
              return self.config._minTime;
            },
            set: minMaxTimeSetter("min")
          });
          Object.defineProperty(self.config, "maxTime", {
            get: function get() {
              return self.config._maxTime;
            },
            set: minMaxTimeSetter("max")
          });

          if (userConfig.mode === "time") {
            self.config.noCalendar = true;
            self.config.enableTime = true;
          }

          Object.assign(self.config, formats, userConfig);

          for (var i = 0; i < boolOpts.length; i++) {
            self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
          }

          HOOKS.filter(function (hook) {
            return self.config[hook] !== undefined;
          }).forEach(function (hook) {
            self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
          });
          self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

          for (var i = 0; i < self.config.plugins.length; i++) {
            var pluginConf = self.config.plugins[i](self) || {};

            for (var key in pluginConf) {
              if (HOOKS.indexOf(key) > -1) {
                self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
              } else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
            }
          }

          triggerEvent("onParseConfig");
        }

        function setupLocale() {
          if (_typeof(self.config.locale) !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
          self.l10n = _assign({}, flatpickr.l10ns["default"], _typeof(self.config.locale) === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
          tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";

          var userConfig = _assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));

          if (userConfig.time_24hr === undefined && flatpickr.defaultConfig.time_24hr === undefined) {
            self.config.time_24hr = self.l10n.time_24hr;
          }

          self.formatDate = createDateFormatter(self);
          self.parseDate = createDateParser({
            config: self.config,
            l10n: self.l10n
          });
        }

        function positionCalendar(customPositionElement) {
          if (self.calendarContainer === undefined) return;
          triggerEvent("onPreCalendarPosition");
          var positionElement = customPositionElement || self._positionElement;
          var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
            return acc + child.offsetHeight;
          }, 0),
              calendarWidth = self.calendarContainer.offsetWidth,
              configPos = self.config.position.split(" "),
              configPosVertical = configPos[0],
              configPosHorizontal = configPos.length > 1 ? configPos[1] : null,
              inputBounds = positionElement.getBoundingClientRect(),
              distanceFromBottom = window.innerHeight - inputBounds.bottom,
              showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
          var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
          toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
          toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
          if (self.config.inline) return;
          var left = window.pageXOffset + inputBounds.left - (configPosHorizontal != null && configPosHorizontal === "center" ? (calendarWidth - inputBounds.width) / 2 : 0);
          var right = window.document.body.offsetWidth - inputBounds.right;
          var rightMost = left + calendarWidth > window.document.body.offsetWidth;
          var centerMost = right + calendarWidth > window.document.body.offsetWidth;
          toggleClass(self.calendarContainer, "rightMost", rightMost);
          if (self.config.static) return;
          self.calendarContainer.style.top = top + "px";

          if (!rightMost) {
            self.calendarContainer.style.left = left + "px";
            self.calendarContainer.style.right = "auto";
          } else if (!centerMost) {
            self.calendarContainer.style.left = "auto";
            self.calendarContainer.style.right = right + "px";
          } else {
            var doc = document.styleSheets[0]; // some testing environments don't have css support

            if (doc === undefined) return;
            var bodyWidth = window.document.body.offsetWidth;
            var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
            var centerBefore = ".flatpickr-calendar.centerMost:before";
            var centerAfter = ".flatpickr-calendar.centerMost:after";
            var centerIndex = doc.cssRules.length;
            var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
            toggleClass(self.calendarContainer, "rightMost", false);
            toggleClass(self.calendarContainer, "centerMost", true);
            doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
            self.calendarContainer.style.left = centerLeft + "px";
            self.calendarContainer.style.right = "auto";
          }
        }

        function redraw() {
          if (self.config.noCalendar || self.isMobile) return;
          updateNavigationCurrentMonth();
          buildDays();
        }

        function focusAndClose() {
          self._input.focus();

          if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) {
            // hack - bugs in the way IE handles focus keeps the calendar open
            setTimeout(self.close, 0);
          } else {
            self.close();
          }
        }

        function selectDate(e) {
          e.preventDefault();
          e.stopPropagation();

          var isSelectable = function isSelectable(day) {
            return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
          };

          var t = findParent(e.target, isSelectable);
          if (t === undefined) return;
          var target = t;
          var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
          var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
          self.selectedDateElem = target;
          if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
            var selectedIndex = isDateSelected(selectedDate);
            if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);
          } else if (self.config.mode === "range") {
            if (self.selectedDates.length === 2) {
              self.clear(false, false);
            }

            self.latestSelectedDateObj = selectedDate;
            self.selectedDates.push(selectedDate); // unless selecting same date twice, sort ascendingly

            if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
              return a.getTime() - b.getTime();
            });
          }
          setHoursFromInputs();

          if (shouldChangeMonth) {
            var isNewYear = self.currentYear !== selectedDate.getFullYear();
            self.currentYear = selectedDate.getFullYear();
            self.currentMonth = selectedDate.getMonth();

            if (isNewYear) {
              triggerEvent("onYearChange");
              buildMonthSwitch();
            }

            triggerEvent("onMonthChange");
          }

          updateNavigationCurrentMonth();
          buildDays();
          updateValue();
          if (self.config.enableTime) setTimeout(function () {
            return self.showTimeInput = true;
          }, 50); // maintain focus

          if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);else if (self.selectedDateElem !== undefined && self.hourElement === undefined) {
            self.selectedDateElem && self.selectedDateElem.focus();
          }
          if (self.hourElement !== undefined) self.hourElement !== undefined && self.hourElement.focus();

          if (self.config.closeOnSelect) {
            var single = self.config.mode === "single" && !self.config.enableTime;
            var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;

            if (single || range) {
              focusAndClose();
            }
          }

          triggerChange();
        }

        var CALLBACKS = {
          locale: [setupLocale, updateWeekdays],
          showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
          minDate: [jumpToDate],
          maxDate: [jumpToDate]
        };

        function set(option, value) {
          if (option !== null && _typeof(option) === "object") {
            Object.assign(self.config, option);

            for (var key in option) {
              if (CALLBACKS[key] !== undefined) CALLBACKS[key].forEach(function (x) {
                return x();
              });
            }
          } else {
            self.config[option] = value;
            if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {
              return x();
            });else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
          }

          self.redraw();
          updateValue(false);
        }

        function setSelectedDate(inputDate, format) {
          var dates = [];
          if (inputDate instanceof Array) dates = inputDate.map(function (d) {
            return self.parseDate(d, format);
          });else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === "string") {
            switch (self.config.mode) {
              case "single":
              case "time":
                dates = [self.parseDate(inputDate, format)];
                break;

              case "multiple":
                dates = inputDate.split(self.config.conjunction).map(function (date) {
                  return self.parseDate(date, format);
                });
                break;

              case "range":
                dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
                  return self.parseDate(date, format);
                });
                break;
            }
          } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
          self.selectedDates = dates.filter(function (d) {
            return d instanceof Date && isEnabled(d, false);
          });
          if (self.config.mode === "range") self.selectedDates.sort(function (a, b) {
            return a.getTime() - b.getTime();
          });
        }

        function setDate(date, triggerChange, format) {
          if (triggerChange === void 0) {
            triggerChange = false;
          }

          if (format === void 0) {
            format = self.config.dateFormat;
          }

          if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
          setSelectedDate(date, format);
          self.showTimeInput = self.selectedDates.length > 0;
          self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
          self.redraw();
          jumpToDate();
          setHoursFromDate();

          if (self.selectedDates.length === 0) {
            self.clear(false);
          }

          updateValue(triggerChange);
          if (triggerChange) triggerEvent("onChange");
        }

        function parseDateRules(arr) {
          return arr.slice().map(function (rule) {
            if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
              return self.parseDate(rule, undefined, true);
            } else if (rule && _typeof(rule) === "object" && rule.from && rule.to) return {
              from: self.parseDate(rule.from, undefined),
              to: self.parseDate(rule.to, undefined)
            };

            return rule;
          }).filter(function (x) {
            return x;
          }); // remove falsy values
        }

        function setupDates() {
          self.selectedDates = [];
          self.now = self.parseDate(self.config.now) || new Date(); // Workaround IE11 setting placeholder as the input's value

          var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
          if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
          self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
          self.currentYear = self._initialDate.getFullYear();
          self.currentMonth = self._initialDate.getMonth();
          if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
          if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
          if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
          self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
          self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
          Object.defineProperty(self, "showTimeInput", {
            get: function get() {
              return self._showTimeInput;
            },
            set: function set(bool) {
              self._showTimeInput = bool;
              if (self.calendarContainer) toggleClass(self.calendarContainer, "showTimeInput", bool);
              self.isOpen && positionCalendar();
            }
          });
        }

        function setupInputs() {
          self.input = self.config.wrap ? element.querySelector("[data-input]") : element;
          /* istanbul ignore next */

          if (!self.input) {
            self.config.errorHandler(new Error("Invalid input element specified"));
            return;
          } // hack: store previous type to restore it after destroy()


          self.input._type = self.input.type;
          self.input.type = "text";
          self.input.classList.add("flatpickr-input");
          self._input = self.input;

          if (self.config.altInput) {
            // replicate self.element
            self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
            self._input = self.altInput;
            self.altInput.placeholder = self.input.placeholder;
            self.altInput.disabled = self.input.disabled;
            self.altInput.required = self.input.required;
            self.altInput.tabIndex = self.input.tabIndex;
            self.altInput.type = "text";
            self.input.setAttribute("type", "hidden");
            if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
          }

          if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
          self._positionElement = self.config.positionElement || self._input;
        }

        function setupMobile() {
          var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
          self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
          self.mobileInput.step = self.input.getAttribute("step") || "any";
          self.mobileInput.tabIndex = 1;
          self.mobileInput.type = inputType;
          self.mobileInput.disabled = self.input.disabled;
          self.mobileInput.required = self.input.required;
          self.mobileInput.placeholder = self.input.placeholder;
          self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

          if (self.selectedDates.length > 0) {
            self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
          }

          if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
          if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
          self.input.type = "hidden";
          if (self.altInput !== undefined) self.altInput.type = "hidden";

          try {
            if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
          } catch (_a) {}

          bind(self.mobileInput, "change", function (e) {
            self.setDate(e.target.value, false, self.mobileFormatStr);
            triggerEvent("onChange");
            triggerEvent("onClose");
          });
        }

        function toggle(e) {
          if (self.isOpen === true) return self.close();
          self.open(e);
        }

        function triggerEvent(event, data) {
          // If the instance has been destroyed already, all hooks have been removed
          if (self.config === undefined) return;
          var hooks = self.config[event];

          if (hooks !== undefined && hooks.length > 0) {
            for (var i = 0; hooks[i] && i < hooks.length; i++) {
              hooks[i](self.selectedDates, self.input.value, self, data);
            }
          }

          if (event === "onChange") {
            self.input.dispatchEvent(createEvent("change")); // many front-end frameworks bind to the input event

            self.input.dispatchEvent(createEvent("input"));
          }
        }

        function createEvent(name) {
          var e = document.createEvent("Event");
          e.initEvent(name, true, true);
          return e;
        }

        function isDateSelected(date) {
          for (var i = 0; i < self.selectedDates.length; i++) {
            if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
          }

          return false;
        }

        function isDateInRange(date) {
          if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
          return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
        }

        function updateNavigationCurrentMonth() {
          if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
          self.yearElements.forEach(function (yearElement, i) {
            var d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i);

            if (self.config.showMonths > 1) {
              self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
            } else {
              self.monthsDropdownContainer.value = d.getMonth().toString();
            }

            yearElement.value = d.getFullYear().toString();
          });
          self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
          self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
        }

        function getDateStr(format) {
          return self.selectedDates.map(function (dObj) {
            return self.formatDate(dObj, format);
          }).filter(function (d, i, arr) {
            return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
          }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
        }
        /**
         * Updates the values of inputs associated with the calendar
         */


        function updateValue(triggerChange) {
          if (triggerChange === void 0) {
            triggerChange = true;
          }

          if (self.mobileInput !== undefined && self.mobileFormatStr) {
            self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
          }

          self.input.value = getDateStr(self.config.dateFormat);

          if (self.altInput !== undefined) {
            self.altInput.value = getDateStr(self.config.altFormat);
          }

          if (triggerChange !== false) triggerEvent("onValueUpdate");
        }

        function onMonthNavClick(e) {
          var isPrevMonth = self.prevMonthNav.contains(e.target);
          var isNextMonth = self.nextMonthNav.contains(e.target);

          if (isPrevMonth || isNextMonth) {
            changeMonth(isPrevMonth ? -1 : 1);
          } else if (self.yearElements.indexOf(e.target) >= 0) {
            e.target.select();
          } else if (e.target.classList.contains("arrowUp")) {
            self.changeYear(self.currentYear + 1);
          } else if (e.target.classList.contains("arrowDown")) {
            self.changeYear(self.currentYear - 1);
          }
        }

        function timeWrapper(e) {
          e.preventDefault();
          var isKeyDown = e.type === "keydown",
              input = e.target;

          if (self.amPM !== undefined && e.target === self.amPM) {
            self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
          }

          var min = parseFloat(input.getAttribute("min")),
              max = parseFloat(input.getAttribute("max")),
              step = parseFloat(input.getAttribute("step")),
              curValue = parseInt(input.value, 10),
              delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
          var newValue = curValue + step * delta;

          if (typeof input.value !== "undefined" && input.value.length === 2) {
            var isHourElem = input === self.hourElement,
                isMinuteElem = input === self.minuteElement;

            if (newValue < min) {
              newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
              if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
            } else if (newValue > max) {
              newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
              if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
            }

            if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
              self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
            }

            input.value = pad(newValue);
          }
        }

        init();
        return self;
      }
      /* istanbul ignore next */


      function _flatpickr(nodeList, config) {
        // static list
        var nodes = Array.prototype.slice.call(nodeList).filter(function (x) {
          return x instanceof HTMLElement;
        });
        var instances = [];

        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];

          try {
            if (node.getAttribute("data-fp-omit") !== null) continue;

            if (node._flatpickr !== undefined) {
              node._flatpickr.destroy();

              node._flatpickr = undefined;
            }

            node._flatpickr = FlatpickrInstance(node, config || {});
            instances.push(node._flatpickr);
          } catch (e) {
            console.error(e);
          }
        }

        return instances.length === 1 ? instances[0] : instances;
      }
      /* istanbul ignore next */


      if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
        // browser env
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
          return _flatpickr(this, config);
        };

        HTMLElement.prototype.flatpickr = function (config) {
          return _flatpickr([this], config);
        };
      }
      /* istanbul ignore next */


      var flatpickr = function flatpickr(selector, config) {
        if (typeof selector === "string") {
          return _flatpickr(window.document.querySelectorAll(selector), config);
        } else if (selector instanceof Node) {
          return _flatpickr([selector], config);
        } else {
          return _flatpickr(selector, config);
        }
      };
      /* istanbul ignore next */


      flatpickr.defaultConfig = {};
      flatpickr.l10ns = {
        en: _assign({}, english),
        "default": _assign({}, english)
      };

      flatpickr.localize = function (l10n) {
        flatpickr.l10ns["default"] = _assign({}, flatpickr.l10ns["default"], l10n);
      };

      flatpickr.setDefaults = function (config) {
        flatpickr.defaultConfig = _assign({}, flatpickr.defaultConfig, config);
      };

      flatpickr.parseDate = createDateParser({});
      flatpickr.formatDate = createDateFormatter({});
      flatpickr.compareDates = compareDates;
      /* istanbul ignore next */

      if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
        jQuery.fn.flatpickr = function (config) {
          return _flatpickr(this, config);
        };
      } // eslint-disable-next-line @typescript-eslint/camelcase


      Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
      };

      if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
      }

      return flatpickr;
    });
  });

  function _typeof$j(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$j = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$j = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$j(obj);
  }

  function _classCallCheck$k(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$j(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$j(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$j(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$j(Constructor, staticProps);
    return Constructor;
  }

  function _get$2(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get$2 = Reflect.get;
    } else {
      _get$2 = function _get(target, property, receiver) {
        var base = _superPropBase$2(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get$2(target, property, receiver || target);
  }

  function _superPropBase$2(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$j(object);
      if (object === null) break;
    }

    return object;
  }

  function _inherits$j(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$j(subClass, superClass);
  }

  function _setPrototypeOf$j(o, p) {
    _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$j(o, p);
  }

  function _createSuper$j(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$j();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$j(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$j(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$j(this, result);
    };
  }

  function _possibleConstructorReturn$j(self, call) {
    if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$j(self);
  }

  function _assertThisInitialized$j(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$j() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$j(o) {
    _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$j(o);
  }

  function _toConsumableArray$5(arr) {
    return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$5();
  }

  function _nonIterableSpread$5() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$5(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
  }

  function _iterableToArray$5(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$5(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$5(arr);
  }

  function _arrayLikeToArray$5(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
  /* eslint no-underscore-dangle: [2, { "allow": ["_input", "_updateClassNames", "_updateInputFields"], "allowAfterThis": true }] */
  // `this.options` create-component mix-in creates prototype chain
  // so that `options` given in constructor argument wins over the one defined in static `options` property
  // 'Flatpickr' wants flat structure of object instead

  function flattenOptions(options) {
    var o = {}; // eslint-disable-next-line guard-for-in, no-restricted-syntax

    for (var key in options) {
      o[key] = options[key];
    }

    return o;
  } // Weekdays shorthand for english locale


  flatpickr.l10ns.en.weekdays.shorthand.forEach(function (day, index) {
    var currentDay = flatpickr.l10ns.en.weekdays.shorthand;

    if (currentDay[index] === 'Thu' || currentDay[index] === 'Th') {
      currentDay[index] = 'Th';
    } else {
      currentDay[index] = currentDay[index].charAt(0);
    }
  });

  var toArray$4 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };
  /**
   * @param {number} monthNumber The month number.
   * @param {boolean} shorthand `true` to use shorthand month.
   * @param {Locale} locale The Flatpickr locale data.
   * @returns {string} The month string.
   */


  var monthToStr = function monthToStr(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? 'shorthand' : 'longhand'][monthNumber];
  };
  /**
   * @param {object} config Plugin configuration.
   * @param {boolean} [config.shorthand] `true` to use shorthand month.
   * @param {string} config.selectorFlatpickrMonthYearContainer The CSS selector for the container of month/year selection UI.
   * @param {string} config.selectorFlatpickrYearContainer The CSS selector for the container of year selection UI.
   * @param {string} config.selectorFlatpickrCurrentMonth The CSS selector for the text-based month selection UI.
   * @param {string} config.classFlatpickrCurrentMonth The CSS class for the text-based month selection UI.
   * @returns {Plugin} A Flatpickr plugin to use text instead of `<select>` for month picker.
   */


  var carbonFlatpickrMonthSelectPlugin = function carbonFlatpickrMonthSelectPlugin(config) {
    return function (fp) {
      var setupElements = function setupElements() {
        var _fp$monthElements;

        if (!fp.monthElements) {
          return;
        }

        fp.monthElements.forEach(function (elem) {
          if (!elem.parentNode) return;
          elem.parentNode.removeChild(elem);
        });

        (_fp$monthElements = fp.monthElements).splice.apply(_fp$monthElements, [0, fp.monthElements.length].concat(_toConsumableArray$5(fp.monthElements.map(function () {
          // eslint-disable-next-line no-underscore-dangle
          var monthElement = fp._createElement('span', config.classFlatpickrCurrentMonth);

          monthElement.textContent = monthToStr(fp.currentMonth, config.shorthand === true, fp.l10n);
          fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));
          return monthElement;
        }))));
      };

      var updateCurrentMonth = function updateCurrentMonth() {
        var monthStr = monthToStr(fp.currentMonth, config.shorthand === true, fp.l10n);
        fp.yearElements.forEach(function (elem) {
          var currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);
          Array.prototype.forEach.call(currentMonthContainer.querySelectorAll('.cur-month'), function (monthElement) {
            monthElement.textContent = monthStr;
          });
        });
      };

      var register = function register() {
        fp.loadedPlugins.push('carbonFlatpickrMonthSelectPlugin');
      };

      return {
        onMonthChange: updateCurrentMonth,
        onValueUpdate: updateCurrentMonth,
        onOpen: updateCurrentMonth,
        onReady: [setupElements, updateCurrentMonth, register]
      };
    };
  };

  var DatePicker = /*#__PURE__*/function (_mixin) {
    _inherits$j(DatePicker, _mixin);

    var _super = _createSuper$j(DatePicker);
    /**
     * DatePicker.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as an date picker.
     */


    function DatePicker(element, options) {
      var _this;

      _classCallCheck$k(this, DatePicker);

      _this = _super.call(this, element, options);

      _this._handleFocus = function () {
        if (_this.calendar) {
          _this.calendar.open();
        }
      };

      _this._handleBlur = function (event) {
        if (_this.calendar) {
          var focusTo = event.relatedTarget;

          if (!focusTo || !_this.element.contains(focusTo) && (!_this.calendar.calendarContainer || !_this.calendar.calendarContainer.contains(focusTo))) {
            _this.calendar.close();
          }
        }
      };

      _this._initDatePicker = function (type) {
        if (type === 'range') {
          // Given FlatPickr assumes one `<input>` even in range mode,
          // use a hidden `<input>` for such purpose, separate from our from/to `<input>`s
          var doc = _this.element.ownerDocument;
          var rangeInput = doc.createElement('input');
          rangeInput.className = _this.options.classVisuallyHidden;
          rangeInput.setAttribute('aria-hidden', 'true');

          _this.element.appendChild(rangeInput);

          _this._rangeInput = rangeInput; // An attempt to open the date picker dropdown when this component gets focus,
          // and close the date picker dropdown when this component loses focus

          var w = doc.defaultView;
          var hasFocusin = ('onfocusin' in w);
          var hasFocusout = ('onfocusout' in w);
          var focusinEventName = hasFocusin ? 'focusin' : 'focus';
          var focusoutEventName = hasFocusout ? 'focusout' : 'blur';

          _this.manage(on(_this.element, focusinEventName, _this._handleFocus, !hasFocusin));

          _this.manage(on(_this.element, focusoutEventName, _this._handleBlur, !hasFocusout));

          _this.manage(on(_this.element.querySelector(_this.options.selectorDatePickerIcon), focusoutEventName, _this._handleBlur, !hasFocusout));
        }

        var self = _assertThisInitialized$j(_this);

        var date = type === 'range' ? _this._rangeInput : _this.element.querySelector(_this.options.selectorDatePickerInput);
        var _this$options = _this.options,
            _onClose = _this$options.onClose,
            _onChange = _this$options.onChange,
            _onMonthChange = _this$options.onMonthChange,
            _onYearChange = _this$options.onYearChange,
            _onOpen = _this$options.onOpen,
            _onValueUpdate = _this$options.onValueUpdate;
        var calendar = new flatpickr(date, Object.assign(flattenOptions(_this.options), {
          allowInput: true,
          mode: type,
          disableMobile: true,
          positionElement: type === 'range' && _this.element.querySelector(_this.options.selectorDatePickerInputFrom),
          onClose: function onClose(selectedDates) {
            // An attempt to disable Flatpickr's focus tracking system,
            // which has adverse effect with our old set up with two `<input>`s or our latest setup with a hidden `<input>`
            if (self.shouldForceOpen) {
              if (self.calendar.calendarContainer) {
                self.calendar.calendarContainer.classList.add('open');
              }

              self.calendar.isOpen = true;
            }

            for (var _len = arguments.length, remainder = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              remainder[_key - 1] = arguments[_key];
            }

            if (!_onClose || _onClose.call.apply(_onClose, [this, selectedDates].concat(remainder)) !== false) {
              self._updateClassNames(calendar);

              self._updateInputFields(selectedDates, type);
            }
          },
          onChange: function onChange() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            if (!_onChange || _onChange.call.apply(_onChange, [this].concat(args)) !== false) {
              self._updateClassNames(calendar);

              if (type === 'range') {
                if (calendar.selectedDates.length === 1 && calendar.isOpen) {
                  self.element.querySelector(self.options.selectorDatePickerInputTo).classList.add(self.options.classFocused);
                } else {
                  self.element.querySelector(self.options.selectorDatePickerInputTo).classList.remove(self.options.classFocused);
                }
              }
            }
          },
          onMonthChange: function onMonthChange() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            if (!_onMonthChange || _onMonthChange.call.apply(_onMonthChange, [this].concat(args)) !== false) {
              self._updateClassNames(calendar);
            }
          },
          onYearChange: function onYearChange() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }

            if (!_onYearChange || _onYearChange.call.apply(_onYearChange, [this].concat(args)) !== false) {
              self._updateClassNames(calendar);
            }
          },
          onOpen: function onOpen() {
            // An attempt to disable Flatpickr's focus tracking system,
            // which has adverse effect with our old set up with two `<input>`s or our latest setup with a hidden `<input>`
            self.shouldForceOpen = true;
            setTimeout(function () {
              self.shouldForceOpen = false;
            }, 0);

            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }

            if (!_onOpen || _onOpen.call.apply(_onOpen, [this].concat(args)) !== false) {
              self._updateClassNames(calendar);
            }
          },
          onValueUpdate: function onValueUpdate() {
            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
              args[_key6] = arguments[_key6];
            }

            if ((!_onValueUpdate || _onValueUpdate.call.apply(_onValueUpdate, [this].concat(args)) !== false) && type === 'range') {
              self._updateInputFields(self.calendar.selectedDates, type);
            }
          },
          nextArrow: _this._rightArrowHTML(),
          prevArrow: _this._leftArrowHTML(),
          plugins: [].concat(_toConsumableArray$5(_this.options.plugins || []), [carbonFlatpickrMonthSelectPlugin(_this.options)])
        }));

        if (type === 'range') {
          _this._addInputLogic(_this.element.querySelector(_this.options.selectorDatePickerInputFrom), 0);

          _this._addInputLogic(_this.element.querySelector(_this.options.selectorDatePickerInputTo), 1);
        }

        _this.manage(on(_this.element.querySelector(_this.options.selectorDatePickerIcon), 'click', function () {
          calendar.open();
        }));

        _this._updateClassNames(calendar);

        if (type !== 'range') {
          _this._addInputLogic(date);
        }

        return calendar;
      };

      _this._addInputLogic = function (input, index) {
        if (!isNaN(index) && (index < 0 || index > 1)) {
          throw new RangeError("The index of <input> (".concat(index, ") is out of range."));
        }

        var inputField = input;

        _this.manage(on(inputField, 'change', function (evt) {
          if (evt.isTrusted || evt.detail && evt.detail.isNotFromFlatpickr) {
            var inputDate = _this.calendar.parseDate(inputField.value);

            if (inputDate && !isNaN(inputDate.valueOf())) {
              if (isNaN(index)) {
                _this.calendar.setDate(inputDate);
              } else {
                var selectedDates = _this.calendar.selectedDates;
                selectedDates[index] = inputDate;

                _this.calendar.setDate(selectedDates);
              }
            }
          }

          _this._updateClassNames(_this.calendar);
        })); // An attempt to temporarily set the `<input>` being edited as the one FlatPicker manages,
        // as FlatPicker attempts to take over `keydown` event handler on `document` to run on the date picker dropdown.


        _this.manage(on(inputField, 'keydown', function (evt) {
          var origInput = _this.calendar._input;
          _this.calendar._input = evt.target;
          setTimeout(function () {
            _this.calendar._input = origInput;
          });
        }));
      };

      _this._updateClassNames = function (_ref) {
        var calendarContainer = _ref.calendarContainer,
            selectedDates = _ref.selectedDates;

        if (calendarContainer) {
          calendarContainer.classList.add(_this.options.classCalendarContainer);
          calendarContainer.querySelector('.flatpickr-month').classList.add(_this.options.classMonth);
          calendarContainer.querySelector('.flatpickr-weekdays').classList.add(_this.options.classWeekdays);
          calendarContainer.querySelector('.flatpickr-days').classList.add(_this.options.classDays);
          toArray$4(calendarContainer.querySelectorAll('.flatpickr-weekday')).forEach(function (item) {
            var currentItem = item;
            currentItem.innerHTML = currentItem.innerHTML.replace(/\s+/g, '');
            currentItem.classList.add(_this.options.classWeekday);
          });
          toArray$4(calendarContainer.querySelectorAll('.flatpickr-day')).forEach(function (item) {
            item.classList.add(_this.options.classDay);

            if (item.classList.contains('today') && selectedDates.length > 0) {
              item.classList.add('no-border');
            } else if (item.classList.contains('today') && selectedDates.length === 0) {
              item.classList.remove('no-border');
            }
          });
        }
      };

      _this._updateInputFields = function (selectedDates, type) {
        if (type === 'range') {
          if (selectedDates.length === 2) {
            _this.element.querySelector(_this.options.selectorDatePickerInputFrom).value = _this._formatDate(selectedDates[0]);
            _this.element.querySelector(_this.options.selectorDatePickerInputTo).value = _this._formatDate(selectedDates[1]);
          } else if (selectedDates.length === 1) {
            _this.element.querySelector(_this.options.selectorDatePickerInputFrom).value = _this._formatDate(selectedDates[0]);
          }
        } else if (selectedDates.length === 1) {
          _this.element.querySelector(_this.options.selectorDatePickerInput).value = _this._formatDate(selectedDates[0]);
        }

        _this._updateClassNames(_this.calendar);
      };

      _this._formatDate = function (date) {
        return _this.calendar.formatDate(date, _this.calendar.config.dateFormat);
      };

      var _type = _this.element.getAttribute(_this.options.attribType);

      _this.calendar = _this._initDatePicker(_type);

      if (_this.calendar.calendarContainer) {
        _this.manage(on(_this.element, 'keydown', function (e) {
          if (e.which === 40) {
            e.preventDefault();

            (_this.calendar.selectedDateElem || _this.calendar.todayDateElem || _this.calendar.calendarContainer).focus();
          }
        }));

        _this.manage(on(_this.calendar.calendarContainer, 'keydown', function (e) {
          if (e.which === 9 && _type === 'range') {
            _this._updateClassNames(_this.calendar);

            _this.element.querySelector(_this.options.selectorDatePickerInputFrom).focus();
          }
        }));
      }

      return _this;
    }
    /**
     * Opens the date picker dropdown when this component gets focus.
     * Used only for range mode for now.
     * @private
     */


    _createClass$j(DatePicker, [{
      key: "_rightArrowHTML",
      value: function _rightArrowHTML() {
        return "\n      <svg\n        focusable=\"false\"\n        preserveAspectRatio=\"xMidYMid meet\"\n        style=\"will-change: transform;\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"16\"\n        height=\"16\"\n        viewBox=\"0 0 16 16\"\n        aria-hidden=\"true\">\n          <path d=\"M11 8l-5 5-.7-.7L9.6 8 5.3 3.7 6 3z\"></path>\n      </svg>";
      }
    }, {
      key: "_leftArrowHTML",
      value: function _leftArrowHTML() {
        return "\n      <svg\n        focusable=\"false\"\n        preserveAspectRatio=\"xMidYMid meet\"\n        style=\"will-change: transform;\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"16\"\n        height=\"16\"\n        viewBox=\"0 0 16 16\"\n        aria-hidden=\"true\"\n      >\n        <path d=\"M5 8l5-5 .7.7L6.4 8l4.3 4.3-.7.7z\"></path>\n      </svg>";
      }
    }, {
      key: "release",
      value: function release() {
        if (this._rangeInput && this._rangeInput.parentNode) {
          this._rangeInput.parentNode.removeChild(this._rangeInput);
        }

        if (this.calendar) {
          try {
            this.calendar.destroy();
          } catch (err) {} // eslint-disable-line no-empty


          this.calendar = null;
        }

        return _get$2(_getPrototypeOf$j(DatePicker.prototype), "release", this).call(this);
      }
      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode DatePicker.create .create()}, or {@linkcode DatePicker.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode DatePicker.init .init()} works.
       * @property {string} selectorInit The CSS selector to find date picker UIs.
       */

    }], [{
      key: "options",
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-date-picker]',
          selectorDatePickerInput: '[data-date-picker-input]',
          selectorDatePickerInputFrom: '[data-date-picker-input-from]',
          selectorDatePickerInputTo: '[data-date-picker-input-to]',
          selectorDatePickerIcon: '[data-date-picker-icon]',
          selectorFlatpickrMonthYearContainer: '.flatpickr-current-month',
          selectorFlatpickrYearContainer: '.numInputWrapper',
          selectorFlatpickrCurrentMonth: '.cur-month',
          classCalendarContainer: "".concat(prefix, "--date-picker__calendar"),
          classMonth: "".concat(prefix, "--date-picker__month"),
          classWeekdays: "".concat(prefix, "--date-picker__weekdays"),
          classDays: "".concat(prefix, "--date-picker__days"),
          classWeekday: "".concat(prefix, "--date-picker__weekday"),
          classDay: "".concat(prefix, "--date-picker__day"),
          classFocused: "".concat(prefix, "--focused"),
          classVisuallyHidden: "".concat(prefix, "--visually-hidden"),
          classFlatpickrCurrentMonth: 'cur-month',
          attribType: 'data-date-picker-type',
          dateFormat: 'm/d/Y'
        };
      }
      /**
       * The map associating DOM element and date picker UI instance.
       * @type {WeakMap}
       */

    }]);

    DatePicker.components = new WeakMap();
    return DatePicker;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$k(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$k = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$k = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$k(obj);
  }

  function _classCallCheck$l(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _inherits$k(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$k(subClass, superClass);
  }

  function _setPrototypeOf$k(o, p) {
    _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$k(o, p);
  }

  function _createSuper$k(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$k();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$k(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$k(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$k(this, result);
    };
  }

  function _possibleConstructorReturn$k(self, call) {
    if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$k(self);
  }

  function _assertThisInitialized$k(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$k() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$k(o) {
    _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$k(o);
  }

  var Pagination = /*#__PURE__*/function (_mixin) {
    _inherits$k(Pagination, _mixin);

    var _super = _createSuper$k(Pagination);
    /**
     * Pagination component.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @param {HTMLElement} element The element working as a pagination component.
     * @param {object} [options] The component options.
     * @property {string} [selectorInit] The CSS selector to find pagination components.
     * @property {string} [selectorItemsPerPageInput]
     *   The CSS selector to find the input that determines the number of items per page.
     * @property {string} [selectorPageNumberInput] The CSS selector to find the input that changes the page displayed.
     * @property {string} [selectorPageBackward] The CSS selector to find the button that goes back a page.
     * @property {string} [selectorPageForward] The CSS selector to find the button that goes forward a page.
     * @property {string} [eventItemsPerPage]
     *   The name of the custom event fired when a user changes the number of items per page.
     *   event.detail.value contains the number of items a user wishes to see.
     * @property {string} [eventPageNumber]
     *   The name of the custom event fired when a user inputs a specific page number.
     *   event.detail.value contains the value that the user input.
     * @property {string} [eventPageChange]
     *   The name of the custom event fired when a user goes forward or backward a page.
     *   event.detail.direction contains the direction a user wishes to go.
     */


    function Pagination(element, options) {
      var _this;

      _classCallCheck$l(this, Pagination);

      _this = _super.call(this, element, options);

      _this._emitEvent = function (evtName, detail) {
        var event = new CustomEvent("".concat(evtName), {
          bubbles: true,
          cancelable: true,
          detail: detail
        });

        _this.element.dispatchEvent(event);
      };

      _this.manage(on(_this.element, 'click', function (evt) {
        if (eventMatches(evt, _this.options.selectorPageBackward)) {
          var detail = {
            initialEvt: evt,
            element: evt.target,
            direction: 'backward'
          };

          _this._emitEvent(_this.options.eventPageChange, detail);
        } else if (eventMatches(evt, _this.options.selectorPageForward)) {
          var _detail = {
            initialEvt: evt,
            element: evt.target,
            direction: 'forward'
          };

          _this._emitEvent(_this.options.eventPageChange, _detail);
        }
      }));

      _this.manage(on(_this.element, 'input', function (evt) {
        if (eventMatches(evt, _this.options.selectorItemsPerPageInput)) {
          var detail = {
            initialEvt: evt,
            element: evt.target,
            value: evt.target.value
          };

          _this._emitEvent(_this.options.eventItemsPerPage, detail);
        } else if (eventMatches(evt, _this.options.selectorPageNumberInput)) {
          var _detail2 = {
            initialEvt: evt,
            element: evt.target,
            value: evt.target.value
          };

          _this._emitEvent(_this.options.eventPageNumber, _detail2);
        }
      }));

      return _this;
    }
    /**
     * Dispatches a custom event
     * @param {string} evtName name of the event to be dispatched.
     * @param {object} detail contains the original event and any other necessary details.
     */


    Pagination.components = new WeakMap();
    Pagination.options = {
      selectorInit: '[data-pagination]',
      selectorItemsPerPageInput: '[data-items-per-page]',
      selectorPageNumberInput: '[data-page-number-input]',
      selectorPageBackward: '[data-page-backward]',
      selectorPageForward: '[data-page-forward]',
      eventItemsPerPage: 'itemsPerPage',
      eventPageNumber: 'pageNumber',
      eventPageChange: 'pageChange'
    };
    return Pagination;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _defineProperty$3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */


  function svgToggleClass(svg, name, forceAdd) {
    var list = svg.getAttribute('class').trim().split(/\s+/);
    var uniqueList = Object.keys(list.reduce(function (o, item) {
      return Object.assign(o, _defineProperty$3({}, item, 1));
    }, {}));
    var index = uniqueList.indexOf(name);
    var found = index >= 0;
    var add = forceAdd === undefined ? !found : forceAdd;

    if (found === !add) {
      if (add) {
        uniqueList.push(name);
      } else {
        uniqueList.splice(index, 1);
      }

      svg.setAttribute('class', uniqueList.join(' '));
    }
  }

  function _typeof$l(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$l = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$l = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$l(obj);
  }

  function _classCallCheck$m(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$k(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$k(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$k(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$k(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$l(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$l(subClass, superClass);
  }

  function _setPrototypeOf$l(o, p) {
    _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$l(o, p);
  }

  function _createSuper$l(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$l();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$l(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$l(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$l(this, result);
    };
  }

  function _possibleConstructorReturn$l(self, call) {
    if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$l(self);
  }

  function _assertThisInitialized$l(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$l() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$l(o) {
    _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$l(o);
  }

  var toArray$5 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var Search = /*#__PURE__*/function (_mixin) {
    _inherits$l(Search, _mixin);

    var _super = _createSuper$l(Search);
    /**
     * Search with Options.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as the search component.
     * @param {object} [options] The component options
     * @property {string} [options.selectorInit]
     *   The selector to find search UIs with options.
     * @property {string} [options.selectorSearchView]
     *   The selector to find the search view icon containers.
     * @property {string} [options.selectorSearchInput]
     *   The selector to find the search input.
     * @property {string} [options.selectorClearIcon]
     *   The selector for the clear icon that clears the search box.
     * @property {string} [options.selectorIconContainer] The data attribute selector for the icon layout container.
     * @property {string} [options.classClearHidden] The class used to hide the clear icon.
     * @property {string} [options.classLayoutHidden] The class used to hide nonselected layout view.
     */


    function Search(element, options) {
      var _this;

      _classCallCheck$m(this, Search);

      _this = _super.call(this, element, options);

      var closeIcon = _this.element.querySelector(_this.options.selectorClearIcon);

      var input = _this.element.querySelector(_this.options.selectorSearchInput);

      if (!input) {
        throw new Error('Cannot find the search input.');
      }

      if (closeIcon) {
        _this.manage(on(closeIcon, 'click', function () {
          svgToggleClass(closeIcon, _this.options.classClearHidden, true);
          input.value = '';
          input.focus();
        }));
      }

      _this.manage(on(_this.element, 'click', function (evt) {
        var toggleItem = eventMatches(evt, _this.options.selectorIconContainer);
        if (toggleItem) _this.toggleLayout(toggleItem);
      }));

      _this.manage(on(input, 'input', function (evt) {
        if (closeIcon) _this.showClear(evt.target.value, closeIcon);
      }));

      return _this;
    }
    /**
     * Toggles between the grid and list layout.
     * @param {HTMLElement} element The element contining the layout toggle.
     */


    _createClass$k(Search, [{
      key: "toggleLayout",
      value: function toggleLayout(element) {
        var _this2 = this;

        toArray$5(element.querySelectorAll(this.options.selectorSearchView)).forEach(function (item) {
          item.classList.toggle(_this2.options.classLayoutHidden);
        });
      }
      /**
       * Toggles the clear icon visibility
       * @param {HTMLElement} value The element serving as the search input.
       * @param {HTMLElement} icon The element serving as close icon.
       */

    }, {
      key: "showClear",
      value: function showClear(value, icon) {
        svgToggleClass(icon, this.options.classClearHidden, value.length === 0);
      }
      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode Search.create .create()}, or {@linkcode Search.init .init()},
       * properties in this object are overriden for the instance being created
       * and how {@linkcode Search.init .init()} works.
       * @member Search.options
       * @type {object}
       * @property {string} [options.selectorInit]
       *   The selector to find search UIs with options.
       * @property {string} [options.selectorSearchView]
       *   The selector to find the search view icon containers.
       * @property {string} [options.selectorSearchInput]
       *   The selector to find the search input.
       * @property {string} [options.selectorClearIcon]
       *   The selector for the clear icon that clears the search box.
       * @property {string} [options.selectorIconContainer] The data attribute selector for the icon layout container.
       * @property {string} [options.classClearHidden] The class used to hide the clear icon.
       * @property {string} [options.classLayoutHidden] The class used to hide nonselected layout view.
       */

    }], [{
      key: "options",
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-search]',
          selectorSearchView: '[data-search-view]',
          selectorSearchInput: ".".concat(prefix, "--search-input"),
          selectorClearIcon: ".".concat(prefix, "--search-close"),
          selectorIconContainer: ".".concat(prefix, "--search-button[data-search-toggle]"),
          classClearHidden: "".concat(prefix, "--search-close--hidden"),
          classLayoutHidden: "".concat(prefix, "--search-view--hidden")
        };
      }
      /**
       * The map associating DOM element and search instance.
       * @member Search.components
       * @type {WeakMap}
       */

    }]);

    Search.components = new WeakMap();
    return Search;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$m(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$m = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$m = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$m(obj);
  }

  function _classCallCheck$n(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$l(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$l(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$l(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$l(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$m(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$m(subClass, superClass);
  }

  function _setPrototypeOf$m(o, p) {
    _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$m(o, p);
  }

  function _createSuper$m(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$m();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$m(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$m(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$m(this, result);
    };
  }

  function _possibleConstructorReturn$m(self, call) {
    if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$m(self);
  }

  function _assertThisInitialized$m(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$m() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$m(o) {
    _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$m(o);
  }

  var Accordion = /*#__PURE__*/function (_mixin) {
    _inherits$m(Accordion, _mixin);

    var _super = _createSuper$m(Accordion);
    /**
     * Accordion.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as an accordion.
     */


    function Accordion(element, options) {
      var _this;

      _classCallCheck$n(this, Accordion);

      _this = _super.call(this, element, options);

      _this.manage(on(_this.element, 'click', function (event) {
        var item = eventMatches(event, _this.options.selectorAccordionItem);

        if (item && !eventMatches(event, _this.options.selectorAccordionContent)) {
          _this._toggle(item);
        }
      }));
      /**
       *
       *  DEPRECATE in v8
       *
       *  Swapping to a button elemenet instead of a div
       *  automatically maps click events to keypress as well
       *  This event listener now is only added if user is using
       *  the older markup
       */


      if (!_this._checkIfButton()) {
        _this.manage(on(_this.element, 'keypress', function (event) {
          var item = eventMatches(event, _this.options.selectorAccordionItem);

          if (item && !eventMatches(event, _this.options.selectorAccordionContent)) {
            _this._handleKeypress(event);
          }
        }));
      }

      return _this;
    }

    _createClass$l(Accordion, [{
      key: "_checkIfButton",
      value: function _checkIfButton() {
        return this.element.firstElementChild.firstElementChild.nodeName === 'BUTTON';
      }
      /**
       * Handles toggling of active state of accordion via keyboard
       * @param {Event} event The event triggering this method.
       */

    }, {
      key: "_handleKeypress",
      value: function _handleKeypress(event) {
        if (event.which === 13 || event.which === 32) {
          this._toggle(event.target);
        }
      }
    }, {
      key: "_toggle",
      value: function _toggle(element) {
        var heading = element.querySelector(this.options.selectorAccordionItemHeading);
        var expanded = heading.getAttribute('aria-expanded');

        if (expanded !== null) {
          heading.setAttribute('aria-expanded', expanded === 'true' ? 'false' : 'true');
        }

        element.classList.toggle(this.options.classActive);
      }
      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode NumberInput.create .create()}, or {@linkcode NumberInput.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode NumberInput.init .init()} works.
       * @property {string} selectorInit The CSS selector to find accordion UIs.
       */

    }], [{
      key: "options",
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-accordion]',
          selectorAccordionItem: ".".concat(prefix, "--accordion__item"),
          selectorAccordionItemHeading: ".".concat(prefix, "--accordion__heading"),
          selectorAccordionContent: ".".concat(prefix, "--accordion__content"),
          classActive: "".concat(prefix, "--accordion__item--active")
        };
      }
      /**
       * The map associating DOM element and accordion UI instance.
       * @type {WeakMap}
       */

    }]);

    Accordion.components = new WeakMap();
    return Accordion;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$n(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$n = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$n = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$n(obj);
  }

  function _classCallCheck$o(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$m(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$m(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$m(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$m(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$n(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$n(subClass, superClass);
  }

  function _setPrototypeOf$n(o, p) {
    _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$n(o, p);
  }

  function _createSuper$n(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$n();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$n(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$n(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$n(this, result);
    };
  }

  function _possibleConstructorReturn$n(self, call) {
    if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$n(self);
  }

  function _assertThisInitialized$n(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$n() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$n(o) {
    _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$n(o);
  }

  var CopyButton = /*#__PURE__*/function (_mixin) {
    _inherits$n(CopyButton, _mixin);

    var _super = _createSuper$n(CopyButton);
    /**
     * CopyBtn UI.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a copy button UI.
     */


    function CopyButton(element, options) {
      var _this;

      _classCallCheck$o(this, CopyButton);

      _this = _super.call(this, element, options);

      _this.manage(on(_this.element, 'click', function () {
        return _this.handleClick();
      }));

      _this.manage(on(_this.element, 'animationend', function (event) {
        return _this.handleAnimationEnd(event);
      }));

      return _this;
    }
    /**
     * Cleanup animation classes
     */


    _createClass$m(CopyButton, [{
      key: "handleAnimationEnd",
      value: function handleAnimationEnd(event) {
        if (event.animationName === 'hide-feedback') {
          this.element.classList.remove(this.options.classAnimating);
          this.element.classList.remove(this.options.classFadeOut);
        }
      }
      /**
       * Show the feedback tooltip on click. Hide the feedback tooltip after specified timeout value.
       */

    }, {
      key: "handleClick",
      value: function handleClick() {
        var _this2 = this;

        var feedback = this.element.querySelector(this.options.feedbackTooltip);

        if (feedback) {
          feedback.classList.add(this.options.classShowFeedback);
          setTimeout(function () {
            feedback.classList.remove(_this2.options.classShowFeedback);
          }, this.options.timeoutValue);
        } else {
          this.element.classList.add(this.options.classAnimating);
          this.element.classList.add(this.options.classFadeIn);
          setTimeout(function () {
            _this2.element.classList.remove(_this2.options.classFadeIn);

            _this2.element.classList.add(_this2.options.classFadeOut);
          }, this.options.timeoutValue);
        }
      }
      /**
       * The map associating DOM element and copy button UI instance.
       * @member CopyBtn.components
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode CopyBtn.create .create()}, or {@linkcode CopyBtn.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode CopyBtn.init .init()} works.
       * @member CopyBtn.options
       * @type {object}
       * @property {string} selectorInit The data attribute to find copy button UIs.
       * @property {string} feedbackTooltip The data attribute to find feedback tooltip.
       * @property {string} classShowFeedback The CSS selector for showing the feedback tooltip.
       * @property {number} timeoutValue The specified timeout value before the feedback tooltip is hidden.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-copy-btn]',
          feedbackTooltip: '[data-feedback]',
          classShowFeedback: "".concat(prefix, "--btn--copy__feedback--displayed"),
          classAnimating: "".concat(prefix, "--copy-btn--animating"),
          classFadeIn: "".concat(prefix, "--copy-btn--fade-in"),
          classFadeOut: "".concat(prefix, "--copy-btn--fade-out"),
          timeoutValue: 2000
        };
      }
    }]);

    CopyButton.components = new WeakMap();
    return CopyButton;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$o(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$o = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$o = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$o(obj);
  }

  function _classCallCheck$p(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$n(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$n(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$n(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$n(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$o(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$o(subClass, superClass);
  }

  function _setPrototypeOf$o(o, p) {
    _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$o(o, p);
  }

  function _createSuper$o(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$o();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$o(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$o(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$o(this, result);
    };
  }

  function _possibleConstructorReturn$o(self, call) {
    if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$o(self);
  }

  function _assertThisInitialized$o(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$o() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$o(o) {
    _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$o(o);
  }

  var Notification = /*#__PURE__*/function (_mixin) {
    _inherits$o(Notification, _mixin);

    var _super = _createSuper$o(Notification);
    /**
     * InlineNotification.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a InlineNotification.
     */


    function Notification(element, options) {
      var _this;

      _classCallCheck$p(this, Notification);

      _this = _super.call(this, element, options);

      _this._changeState = function (state, callback) {
        if (state === 'delete-notification') {
          _this.element.parentNode.removeChild(_this.element);

          _this.release();
        }

        callback();
      };

      _this.button = element.querySelector(_this.options.selectorButton);

      if (_this.button) {
        _this.manage(on(_this.button, 'click', function (evt) {
          if (evt.currentTarget === _this.button) {
            _this.remove();
          }
        }));
      }

      return _this;
    }

    _createClass$n(Notification, [{
      key: "remove",
      value: function remove() {
        this.changeState('delete-notification');
      }
      /**
       * The map associating DOM element and accordion UI instance.
       * @type {WeakMap}
       */

    }]);

    Notification.components = new WeakMap();
    Notification.options = {
      selectorInit: '[data-notification]',
      selectorButton: '[data-notification-btn]',
      eventBeforeDeleteNotification: 'notification-before-delete',
      eventAfterDeleteNotification: 'notification-after-delete'
    };
    return Notification;
  }(mixin(createComponent, initComponentBySearch, eventedState, handles));

  function _typeof$p(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$p = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$p = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$p(obj);
  }

  function _classCallCheck$q(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$o(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$o(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$o(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$o(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$p(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$p(subClass, superClass);
  }

  function _setPrototypeOf$p(o, p) {
    _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$p(o, p);
  }

  function _createSuper$p(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$p();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$p(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$p(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$p(this, result);
    };
  }

  function _possibleConstructorReturn$p(self, call) {
    if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$p(self);
  }

  function _assertThisInitialized$p(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$p() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$p(o) {
    _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$p(o);
  }

  var toArray$6 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var Toolbar = /*#__PURE__*/function (_mixin) {
    _inherits$p(Toolbar, _mixin);

    var _super = _createSuper$p(Toolbar);
    /**
     * Toolbar.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as an toolbar.
     */


    function Toolbar(element, options) {
      var _this;

      _classCallCheck$q(this, Toolbar);

      _this = _super.call(this, element, options);

      if (!_this.element.dataset.tableTarget) {
        console.warn('There is no table bound to this toolbar!'); // eslint-disable-line no-console
      } else {
        var boundTable = _this.element.ownerDocument.querySelector(_this.element.dataset.tableTarget);

        var rowHeightBtns = _this.element.querySelector(_this.options.selectorRowHeight);

        if (rowHeightBtns) {
          _this.manage(on(rowHeightBtns, 'click', function (event) {
            _this._handleRowHeightChange(event, boundTable);
          })); // toArray(this.element.querySelectorAll(this.options.selectorRowHeight)).forEach((item) => {
          //   item.addEventListener('click', (event) => { this._handleRowHeightChange(event, boundTable); });
          // });

        }
      }

      _this.manage(on(_this.element.ownerDocument, 'keydown', function (evt) {
        _this._handleKeyDown(evt);
      }));

      _this.manage(on(_this.element.ownerDocument, 'click', function (evt) {
        _this._handleDocumentClick(evt);
      }));

      return _this;
    }
    /**
     * Handles toggling of active state of the toolbar search input
     * @param {Event} event The event triggering this method.
     */


    _createClass$o(Toolbar, [{
      key: "_handleDocumentClick",
      value: function _handleDocumentClick(event) {
        var _this2 = this;

        var searchInput = eventMatches(event, this.options.selectorSearch);
        var isOfSelfSearchInput = searchInput && this.element.contains(searchInput);

        if (isOfSelfSearchInput) {
          var shouldBeOpen = isOfSelfSearchInput && !this.element.classList.contains(this.options.classSearchActive);
          searchInput.classList.toggle(this.options.classSearchActive, shouldBeOpen);

          if (shouldBeOpen) {
            searchInput.querySelector('input').focus();
          }
        }

        var targetComponentElement = eventMatches(event, this.options.selectorInit);
        toArray$6(this.element.ownerDocument.querySelectorAll(this.options.selectorSearch)).forEach(function (item) {
          if (!targetComponentElement || !targetComponentElement.contains(item)) {
            item.classList.remove(_this2.options.classSearchActive);
          }
        });
      }
      /**
       * Handles toggling of active state of the toolbar search input via the keyboard
       * @param {Event} event The event triggering this method.
       */

    }, {
      key: "_handleKeyDown",
      value: function _handleKeyDown(event) {
        var searchInput = eventMatches(event, this.options.selectorSearch);

        if (searchInput && event.which === 27) {
          searchInput.classList.remove(this.options.classSearchActive);
        }
      }
      /**
       * Handles toggling of the row height of the associated table
       * @param {Event} event The event triggering this method.
       * @param {HTMLElement} boundTable The table associated with the toolbar.
       */

    }, {
      key: "_handleRowHeightChange",
      value: function _handleRowHeightChange(event, boundTable) {
        var _event$currentTarget$ = event.currentTarget.querySelector('input:checked'),
            value = _event$currentTarget$.value;

        if (value === 'tall') {
          boundTable.classList.add(this.options.classTallRows);
        } else {
          boundTable.classList.remove(this.options.classTallRows);
        }
      }
      /**
       * The map associating DOM element and Toolbar UI instance.
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * properties in this object are overriden for the instance being created.
       * @property {string} selectorInit The CSS selector to find toolbar instances.
       * @property {string} selectorSearch The CSS selector to find search inputs in a toolbar.
       * @property {string} selectorRowHeight The CSS selector to find the row height inputs in a toolbar.
       * @property {string} classTallRows The CSS class for making table rows into tall rows.
       * @property {string} classSearchActive The CSS class the active state of the search input.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-toolbar]',
          selectorSearch: '[data-toolbar-search]',
          selectorRowHeight: '[data-row-height]',
          classTallRows: "".concat(prefix, "--responsive-table--tall"),
          classSearchActive: "".concat(prefix, "--toolbar-search--active")
        };
      }
    }]);

    Toolbar.components = new WeakMap();
    return Toolbar;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$q(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$q = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$q = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$q(obj);
  }

  function _classCallCheck$r(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$p(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$p(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$p(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$p(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$q(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$q(subClass, superClass);
  }

  function _setPrototypeOf$q(o, p) {
    _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$q(o, p);
  }

  function _createSuper$q(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$q();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$q(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$q(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$q(this, result);
    };
  }

  function _possibleConstructorReturn$q(self, call) {
    if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$q(self);
  }

  function _assertThisInitialized$q(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$q() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$q(o) {
    _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$q(o);
  }
  function initComponentByEvent (ToMix) {
    /**
     * Mix-in class to instantiate components upon events.
     * @class InitComponentByEvent
     */
    var InitComponentByEvent = /*#__PURE__*/function (_ToMix) {
      _inherits$q(InitComponentByEvent, _ToMix);

      var _super = _createSuper$q(InitComponentByEvent);

      function InitComponentByEvent() {
        _classCallCheck$r(this, InitComponentByEvent);

        return _super.apply(this, arguments);
      }

      _createClass$p(InitComponentByEvent, null, [{
        key: "init",

        /**
         * `true` suggests that this component is lazily initialized upon an action/event, etc.
         * @type {boolean}
         */

        /**
         * Instantiates this component in the given element.
         * If the given element indicates that it's an component of this class, instantiates it.
         * Otherwise, instantiates this component by clicking on this component in the given node.
         * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
         * @param {object} [options] The component options.
         * @param {string} [options.selectorInit] The CSS selector to find this component.
         * @returns {Handle} The handle to remove the event listener to handle clicking.
         */
        value: function init() {
          var _this = this;

          var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var effectiveOptions = Object.assign(Object.create(this.options), options);

          if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
            throw new TypeError('DOM document or DOM element should be given to search for and initialize this widget.');
          }

          if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
            this.create(target, options);
          } else {
            // To work around non-bubbling `focus` event, use `focusin` event instead of it's available, and "capture mode" otherwise
            var hasFocusin = ('onfocusin' in (target.nodeType === Node.ELEMENT_NODE ? target.ownerDocument : target).defaultView);
            var handles = effectiveOptions.initEventNames.map(function (name) {
              var eventName = name === 'focus' && hasFocusin ? 'focusin' : name;
              return on(target, eventName, function (event) {
                var element = eventMatches(event, effectiveOptions.selectorInit); // Instantiated components handles events by themselves

                if (element && !_this.components.has(element)) {
                  var component = _this.create(element, options);

                  if (typeof component.createdByEvent === 'function') {
                    component.createdByEvent(event);
                  }
                }
              }, name === 'focus' && !hasFocusin);
            });
            return {
              release: function release() {
                for (var handle = handles.pop(); handle; handle = handles.pop()) {
                  handle.release();
                }
              }
            };
          }

          return '';
        }
      }]);

      InitComponentByEvent.forLazyInit = true;
      return InitComponentByEvent;
    }(ToMix);

    return InitComponentByEvent;
  }

  function _typeof$r(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$r = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$r = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$r(obj);
  }

  function _classCallCheck$s(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$q(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$q(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$q(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$q(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$r(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$r(subClass, superClass);
  }

  function _setPrototypeOf$r(o, p) {
    _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$r(o, p);
  }

  function _createSuper$r(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$r();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$r(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$r(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$r(this, result);
    };
  }

  function _possibleConstructorReturn$r(self, call) {
    if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$r(self);
  }

  function _assertThisInitialized$r(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$r() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$r(o) {
    _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$r(o);
  }

  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$1(Object(source), true).forEach(function (key) {
          _defineProperty$4(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$1(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /**
   * @param {Element} menuBody The menu body with the menu arrow.
   * @param {string} menuDirection Where the floating menu menu should be placed relative to the trigger button.
   * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
   * @private
   */

  var getMenuOffset$1 = function getMenuOffset(menuBody, menuDirection) {
    var _DIRECTION_LEFT$DIREC, _DIRECTION_LEFT$DIREC2;

    var arrowStyle = menuBody.ownerDocument.defaultView.getComputedStyle(menuBody, ':before');
    var arrowPositionProp = (_DIRECTION_LEFT$DIREC = {}, _defineProperty$4(_DIRECTION_LEFT$DIREC, DIRECTION_LEFT, 'right'), _defineProperty$4(_DIRECTION_LEFT$DIREC, DIRECTION_TOP, 'bottom'), _defineProperty$4(_DIRECTION_LEFT$DIREC, DIRECTION_RIGHT, 'left'), _defineProperty$4(_DIRECTION_LEFT$DIREC, DIRECTION_BOTTOM, 'top'), _DIRECTION_LEFT$DIREC)[menuDirection];
    var menuPositionAdjustmentProp = (_DIRECTION_LEFT$DIREC2 = {}, _defineProperty$4(_DIRECTION_LEFT$DIREC2, DIRECTION_LEFT, 'left'), _defineProperty$4(_DIRECTION_LEFT$DIREC2, DIRECTION_TOP, 'top'), _defineProperty$4(_DIRECTION_LEFT$DIREC2, DIRECTION_RIGHT, 'left'), _defineProperty$4(_DIRECTION_LEFT$DIREC2, DIRECTION_BOTTOM, 'top'), _DIRECTION_LEFT$DIREC2)[menuDirection];
    var values = [arrowPositionProp, 'border-bottom-width'].reduce(function (o, name) {
      return _objectSpread(_objectSpread({}, o), {}, _defineProperty$4({}, name, Number((/^([\d-.]+)px$/.exec(arrowStyle.getPropertyValue(name)) || [])[1])));
    }, {});
    var margin = 0;

    if (menuDirection !== DIRECTION_BOTTOM) {
      var style = menuBody.ownerDocument.defaultView.getComputedStyle(menuBody);
      margin = Number((/^([\d-.]+)px$/.exec(style.getPropertyValue('margin-top')) || [])[1]);
    }

    values[arrowPositionProp] = values[arrowPositionProp] || -6; // IE, etc.

    if (Object.keys(values).every(function (name) {
      return !isNaN(values[name]);
    })) {
      var arrowPosition = values[arrowPositionProp],
          borderBottomWidth = values['border-bottom-width'];
      return _defineProperty$4({
        left: 0,
        top: 0
      }, menuPositionAdjustmentProp, Math.sqrt(Math.pow(borderBottomWidth, 2) * 2) - arrowPosition + margin * (menuDirection === DIRECTION_TOP ? 2 : 1));
    }

    return undefined;
  };
  /**
   * Key codes for allowed keys that will trigger opening a tooltip
   * @type {Integer[]}
   * @private
   */


  var allowedOpenKeys = [32, 13];

  var Tooltip = /*#__PURE__*/function (_mixin) {
    _inherits$r(Tooltip, _mixin);

    var _super = _createSuper$r(Tooltip);
    /**
     * Tooltip.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     */


    function Tooltip(element, options) {
      var _this;

      _classCallCheck$s(this, Tooltip);

      _this = _super.call(this, element, options);
      _this._hasContextMenu = false;

      _this._hookOn(element);

      return _this;
    }
    /**
     * A flag to detect if `oncontextmenu` event is fired right before `focus`/`blur` events.
     * @type {boolean}
     */


    _createClass$q(Tooltip, [{
      key: "createdByEvent",

      /**
       * A method called when this widget is created upon events.
       * @param {Event} event The event triggering the creation.
       */
      value: function createdByEvent(event) {
        var relatedTarget = event.relatedTarget,
            type = event.type,
            which = event.which;

        if (type === 'click' || allowedOpenKeys.includes(which)) {
          this._handleClick({
            relatedTarget: relatedTarget,
            type: type,
            details: getLaunchingDetails(event)
          });
        }
      }
      /**
       * Changes the shown/hidden state.
       * @param {string} state The new state.
       * @param {object} detail The detail of the event trigging this action.
       * @param {Function} callback Callback called when change in state completes.
       */

    }, {
      key: "changeState",
      value: function changeState(state, detail, callback) {
        if (!this.tooltip) {
          var tooltip = this.element.ownerDocument.querySelector(this.element.getAttribute(this.options.attribTooltipTarget));

          if (!tooltip) {
            throw new Error('Cannot find the target tooltip.');
          } // Lazily create a component instance for tooltip


          this.tooltip = FloatingMenu.create(tooltip, {
            refNode: this.element,
            classShown: this.options.classShown,
            offset: this.options.objMenuOffset,
            contentNode: tooltip.querySelector(this.options.selectorContent)
          });

          this._hookOn(tooltip);

          this.children.push(this.tooltip);
        } // Delegates the action of changing state to the tooltip.
        // (And thus the before/after shown/hidden events are fired from the tooltip)


        this.tooltip.changeState(state, Object.assign(detail, {
          delegatorNode: this.element
        }), callback);
      }
      /**
       * Attaches event handlers to show the tooltip.
       * @param {Element} element The element to attach the events to.
       * @private
       */

    }, {
      key: "_hookOn",
      value: function _hookOn(element) {
        var _this2 = this;
        /**
         * Setup the _handleClick function for displaying a tooltip
         * @param {Event} evt - user initiated event
         * @param {Integer[]} [allowedKeys] - allowed key codes the user may press to open the tooltip
         * @private
         */


        var handleClickContextMenu = function handleClickContextMenu(evt, allowedKeys) {
          var relatedTarget = evt.relatedTarget,
              type = evt.type,
              which = evt.which; // Allow user to use `space` or `enter` to open tooltip

          if (typeof allowedKeys === 'undefined' || allowedKeys.includes(which)) {
            var hadContextMenu = _this2._hasContextMenu;
            _this2._hasContextMenu = type === 'contextmenu';

            _this2._handleClick({
              relatedTarget: relatedTarget,
              type: type,
              hadContextMenu: hadContextMenu,
              details: getLaunchingDetails(evt)
            });
          }
        };

        this.manage(on(element, 'click', handleClickContextMenu, false));

        if (this.element.tagName !== 'BUTTON') {
          this.manage(on(this.element, 'keydown', function (event) {
            handleClickContextMenu(event, allowedOpenKeys);
          }, false));
        }
      }
      /**
       * Handles click/focus events.
       * @param {object} params The parameters.
       * @param {Element} params.relatedTarget The element that focus went to. (For `blur` event)
       * @param {string} params.type The event type triggering this method.
       * @param {boolean} params.hadContextMenu
       * @param {object} params.details The event details.
       * @private
       */

    }, {
      key: "_handleClick",
      value: function _handleClick(_ref2) {
        var relatedTarget = _ref2.relatedTarget,
            type = _ref2.type,
            hadContextMenu = _ref2.hadContextMenu,
            details = _ref2.details;
        var state = {
          click: 'shown',
          keydown: 'shown',
          blur: 'hidden',
          touchleave: 'hidden',
          touchcancel: 'hidden'
        }[type];
        var shouldPreventClose;

        if (type === 'blur') {
          // Note: SVGElement in IE11 does not have `.contains()`
          var wentToSelf = relatedTarget && this.element.contains && this.element.contains(relatedTarget) || this.tooltip && this.tooltip.element.contains(relatedTarget);
          shouldPreventClose = hadContextMenu || wentToSelf;
        }

        if (!shouldPreventClose) {
          this.changeState(state, details);
        }
      }
    }], [{
      key: "options",
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-tooltip-trigger]',
          selectorContent: ".".concat(prefix, "--tooltip__content"),
          classShown: "".concat(prefix, "--tooltip--shown"),
          attribTooltipTarget: 'data-tooltip-target',
          objMenuOffset: getMenuOffset$1,
          initEventNames: ['click', 'keydown']
        };
      }
    }]);

    Tooltip.components = new WeakMap();
    return Tooltip;
  }(mixin(createComponent, initComponentByEvent, exports$1, handles));

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the `TypeError` message for "Functions" methods. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();
  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString = objectProto.toString;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max,
      nativeMin = Math.min;
  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */

  var now = function now() {
    return root.Date.now();
  };
  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */


  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    wait = toNumber(wait) || 0;

    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time; // Start the timer for the trailing edge.

      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          result = wait - timeSinceLastCall;
      return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject(value) {
    var type = _typeof(value);

    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike(value) {
    return !!value && _typeof(value) == 'object';
  }
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */


  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */


  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var lodash_debounce = debounce;

  function _typeof$s(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$s = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$s = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$s(obj);
  }

  function _classCallCheck$t(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$r(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$r(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$r(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$r(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$s(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$s(subClass, superClass);
  }

  function _setPrototypeOf$s(o, p) {
    _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$s(o, p);
  }

  function _createSuper$s(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$s();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$s(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$s(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$s(this, result);
    };
  }

  function _possibleConstructorReturn$s(self, call) {
    if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$s(self);
  }

  function _assertThisInitialized$s(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$s() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$s(o) {
    _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$s(o);
  }

  var TooltipSimple = /*#__PURE__*/function (_mixin) {
    _inherits$s(TooltipSimple, _mixin);

    var _super = _createSuper$s(TooltipSimple);
    /**
     * Simple Tooltip.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element - The element functioning as a text field.
     */


    function TooltipSimple(element, options) {
      var _this;

      _classCallCheck$t(this, TooltipSimple);

      _this = _super.call(this, element, options);
      _this.tooltipFadeOut = lodash_debounce(function () {
        var tooltipTriggerButton = _this.getTooltipTriggerButton();

        if (tooltipTriggerButton) {
          tooltipTriggerButton.classList.remove(_this.options.classTooltipVisible);
        }
      }, 100);

      _this.getTooltipTriggerButton = function () {
        return _this.element.matches(_this.options.selectorTriggerButton) ? _this.element : _this.element.querySelector(_this.options.selectorTriggerButton);
      };

      _this.allowTooltipVisibility = function (_ref) {
        var visible = _ref.visible;

        var tooltipTriggerButton = _this.getTooltipTriggerButton();

        if (!tooltipTriggerButton) {
          return;
        }

        if (visible) {
          tooltipTriggerButton.classList.remove(_this.options.classTooltipHidden);
        } else {
          tooltipTriggerButton.classList.add(_this.options.classTooltipHidden);
        }
      };

      _this.manage(on(_this.element.ownerDocument, 'keydown', function (event) {
        // ESC
        if (event.which === 27) {
          _this.allowTooltipVisibility({
            visible: false
          });

          var tooltipTriggerButton = _this.getTooltipTriggerButton();

          if (tooltipTriggerButton) {
            tooltipTriggerButton.classList.remove(_this.options.classTooltipVisible);
          }
        }
      }));

      _this.manage(on(_this.element, 'mouseenter', function () {
        _this.tooltipFadeOut.cancel();

        _this.allowTooltipVisibility({
          visible: true
        });

        var tooltipTriggerButton = _this.getTooltipTriggerButton();

        if (tooltipTriggerButton) {
          tooltipTriggerButton.classList.add(_this.options.classTooltipVisible);
        }
      }));

      _this.manage(on(_this.element, 'mouseleave', _this.tooltipFadeOut));

      _this.manage(on(_this.element, 'focusin', function (event) {
        if (eventMatches(event, _this.options.selectorTriggerButton)) {
          _this.allowTooltipVisibility({
            visible: true
          });
        }
      }));

      return _this;
    }

    _createClass$r(TooltipSimple, null, [{
      key: "options",

      /**
       * The component options.
       *
       * If `options` is specified in the constructor,
       * {@linkcode TooltipSimple.create .create()},
       * or {@linkcode TooltipSimple.init .init()},
       * properties in this object are overriden for the instance being
       * created and how {@linkcode TooltipSimple.init .init()} works.
       * @property {string} selectorInit The CSS selector to find simple tooltip UIs.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-tooltip-definition],[data-tooltip-icon]',
          selectorTriggerButton: ".".concat(prefix, "--tooltip__trigger.").concat(prefix, "--tooltip--a11y"),
          classTooltipHidden: "".concat(prefix, "--tooltip--hidden"),
          classTooltipVisible: "".concat(prefix, "--tooltip--visible")
        };
      }
      /**
       * The map associating DOM element and simple tooltip UI instance.
       * @type {WeakMap}
       */

    }]);

    TooltipSimple.components = new WeakMap();
    return TooltipSimple;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$t(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$t = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$t = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$t(obj);
  }

  function _classCallCheck$u(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$s(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$s(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$s(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$s(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$t(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$t(subClass, superClass);
  }

  function _setPrototypeOf$t(o, p) {
    _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$t(o, p);
  }

  function _createSuper$t(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$t();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$t(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$t(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$t(this, result);
    };
  }

  function _possibleConstructorReturn$t(self, call) {
    if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$t(self);
  }

  function _assertThisInitialized$t(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$t() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$t(o) {
    _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$t(o);
  }

  var toArray$7 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var ProgressIndicator = /*#__PURE__*/function (_mixin) {
    _inherits$t(ProgressIndicator, _mixin);

    var _super = _createSuper$t(ProgressIndicator);
    /**
     * ProgressIndicator.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @param {HTMLElement} element The element representing the ProgressIndicator.
     * @param {object} [options] The component options.
     * @property {string} [options.selectorStepElement] The CSS selector to find step elements.
     * @property {string} [options.selectorCurrent] The CSS selector to find the current step element.
     * @property {string} [options.selectorIncomplete] The CSS class to find incomplete step elements.
     * @property {string} [options.selectorComplete] The CSS selector to find completed step elements.
     * @property {string} [options.classStep] The className for a step element.
     * @property {string} [options.classComplete] The className for a completed step element.
     * @property {string} [options.classCurrent] The className for the current step element.
     * @property {string} [options.classIncomplete] The className for a incomplete step element.
     */


    function ProgressIndicator(element, options) {
      var _this;

      _classCallCheck$u(this, ProgressIndicator);

      _this = _super.call(this, element, options);
      /**
       * The component state.
       * @type {object}
       */

      _this.state = {
        /**
         * The current step index.
         * @type {number}
         */
        currentIndex: _this.getCurrent().index,

        /**
         * Total number of steps.
         * @type {number}
         */
        totalSteps: _this.getSteps().length
      };

      _this.addOverflowTooltip();

      return _this;
    }
    /**
     * Returns all steps with details about element and index.
     */


    _createClass$s(ProgressIndicator, [{
      key: "getSteps",
      value: function getSteps() {
        return toArray$7(this.element.querySelectorAll(this.options.selectorStepElement)).map(function (element, index) {
          return {
            element: element,
            index: index
          };
        });
      }
      /**
       * Returns current step; gives detail about element and index.
       */

    }, {
      key: "getCurrent",
      value: function getCurrent() {
        var currentEl = this.element.querySelector(this.options.selectorCurrent);
        return this.getSteps().filter(function (step) {
          return step.element === currentEl;
        })[0];
      }
      /**
       * Sets the current step.
       * * @param {Number} new step index or use default in `this.state.currentIndex`.
       */

    }, {
      key: "setCurrent",
      value: function setCurrent() {
        var _this2 = this;

        var newCurrentStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentIndex;
        var changed = false;

        if (newCurrentStep !== this.state.currentIndex) {
          this.state.currentIndex = newCurrentStep;
          changed = true;
        }

        if (changed) {
          this.getSteps().forEach(function (step) {
            if (step.index < newCurrentStep) {
              _this2._updateStep({
                element: step.element,
                className: _this2.options.classComplete,
                html: _this2._getSVGComplete()
              });
            }

            if (step.index === newCurrentStep) {
              _this2._updateStep({
                element: step.element,
                className: _this2.options.classCurrent,
                html: _this2._getCurrentSVG()
              });
            }

            if (step.index > newCurrentStep) {
              _this2._updateStep({
                element: step.element,
                className: _this2.options.classIncomplete,
                html: _this2._getIncompleteSVG()
              });
            }
          });
        }
      }
      /**
       * Update step with correct inline SVG and className
       * @param {object} args
       * @param {object} [args.element] target element
       * @param {object} [args.className] new className
       * @param {object} [args.html] new inline SVG to insert
       */

    }, {
      key: "_updateStep",
      value: function _updateStep(args) {
        var element = args.element,
            className = args.className,
            html = args.html;

        if (element.firstElementChild) {
          element.removeChild(element.firstElementChild);
        }

        if (!element.classList.contains(className)) {
          element.setAttribute('class', this.options.classStep);
          element.classList.add(className);
        }

        element.insertAdjacentHTML('afterbegin', html);
      }
      /**
       * Returns HTML string for an SVG used to represent a compelted step (checkmark)
       */

    }, {
      key: "_getSVGComplete",
      value: function _getSVGComplete() {
        return "<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n        <circle cx=\"12\" cy=\"12\" r=\"12\"></circle>\n        <polygon points=\"10.3 13.6 7.7 11 6.3 12.4 10.3 16.4 17.8 9 16.4 7.6\"></polygon>\n      </svg>";
      }
      /**
       * Returns HTML string for an SVG used to represent current step (circles, like a radio button, but not.)
       */

    }, {
      key: "_getCurrentSVG",
      value: function _getCurrentSVG() {
        return "<svg>\n        <circle cx=\"12\" cy=\"12\" r=\"12\"></circle>\n        <circle cx=\"12\" cy=\"12\" r=\"6\"></circle>\n      </svg>";
      }
      /**
       * Returns HTML string for an SVG used to represent incomple step (grey empty circle)
       */

    }, {
      key: "_getIncompleteSVG",
      value: function _getIncompleteSVG() {
        return "<svg>\n        <circle cx=\"12\" cy=\"12\" r=\"12\"></circle>\n      </svg>";
      }
    }, {
      key: "addOverflowTooltip",
      value: function addOverflowTooltip() {
        var _this3 = this;

        var stepLabels = toArray$7(this.element.querySelectorAll(this.options.selectorLabel));
        var tooltips = toArray$7(this.element.querySelectorAll(this.options.selectorTooltip));
        stepLabels.forEach(function (step) {
          if (step.scrollWidth > _this3.options.maxWidth) {
            step.classList.add(_this3.options.classOverflowLabel);
          }
        });
        tooltips.forEach(function (tooltip) {
          var childText = tooltip.querySelector(_this3.options.selectorTooltipText);

          if (childText.scrollHeight > _this3.options.tooltipMaxHeight) {
            tooltip.classList.add(_this3.options.classTooltipMulti);
          }
        });
      }
    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode ProgressIndicator.create .create()}, or {@linkcode ProgressIndicator.init .init()},
       * properties in this object are overriden for the instance being created.
       * @member ProgressIndicator.options
       * @type {object}
       * @property {string} selectorInit The CSS selector to find content switcher button set.
       * @property {string} [selectorStepElement] The CSS selector to find step elements.
       * @property {string} [selectorCurrent] The CSS selector to find the current step element.
       * @property {string} [selectorIncomplete] The CSS class to find incomplete step elements.
       * @property {string} [selectorComplete] The CSS selector to find completed step elements.
       * @property {string} [classStep] The className for a step element.
       * @property {string} [classComplete] The className for a completed step element.
       * @property {string} [classCurrent] The className for the current step element.
       * @property {string} [classIncomplete] The className for a incomplete step element.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-progress]',
          selectorStepElement: ".".concat(prefix, "--progress-step"),
          selectorCurrent: ".".concat(prefix, "--progress-step--current"),
          selectorIncomplete: ".".concat(prefix, "--progress-step--incomplete"),
          selectorComplete: ".".concat(prefix, "--progress-step--complete"),
          selectorLabel: ".".concat(prefix, "--progress-label"),
          selectorTooltip: ".".concat(prefix, "--tooltip"),
          selectorTooltipText: ".".concat(prefix, "--tooltip__text"),
          classStep: "".concat(prefix, "--progress-step"),
          classComplete: "".concat(prefix, "--progress-step--complete"),
          classCurrent: "".concat(prefix, "--progress-step--current"),
          classIncomplete: "".concat(prefix, "--progress-step--incomplete"),
          classOverflowLabel: "".concat(prefix, "--progress-label-overflow"),
          classTooltipMulti: "".concat(prefix, "--tooltip_multi"),
          maxWidth: 87,
          tooltipMaxHeight: 21
        };
      }
    }]);

    ProgressIndicator.components = new WeakMap();
    return ProgressIndicator;
  }(mixin(createComponent, initComponentBySearch));

  function _typeof$u(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$u = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$u = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$u(obj);
  }

  function _classCallCheck$v(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$t(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$t(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$t(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$t(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$u(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$u(subClass, superClass);
  }

  function _setPrototypeOf$u(o, p) {
    _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$u(o, p);
  }

  function _createSuper$u(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$u();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$u(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$u(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$u(this, result);
    };
  }

  function _possibleConstructorReturn$u(self, call) {
    if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$u(self);
  }

  function _assertThisInitialized$u(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$u() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$u(o) {
    _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$u(o);
  }

  var toArray$8 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var StructuredList = /*#__PURE__*/function (_mixin) {
    _inherits$u(StructuredList, _mixin);

    var _super = _createSuper$u(StructuredList);
    /**
     * StructuredList
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The root element of tables
     * @param {object} [options] the... options
     * @param {string} [options.selectorInit] selector initialization
     * @param {string} [options.selectorRow] css selector for selected row
     */


    function StructuredList(element, options) {
      var _this;

      _classCallCheck$v(this, StructuredList);

      _this = _super.call(this, element, options);

      _this.manage(on(_this.element, 'keydown', function (evt) {
        if (evt.which === 37 || evt.which === 38 || evt.which === 39 || evt.which === 40) {
          _this._handleKeydownArrow(evt);
        }

        if (evt.which === 13 || evt.which === 32) {
          _this._handleKeydownChecked(evt);
        }
      }));

      _this.manage(on(_this.element, 'click', function (evt) {
        _this._handleClick(evt);
      }));

      return _this;
    }

    _createClass$t(StructuredList, [{
      key: "_direction",
      value: function _direction(evt) {
        return {
          37: -1,
          // backward
          38: -1,
          // backward
          39: 1,
          // forward
          40: 1 // forward

        }[evt.which];
      }
    }, {
      key: "_nextIndex",
      value: function _nextIndex(array, arrayItem, direction) {
        return array.indexOf(arrayItem) + direction; // returns -1, 0, 1, 2, 3, 4...
      }
    }, {
      key: "_getInput",
      value: function _getInput(index) {
        var rows = toArray$8(this.element.querySelectorAll(this.options.selectorRow));
        return this.element.ownerDocument.querySelector(this.options.selectorListInput(rows[index].getAttribute('for')));
      }
    }, {
      key: "_handleInputChecked",
      value: function _handleInputChecked(index) {
        var rows = this.element.querySelectorAll(this.options.selectorRow);
        var input = this.getInput(index) || rows[index].querySelector('input');
        input.checked = true;
      }
    }, {
      key: "_handleClick",
      value: function _handleClick(evt) {
        var _this2 = this;

        var selectedRow = eventMatches(evt, this.options.selectorRow);
        toArray$8(this.element.querySelectorAll(this.options.selectorRow)).forEach(function (row) {
          return row.classList.remove(_this2.options.classActive);
        });

        if (selectedRow) {
          selectedRow.classList.add(this.options.classActive);
        }
      } // Handle Enter or Space keydown events for selecting <label> rows

    }, {
      key: "_handleKeydownChecked",
      value: function _handleKeydownChecked(evt) {
        var _this3 = this;

        evt.preventDefault(); // prevent spacebar from scrolling page

        var selectedRow = eventMatches(evt, this.options.selectorRow);
        toArray$8(this.element.querySelectorAll(this.options.selectorRow)).forEach(function (row) {
          return row.classList.remove(_this3.options.classActive);
        });

        if (selectedRow) {
          selectedRow.classList.add(this.options.classActive);
          var input = selectedRow.querySelector(this.options.selectorListInput(selectedRow.getAttribute('for'))) || selectedRow.querySelector('input');
          input.checked = true;
        }
      } // Handle up and down keydown events for selecting <label> rows

    }, {
      key: "_handleKeydownArrow",
      value: function _handleKeydownArrow(evt) {
        var _this4 = this;

        evt.preventDefault(); // prevent arrow keys from scrolling

        var selectedRow = eventMatches(evt, this.options.selectorRow);

        var direction = this._direction(evt);

        if (direction && selectedRow !== undefined) {
          var rows = toArray$8(this.element.querySelectorAll(this.options.selectorRow));
          rows.forEach(function (row) {
            return row.classList.remove(_this4.options.classActive);
          });
          var firstIndex = 0;

          var nextIndex = this._nextIndex(rows, selectedRow, direction);

          var lastIndex = rows.length - 1;

          var getSelectedIndex = function getSelectedIndex() {
            switch (nextIndex) {
              case -1:
                return lastIndex;

              case rows.length:
                return firstIndex;

              default:
                return nextIndex;
            }
          };

          var selectedIndex = getSelectedIndex();
          rows[selectedIndex].classList.add(this.options.classActive);
          rows[selectedIndex].focus();

          this._handleInputChecked(selectedIndex);
        }
      }
    }], [{
      key: "options",
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-structured-list]',
          selectorRow: "[data-structured-list] .".concat(prefix, "--structured-list-tbody > label.").concat(prefix, "--structured-list-row"),
          selectorListInput: function selectorListInput(id) {
            return "#".concat(id, ".").concat(prefix, "--structured-list-input");
          },
          classActive: "".concat(prefix, "--structured-list-row--selected")
        };
      }
    }]);

    StructuredList.components = new WeakMap();
    return StructuredList;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$v(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$v = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$v = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$v(obj);
  }

  function _classCallCheck$w(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$u(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$u(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$u(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$u(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$v(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$v(subClass, superClass);
  }

  function _setPrototypeOf$v(o, p) {
    _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$v(o, p);
  }

  function _createSuper$v(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$v();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$v(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$v(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$v(this, result);
    };
  }

  function _possibleConstructorReturn$v(self, call) {
    if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$v(self);
  }

  function _assertThisInitialized$v(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$v() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$v(o) {
    _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$v(o);
  }

  var Slider = /*#__PURE__*/function (_mixin) {
    _inherits$v(Slider, _mixin);

    var _super = _createSuper$v(Slider);
    /**
     * Slider.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as an slider.
     */


    function Slider(element, options) {
      var _this;

      _classCallCheck$w(this, Slider);

      _this = _super.call(this, element, options);

      _this._changeState = function (state, detail, callback) {
        callback();
      };

      _this.sliderActive = false;
      _this.dragging = false;
      _this.track = _this.element.querySelector(_this.options.selectorTrack);
      _this.filledTrack = _this.element.querySelector(_this.options.selectorFilledTrack);
      _this.thumb = _this.element.querySelector(_this.options.selectorThumb);
      _this.input = _this.element.querySelector(_this.options.selectorInput);

      if (_this.element.dataset.sliderInputBox) {
        _this.boundInput = _this.element.ownerDocument.querySelector(_this.element.dataset.sliderInputBox);

        _this._updateInput();

        _this.manage(on(_this.boundInput, 'change', function (evt) {
          _this.setValue(evt.target.value);
        }));

        _this.manage(on(_this.boundInput, 'focus', function (evt) {
          evt.target.select();
        })); // workaround for safari


        _this.manage(on(_this.boundInput, 'mouseup', function (evt) {
          evt.preventDefault();
        }));
      }

      _this._updatePosition();

      _this.manage(on(_this.thumb, 'mousedown', function () {
        _this.sliderActive = true;
      }));

      _this.manage(on(_this.element.ownerDocument, 'mouseup', function () {
        _this.sliderActive = false;
      }));

      _this.manage(on(_this.element.ownerDocument, 'mousemove', function (evt) {
        var disabled = _this.element.classList.contains(_this.options.classDisabled);

        if (_this.sliderActive === true && !disabled) {
          _this._updatePosition(evt);
        }
      }));

      _this.manage(on(_this.thumb, 'keydown', function (evt) {
        var disabled = _this.element.classList.contains(_this.options.classDisabled);

        if (!disabled) {
          _this._updatePosition(evt);
        }
      }));

      _this.manage(on(_this.track, 'click', function (evt) {
        var disabled = _this.element.classList.contains(_this.options.classDisabled);

        if (!disabled) {
          _this._updatePosition(evt);
        }
      }));

      return _this;
    }

    _createClass$u(Slider, [{
      key: "_updatePosition",
      value: function _updatePosition(evt) {
        var _this2 = this;

        var _this$_calcValue = this._calcValue(evt),
            left = _this$_calcValue.left,
            newValue = _this$_calcValue.newValue;

        if (this.dragging) {
          return;
        }

        this.dragging = true;
        requestAnimationFrame(function () {
          _this2.dragging = false;
          _this2.thumb.style.left = "".concat(left, "%");
          _this2.filledTrack.style.transform = "translate(0%, -50%) scaleX(".concat(left / 100, ")");
          _this2.input.value = newValue;

          _this2._updateInput();

          _this2.changeState('slider-value-change', {
            value: newValue
          });
        });
      }
    }, {
      key: "_calcValue",
      value: function _calcValue(evt) {
        var _this$getInputProps = this.getInputProps(),
            value = _this$getInputProps.value,
            min = _this$getInputProps.min,
            max = _this$getInputProps.max,
            step = _this$getInputProps.step;

        var range = max - min;
        var valuePercentage = (value - min) / range * 100;
        var left;
        var newValue;
        left = valuePercentage;
        newValue = value;

        if (evt) {
          var type = evt.type;

          if (type === 'keydown') {
            var direction = {
              40: -1,
              // decreasing
              37: -1,
              // decreasing
              38: 1,
              // increasing
              39: 1 // increasing

            }[evt.which];

            if (direction !== undefined) {
              var multiplier = evt.shiftKey === true ? range / step / this.options.stepMultiplier : 1;
              var stepMultiplied = step * multiplier;
              var stepSize = stepMultiplied / range * 100;
              left = valuePercentage + stepSize * direction;
              newValue = Number(value) + stepMultiplied * direction;
            }
          }

          if (type === 'mousemove' || type === 'click') {
            if (type === 'click') {
              this.element.querySelector(this.options.selectorThumb).classList.add(this.options.classThumbClicked);
            } else {
              this.element.querySelector(this.options.selectorThumb).classList.remove(this.options.classThumbClicked);
            }

            var track = this.track.getBoundingClientRect();
            var unrounded = (evt.clientX - track.left) / track.width;
            var rounded = Math.round(range * unrounded / step) * step;
            left = rounded / range * 100;
            newValue = rounded + min;
          }
        }

        if (newValue <= Number(min)) {
          left = 0;
          newValue = min;
        }

        if (newValue >= Number(max)) {
          left = 100;
          newValue = max;
        }

        return {
          left: left,
          newValue: newValue
        };
      }
    }, {
      key: "_updateInput",
      value: function _updateInput() {
        if (this.boundInput) {
          this.boundInput.value = this.input.value;
        }
      }
    }, {
      key: "getInputProps",
      value: function getInputProps() {
        var values = {
          value: Number(this.input.value),
          min: Number(this.input.min),
          max: Number(this.input.max),
          step: this.input.step ? Number(this.input.step) : 1
        };
        return values;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.input.value = value;

        this._updatePosition();
      }
    }, {
      key: "stepUp",
      value: function stepUp() {
        this.input.stepUp();

        this._updatePosition();
      }
    }, {
      key: "stepDown",
      value: function stepDown() {
        this.input.stepDown();

        this._updatePosition();
      }
      /**
       * The map associating DOM element and Slider UI instance.
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * properties in this object are overriden for the instance being created.
       * @property {string} selectorInit The CSS selector to find slider instances.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-slider]',
          selectorTrack: ".".concat(prefix, "--slider__track"),
          selectorFilledTrack: ".".concat(prefix, "--slider__filled-track"),
          selectorThumb: ".".concat(prefix, "--slider__thumb"),
          selectorInput: ".".concat(prefix, "--slider__input"),
          classDisabled: "".concat(prefix, "--slider--disabled"),
          classThumbClicked: "".concat(prefix, "--slider__thumb--clicked"),
          eventBeforeSliderValueChange: 'slider-before-value-change',
          eventAfterSliderValueChange: 'slider-after-value-change',
          stepMultiplier: 4
        };
      }
    }]);

    Slider.components = new WeakMap();
    return Slider;
  }(mixin(createComponent, initComponentBySearch, eventedState, handles));

  function _typeof$w(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$w = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$w = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$w(obj);
  }

  function _classCallCheck$x(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$v(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$v(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$v(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$v(Constructor, staticProps);
    return Constructor;
  }

  function _get$3(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get$3 = Reflect.get;
    } else {
      _get$3 = function _get(target, property, receiver) {
        var base = _superPropBase$3(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get$3(target, property, receiver || target);
  }

  function _superPropBase$3(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$w(object);
      if (object === null) break;
    }

    return object;
  }

  function _inherits$w(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$w(subClass, superClass);
  }

  function _setPrototypeOf$w(o, p) {
    _setPrototypeOf$w = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$w(o, p);
  }

  function _createSuper$w(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$w();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$w(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$w(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$w(this, result);
    };
  }

  function _possibleConstructorReturn$w(self, call) {
    if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$w(self);
  }

  function _assertThisInitialized$w(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$w() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$w(o) {
    _getPrototypeOf$w = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$w(o);
  }

  var Tile = /*#__PURE__*/function (_mixin) {
    _inherits$w(Tile, _mixin);

    var _super = _createSuper$w(Tile);
    /**
     * Tile.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @param {HTMLElement} element The element working as an Tile.
     */


    function Tile(element, options) {
      var _this;

      _classCallCheck$x(this, Tile);

      _this = _super.call(this, element, options);

      _this._getClass = function (type) {
        var typeObj = {
          expandable: _this.options.classExpandedTile,
          clickable: _this.options.classClickableTile,
          selectable: _this.options.classSelectableTile
        };
        return typeObj[type];
      };

      _this._hookActions = function (tileClass) {
        var isExpandable = _this.tileType === 'expandable';

        if (isExpandable) {
          var aboveTheFold = _this.element.querySelector(_this.options.selectorAboveTheFold);

          var getStyle = _this.element.ownerDocument.defaultView.getComputedStyle(_this.element, null);

          var tilePaddingTop = parseInt(getStyle.getPropertyValue('padding-top'), 10);
          var tilePaddingBottom = parseInt(getStyle.getPropertyValue('padding-bottom'), 10);
          var tilePadding = tilePaddingTop + tilePaddingBottom;

          if (aboveTheFold) {
            _this.tileHeight = _this.element.getBoundingClientRect().height;
            _this.atfHeight = aboveTheFold.getBoundingClientRect().height + tilePadding;
            _this.element.style.maxHeight = "".concat(_this.atfHeight, "px");
          }

          if (_this.element.classList.contains(_this.options.classExpandedTile)) {
            _this._setTileHeight();
          }
        }

        _this.element.addEventListener('click', function (evt) {
          var input = eventMatches(evt, _this.options.selectorTileInput);

          if (!input) {
            _this.element.classList.toggle(tileClass);
          }

          if (isExpandable) {
            _this._setTileHeight();
          }
        });

        _this.element.addEventListener('keydown', function (evt) {
          var input = _this.element.querySelector(_this.options.selectorTileInput);

          if (input) {
            if (evt.which === 13 || evt.which === 32) {
              if (!isExpandable) {
                _this.element.classList.toggle(tileClass);

                input.checked = !input.checked;
              }
            }
          }
        });
      };

      _this._setTileHeight = function () {
        var isExpanded = _this.element.classList.contains(_this.options.classExpandedTile);

        _this.element.style.maxHeight = isExpanded ? "".concat(_this.tileHeight, "px") : "".concat(_this.atfHeight, "px");
      };

      _this.tileType = _this.element.dataset.tile;
      _this.tileHeight = 0; // Tracks expandable tile height

      _this.atfHeight = 0; // Tracks above the fold height

      _this._hookActions(_this._getClass(_this.tileType));

      return _this;
    }

    _createClass$v(Tile, [{
      key: "release",
      value: function release() {
        _get$3(_getPrototypeOf$w(Tile.prototype), "release", this).call(this);
      }
      /**
       * The map associating DOM element and Tile UI instance.
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * properties in this object are overriden for the instance being created.
       * @property {string} selectorInit The CSS selector to find Tile instances.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-tile]',
          selectorAboveTheFold: '[data-tile-atf]',
          selectorTileInput: '[data-tile-input]',
          classExpandedTile: "".concat(prefix, "--tile--is-expanded"),
          classClickableTile: "".concat(prefix, "--tile--is-clicked"),
          classSelectableTile: "".concat(prefix, "--tile--is-selected")
        };
      }
    }]);

    Tile.components = new WeakMap();
    return Tile;
  }(mixin(createComponent, initComponentBySearch));

  function _typeof$x(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$x = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$x = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$x(obj);
  }

  function _classCallCheck$y(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$w(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$w(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$w(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$w(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$x(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$x(subClass, superClass);
  }

  function _setPrototypeOf$x(o, p) {
    _setPrototypeOf$x = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$x(o, p);
  }

  function _createSuper$x(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$x();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$x(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$x(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$x(this, result);
    };
  }

  function _possibleConstructorReturn$x(self, call) {
    if (call && (_typeof$x(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$x(self);
  }

  function _assertThisInitialized$x(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$x() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$x(o) {
    _getPrototypeOf$x = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$x(o);
  }

  var CodeSnippet = /*#__PURE__*/function (_mixin) {
    _inherits$x(CodeSnippet, _mixin);

    var _super = _createSuper$x(CodeSnippet);
    /**
     * CodeSnippet UI.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a CodeSnippet UI.
     */


    function CodeSnippet(element, options) {
      var _this;

      _classCallCheck$y(this, CodeSnippet);

      _this = _super.call(this, element, options);

      _this._initCodeSnippet();

      _this.element.querySelector(_this.options.classExpandBtn).addEventListener('click', function (evt) {
        return _this._handleClick(evt);
      });

      return _this;
    }

    _createClass$w(CodeSnippet, [{
      key: "_handleClick",
      value: function _handleClick() {
        var expandBtn = this.element.querySelector(this.options.classExpandText);
        this.element.classList.toggle(this.options.classExpanded);

        if (this.element.classList.contains(this.options.classExpanded)) {
          expandBtn.textContent = expandBtn.getAttribute(this.options.attribShowLessText);
        } else {
          expandBtn.textContent = expandBtn.getAttribute(this.options.attribShowMoreText);
        }
      }
    }, {
      key: "_initCodeSnippet",
      value: function _initCodeSnippet() {
        var expandBtn = this.element.querySelector(this.options.classExpandText);

        if (!expandBtn) {
          throw new TypeError('Cannot find the expand button.');
        }

        expandBtn.textContent = expandBtn.getAttribute(this.options.attribShowMoreText);

        if (this.element.offsetHeight < this.options.minHeight) {
          this.element.classList.add(this.options.classHideExpand);
        }
      }
      /**
       * The map associating DOM element and code snippet UI instance.
       * @member CodeSnippet.components
       * @type {WeakMap}
       */

    }], [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode CodeSnippet.create .create()},
       * or {@linkcode CodeSnippet.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode CodeSnippet.init .init()} works.
       * @member CodeSnippet.options
       * @type {object}
       * @property {string} selectorInit The data attribute to find code snippet UIs.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-code-snippet]',
          attribShowMoreText: 'data-show-more-text',
          attribShowLessText: 'data-show-less-text',
          minHeight: 288,
          classExpanded: "".concat(prefix, "--snippet--expand"),
          classExpandBtn: ".".concat(prefix, "--snippet-btn--expand"),
          classExpandText: ".".concat(prefix, "--snippet-btn--text"),
          classHideExpand: "".concat(prefix, "--snippet-btn--expand--hide")
        };
      }
    }]);

    CodeSnippet.components = new WeakMap();
    return CodeSnippet;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$y(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$y = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$y = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$y(obj);
  }

  function _classCallCheck$z(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$x(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$x(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$x(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$x(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$y(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$y(subClass, superClass);
  }

  function _setPrototypeOf$y(o, p) {
    _setPrototypeOf$y = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$y(o, p);
  }

  function _createSuper$y(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$y();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$y(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$y(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$y(this, result);
    };
  }

  function _possibleConstructorReturn$y(self, call) {
    if (call && (_typeof$y(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$y(self);
  }

  function _assertThisInitialized$y(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$y() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$y(o) {
    _getPrototypeOf$y = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$y(o);
  }

  var TextInput = /*#__PURE__*/function (_mixin) {
    _inherits$y(TextInput, _mixin);

    var _super = _createSuper$y(TextInput);
    /**
     * Text Input.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element - The element functioning as a text field.
     */


    function TextInput(_element, options) {
      var _this;

      _classCallCheck$z(this, TextInput);

      _this = _super.call(this, _element, options);

      _this._setIconVisibility = function (_ref) {
        var iconVisibilityOn = _ref.iconVisibilityOn,
            iconVisibilityOff = _ref.iconVisibilityOff,
            passwordIsVisible = _ref.passwordIsVisible,
            selectorPasswordVisibilityTooltip = _ref.selectorPasswordVisibilityTooltip;

        if (passwordIsVisible) {
          iconVisibilityOn.setAttribute('hidden', true);
          iconVisibilityOff.removeAttribute('hidden');
          selectorPasswordVisibilityTooltip.textContent = 'Hide password';
          return;
        }

        iconVisibilityOn.removeAttribute('hidden');
        iconVisibilityOff.setAttribute('hidden', true);
        selectorPasswordVisibilityTooltip.textContent = 'Show password';
      };

      _this._toggle = function (_ref2) {
        var element = _ref2.element,
            button = _ref2.button; // toggle action must come before querying the classList

        element.classList.toggle(_this.options.passwordIsVisible);
        var passwordIsVisible = element.classList.contains(_this.options.passwordIsVisible);
        var iconVisibilityOn = button.querySelector(_this.options.svgIconVisibilityOn);
        var iconVisibilityOff = button.querySelector(_this.options.svgIconVisibilityOff);
        var input = element.querySelector(_this.options.selectorPasswordField);
        var selectorPasswordVisibilityTooltip = element.querySelector(_this.options.selectorPasswordVisibilityTooltip);

        _this._setIconVisibility({
          iconVisibilityOn: iconVisibilityOn,
          iconVisibilityOff: iconVisibilityOff,
          passwordIsVisible: passwordIsVisible,
          selectorPasswordVisibilityTooltip: selectorPasswordVisibilityTooltip
        });

        input.type = passwordIsVisible ? 'text' : 'password';
      };

      _this.manage(on(_this.element, 'click', function (event) {
        var toggleVisibilityButton = eventMatches(event, _this.options.selectorPasswordVisibilityButton);

        if (toggleVisibilityButton) {
          _this._toggle({
            element: _element,
            button: toggleVisibilityButton
          });
        }
      }));

      return _this;
    }
    /**
     *
     * @param {object} obj - Object containing selectors and visibility status
     * @param {HTMLElement} obj.iconVisibilityOn - The element functioning as
     * the SVG icon for visibility on
     * @param {HTMLElement} obj.iconVisibilityOff - The element functioning as
     * the SVG icon for visibility off
     * @param {boolean} obj.passwordIsVisible - The visibility of the password in the
     * input field
     */


    _createClass$x(TextInput, null, [{
      key: "options",

      /**
       * The component options.
       *
       * If `options` is specified in the constructor,
       * {@linkcode TextInput.create .create()},
       * or {@linkcode TextInput.init .init()},
       * properties in this object are overriden for the instance being
       * created and how {@linkcode TextInput.init .init()} works.
       * @property {string} selectorInit The CSS selector to find text input UIs.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-text-input]',
          selectorPasswordField: ".".concat(prefix, "--text-input[data-toggle-password-visibility]"),
          selectorPasswordVisibilityButton: ".".concat(prefix, "--text-input--password__visibility__toggle"),
          selectorPasswordVisibilityTooltip: ".".concat(prefix, "--text-input--password__visibility__toggle > .").concat(prefix, "--assistive-text"),
          passwordIsVisible: "".concat(prefix, "--text-input--password-visible"),
          svgIconVisibilityOn: "svg.".concat(prefix, "--icon--visibility-on"),
          svgIconVisibilityOff: "svg.".concat(prefix, "--icon--visibility-off")
        };
      }
      /**
       * The map associating DOM element and text input UI instance.
       * @type {WeakMap}
       */

    }]);

    TextInput.components = new WeakMap();
    return TextInput;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$z(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$z = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$z = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$z(obj);
  }

  function _toConsumableArray$6(arr) {
    return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$6();
  }

  function _nonIterableSpread$6() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$6(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
  }

  function _iterableToArray$6(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$6(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$6(arr);
  }

  function _arrayLikeToArray$6(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _classCallCheck$A(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$y(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$y(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$y(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$y(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$z(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$z(subClass, superClass);
  }

  function _setPrototypeOf$z(o, p) {
    _setPrototypeOf$z = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$z(o, p);
  }

  function _createSuper$z(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$z();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$z(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$z(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$z(this, result);
    };
  }

  function _possibleConstructorReturn$z(self, call) {
    if (call && (_typeof$z(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$z(self);
  }

  function _assertThisInitialized$z(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$z() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$z(o) {
    _getPrototypeOf$z = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$z(o);
  }
  var prefix = settings_1.prefix;

  var SideNav = /*#__PURE__*/function (_mixin) {
    _inherits$z(SideNav, _mixin);

    var _super = _createSuper$z(SideNav);
    /**
     * The map associating DOM element and copy button UI instance.
     * @member SideNav.components
     * @type {WeakMap}
     */

    /**
     * Side nav.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a side nav.
     * @param {object} [options] The component options.
     * @param {string} [options.selectorSideNavToggle]
     *   The CSS selector to find the toggle button.
     * @param {string} [options.selectorSideNavSubmenu] The CSS selector to find the trigger buttons for sub nav items.
     * @param {string} [options.selectorSideNavItem] The CSS selector to find the nav items.
     * @param {string} [options.selectorSideNavLink] The CSS selector to find the interactive potions in non-nested nav items.
     * @param {string} [options.selectorSideNavLinkCurrent]
     *   The CSS selector to find the interactive potion in active non-nested nav item.
     * @param {string} [options.classSideNavExpanded] The CSS class for the expanded state.
     * @param {string} [options.classSideNavItemActive]
     *   The CSS class for the active/inactive state for nav items.
     * @param {string} [options.classSideNavLinkCurrent]
     *   The CSS class for the active/inactive state of the interactive potion in non-nested nav items.
     */


    function SideNav(element, options) {
      var _this;

      _classCallCheck$A(this, SideNav);

      _this = _super.call(this, element, options);

      _this._handleClick = function (evt) {
        var matchesToggle = eventMatches(evt, _this.options.selectorSideNavToggle);
        var matchesNavSubmenu = eventMatches(evt, _this.options.selectorSideNavSubmenu);
        var matchesSideNavLink = eventMatches(evt, _this.options.selectorSideNavLink);

        if (!matchesToggle && !matchesNavSubmenu && !matchesSideNavLink) {
          return;
        }

        if (matchesToggle) {
          _this.changeState(!_this.isNavExpanded() ? _this.constructor.state.EXPANDED : _this.constructor.state.COLLAPSED);

          return;
        }

        if (matchesNavSubmenu) {
          var isSubmenuExpanded = matchesNavSubmenu.getAttribute('aria-expanded') === 'true';
          matchesNavSubmenu.setAttribute('aria-expanded', "".concat(!isSubmenuExpanded));
          return;
        }

        if (matchesSideNavLink) {
          _toConsumableArray$6(_this.element.querySelectorAll(_this.options.selectorSideNavLinkCurrent)).forEach(function (el) {
            el.classList.remove(_this.options.classSideNavItemActive, _this.options.classSideNavLinkCurrent);
            el.removeAttribute('aria-current');
          });

          matchesSideNavLink.classList.add(_this.options.classSideNavLinkCurrent);
          var closestSideNavItem = matchesSideNavLink.closest(_this.options.selectorSideNavItem);

          if (closestSideNavItem) {
            closestSideNavItem.classList.add(_this.options.classSideNavItemActive);
          }
        }
      };

      _this.manage(on(element, 'click', _this._handleClick));

      return _this;
    }
    /**
     * Enum for toggling side nav visibility
     * @readonly
     * @member SideNav.state
     * @type {object}
     * @property {string} EXPANDED Opening/visible
     * @property {string} COLLAPSED Closing/hidden
     */


    _createClass$y(SideNav, [{
      key: "isNavExpanded",

      /**
       * @returns {boolean} `true` if the nav is expanded.
       */
      value: function isNavExpanded() {
        return this.element.classList.contains(this.options.classSideNavExpanded);
      }
      /**
       * Changes the expanded/collapsed state.
       */

    }, {
      key: "changeState",
      value: function changeState(state) {
        this.element.classList.toggle(this.options.classSideNavExpanded, state === this.constructor.state.EXPANDED);
      }
    }]);

    SideNav.components = new WeakMap();
    SideNav.state = {
      EXPANDED: 'expanded',
      COLLAPSED: 'collapsed'
    };
    SideNav.options = {
      selectorInit: '[data-side-nav]',
      selectorSideNavToggle: ".".concat(prefix, "--side-nav__toggle"),
      selectorSideNavSubmenu: ".".concat(prefix, "--side-nav__submenu"),
      selectorSideNavItem: ".".concat(prefix, "--side-nav__item"),
      selectorSideNavLink: ".".concat(prefix, "--side-nav__link"),
      selectorSideNavLinkCurrent: "[aria-current=\"page\"],.".concat(prefix, "--side-nav__link--current,.").concat(prefix, "--side-nav__item--active"),
      classSideNavExpanded: "".concat(prefix, "--side-nav--expanded"),
      classSideNavItemActive: "".concat(prefix, "--side-nav__item--active"),
      classSideNavLinkCurrent: "".concat(prefix, "--side-nav__link--current")
    };
    return SideNav;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$A(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$A = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$A = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$A(obj);
  }

  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$1();
  }

  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$7(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
  }

  function _arrayLikeToArray$7(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _iterableToArrayLimit$1(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _classCallCheck$B(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$z(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$z(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$z(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$z(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$A(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$A(subClass, superClass);
  }

  function _setPrototypeOf$A(o, p) {
    _setPrototypeOf$A = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$A(o, p);
  }

  function _createSuper$A(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$A();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$A(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$A(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$A(this, result);
    };
  }

  function _possibleConstructorReturn$A(self, call) {
    if (call && (_typeof$A(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$A(self);
  }

  function _assertThisInitialized$A(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$A() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$A(o) {
    _getPrototypeOf$A = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$A(o);
  }

  var forEach = /* #__PURE__ */function () {
    return Array.prototype.forEach;
  }();

  var toArray$9 = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var HeaderSubmenu = /*#__PURE__*/function (_mixin) {
    _inherits$A(HeaderSubmenu, _mixin);

    var _super = _createSuper$A(HeaderSubmenu);
    /**
     * Sub menus in header nav.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a submenu in header nav.
     * @param {object} [options] The component options.
     * @param {string} [options.selectorTrigger] The CSS selector to find the trigger button.
     * @param {string} [options.selectorItem] The CSS selector to find the menu items.
     * @param {string} [options.attribExpanded] The attribute that represents the expanded/collapsed state.
     */


    function HeaderSubmenu(element, options) {
      var _this;

      _classCallCheck$B(this, HeaderSubmenu);

      _this = _super.call(this, element, options);

      _this._getAction = function (event) {
        var isFlyoutMenu = eventMatches(event, _this.options.selectorFlyoutMenu);

        if (isFlyoutMenu) {
          return _this.constructor.actions.DELEGATE_TO_FLYOUT_MENU;
        }

        switch (event.type) {
          case 'keydown':
            return {
              32: _this.constructor.actions.TOGGLE_SUBMENU_WITH_FOCUS,
              // space bar
              13: _this.constructor.actions.TOGGLE_SUBMENU_WITH_FOCUS,
              // enter
              27: _this.constructor.actions.CLOSE_SUBMENU // esc
              // possible arrow keys

            }[event.which];

          case 'click':
            return eventMatches(event, _this.options.selectorItem) ? _this.constructor.actions.CLOSE_SUBMENU : null;

          case 'blur':
          case 'focusout':
            {
              var isOfSelf = _this.element.contains(event.relatedTarget);

              return isOfSelf ? null : _this.constructor.actions.CLOSE_SUBMENU;
            }

          case 'mouseenter':
            return _this.constructor.actions.OPEN_SUBMENU;

          case 'mouseleave':
            return _this.constructor.actions.CLOSE_SUBMENU;

          default:
            return null;
        }
      };

      _this._getNewState = function (action) {
        var trigger = _this.element.querySelector(_this.options.selectorTrigger);

        var isExpanded = trigger.getAttribute(_this.options.attribExpanded) === 'true';

        switch (action) {
          case _this.constructor.actions.CLOSE_SUBMENU:
            return false;

          case _this.constructor.actions.OPEN_SUBMENU:
            return true;

          case _this.constructor.actions.TOGGLE_SUBMENU_WITH_FOCUS:
            return !isExpanded;

          default:
            return isExpanded;
        }
      };

      _this._setState = function (_ref) {
        var shouldBeExpanded = _ref.shouldBeExpanded,
            shouldFocusOnOpen = _ref.shouldFocusOnOpen;

        var trigger = _this.element.querySelector(_this.options.selectorTrigger);

        trigger.setAttribute(_this.options.attribExpanded, shouldBeExpanded);
        forEach.call(_this.element.querySelectorAll(_this.options.selectorItem), function (item) {
          item.tabIndex = shouldBeExpanded ? 0 : -1;
        }); // focus first submenu item

        if (shouldBeExpanded && shouldFocusOnOpen) {
          _this.element.querySelector(_this.options.selectorItem).focus();
        }
      };

      _this.getCurrentNavigation = function () {
        var focused = _this.element.ownerDocument.activeElement;
        return focused.nodeType === Node.ELEMENT_NODE && focused.matches(_this.options.selectorItem) ? focused : null;
      };

      _this.navigate = function (direction) {
        var items = toArray$9(_this.element.querySelectorAll(_this.options.selectorItem));

        var start = _this.getCurrentNavigation() || _this.element.querySelector(_this.options.selectorItemSelected);

        var getNextItem = function getNextItem(old) {
          var handleUnderflow = function handleUnderflow(index, length) {
            return index + (index >= 0 ? 0 : length);
          };

          var handleOverflow = function handleOverflow(index, length) {
            return index - (index < length ? 0 : length);
          }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


          var index = Math.max(items.indexOf(old) + direction, -1);
          return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
        };

        for (var current = getNextItem(start); current && current !== start; current = getNextItem(current)) {
          if (!current.matches(_this.options.selectorItemHidden) && !current.parentNode.matches(_this.options.selectorItemHidden) && !current.matches(_this.options.selectorItemSelected)) {
            current.focus();
            break;
          }
        }
      };

      _this._handleEvent = function (event) {
        var trigger = _this.element.querySelector(_this.options.selectorTrigger);

        if (!trigger) {
          return;
        }

        var action = _this._getAction(event);

        if (action) {
          var shouldBeExpanded = _this._getNewState(action);

          _this._setState({
            shouldBeExpanded: shouldBeExpanded
          });
        }
      };

      _this._handleKeyDown = function (event) {
        var trigger = _this.element.querySelector(_this.options.selectorTrigger);

        if (!trigger) {
          return;
        }

        var action = _this._getAction(event);

        if (event.which === 32) {
          event.preventDefault();
        }

        switch (action) {
          case _this.constructor.actions.DELEGATE_TO_FLYOUT_MENU:
            // currently we do not have a scenario that handles flyout menu
            // handleFlyoutMenu
            break;
          // currently we do not have a scenario that opens a submenu on keydown
          // case this.constructor.actions.OPEN_SUBMENU:

          case _this.constructor.actions.CLOSE_SUBMENU:
            {
              var shouldBeExpanded = _this._getNewState(action);

              _this._setState({
                shouldBeExpanded: shouldBeExpanded
              });

              break;
            }

          case _this.constructor.actions.TOGGLE_SUBMENU_WITH_FOCUS:
            {
              var _shouldBeExpanded = _this._getNewState(action);

              _this._setState({
                shouldBeExpanded: _shouldBeExpanded,
                shouldFocusOnOpen: true
              });

              break;
            }

          default:
            {
              var expanded = trigger.getAttribute(_this.options.attribExpanded) === 'true';

              if (expanded) {
                var direction = {
                  38: _this.constructor.NAVIGATE.BACKWARD,
                  40: _this.constructor.NAVIGATE.FORWARD
                }[event.which];

                switch (event.which) {
                  case 35:
                    {
                      // end key
                      event.preventDefault(); // prevents key from scrolling page

                      var menuItems = _this.element.querySelectorAll(_this.options.selectorItem);

                      var lastMenuItem = menuItems[menuItems.length - 1];

                      if (lastMenuItem) {
                        lastMenuItem.focus();
                      }

                      break;
                    }

                  case 36:
                    {
                      // home key
                      event.preventDefault(); // prevents key from scrolling page

                      var _this$element$querySe = _this.element.querySelectorAll(_this.options.selectorItem),
                          _this$element$querySe2 = _slicedToArray$1(_this$element$querySe, 1),
                          firstMenuItem = _this$element$querySe2[0];

                      if (firstMenuItem) {
                        firstMenuItem.focus();
                      }

                      break;
                    }

                  case 38: // up arrow

                  case 40:
                    // down arrow
                    _this.navigate(direction);

                    event.preventDefault(); // prevents keys from scrolling page

                    break;
                }
              }

              break;
            }
        }
      };

      var hasFocusOut = ('onfocusout' in window);

      _this.manage(on(_this.element, hasFocusOut ? 'focusout' : 'blur', _this._handleEvent, !hasFocusOut));

      _this.manage(on(_this.element, 'mouseenter', _this._handleEvent));

      _this.manage(on(_this.element, 'mouseleave', _this._handleEvent));

      _this.manage(on(_this.element, 'click', _this._handleEvent));

      _this.manage(on(_this.element, 'keydown', _this._handleKeyDown));

      return _this;
    }
    /**
     * The map associating DOM element and HeaderSubmenu instance.
     * @member HeaderSubmenu.components
     * @type {WeakMap}
     */


    _createClass$z(HeaderSubmenu, null, [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode HeaderSubmenu.create .create()}, or
       * {@linkcode HeaderSubmenu.init .init()},
       * properties in this object are overriden for the instance being create and
       * how {@linkcode HeaderSubmenu.init .init()} works.
       * @member HeaderSubmenu.options
       * @type {object}
       * @property {string} selectorInit The data attribute to find side navs.
       * @property {string} [selectorTrigger] The CSS selector to find the trigger button.
       * @property {string} [selectorItem] The CSS selector to find the menu items.
       * @property {string} [attribExpanded] The attribute that represents the expanded/collapsed state.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-header-submenu]',
          selectorTrigger: ".".concat(prefix, "--header__menu-title"),
          selectorItem: ".".concat(prefix, "--header__menu .").concat(prefix, "--header__menu-item"),
          attribExpanded: 'aria-expanded'
        };
      }
      /**
       * Enum for navigating backward/forward.
       * @readonly
       * @member HeaderSubmenu.NAVIGATE
       * @type {object}
       * @property {number} BACKWARD Navigating backward.
       * @property {number} FORWARD Navigating forward.
       */

    }]);

    HeaderSubmenu.components = new WeakMap();
    HeaderSubmenu.actions = {
      CLOSE_SUBMENU: 'CLOSE_SUBMENU',
      OPEN_SUBMENU: 'OPEN_SUBMENU',
      TOGGLE_SUBMENU_WITH_FOCUS: 'TOGGLE_SUBMENU_WITH_FOCUS',
      DELEGATE_TO_FLYOUT_MENU: 'DELEGATE_TO_FLYOUT_MENU'
    };
    HeaderSubmenu.NAVIGATE = {
      BACKWARD: -1,
      FORWARD: 1
    };
    return HeaderSubmenu;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$B(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$B = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$B = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$B(obj);
  }

  function _classCallCheck$C(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$A(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$A(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$A(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$A(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$B(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$B(subClass, superClass);
  }

  function _setPrototypeOf$B(o, p) {
    _setPrototypeOf$B = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$B(o, p);
  }

  function _createSuper$B(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$B();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$B(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$B(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$B(this, result);
    };
  }

  function _possibleConstructorReturn$B(self, call) {
    if (call && (_typeof$B(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$B(self);
  }

  function _assertThisInitialized$B(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$B() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$B(o) {
    _getPrototypeOf$B = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$B(o);
  }

  var toArray$a = function toArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
  };

  var HeaderNav = /*#__PURE__*/function (_mixin) {
    _inherits$B(HeaderNav, _mixin);

    var _super = _createSuper$B(HeaderNav);
    /**
     * Header nav.
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as an header nav.
     * @param {object} [options] The component options.
     * @param {string} [options.selectorSubmenu] The CSS selector to find sub menus.
     * @param {string} [options.selectorSubmenuLink] The CSS selector to find the trigger buttons of sub menus.
     * @param {string} [options.selectorSubmenuItem] The CSS selector to find the sub menu items.
     */


    function HeaderNav(element, options) {
      var _this;

      _classCallCheck$C(this, HeaderNav);

      _this = _super.call(this, element, options);

      _this.getCurrentNavigation = function () {
        var focused = _this.element.ownerDocument.activeElement.closest(_this.options.selectorSubmenu);

        return focused && focused.nodeType === Node.ELEMENT_NODE ? focused.querySelector(_this.options.selectorSubmenuLink) : null;
      };

      _this.navigate = function (direction) {
        var items = toArray$a(_this.element.querySelectorAll(_this.options.selectorSubmenuLink));

        var start = _this.getCurrentNavigation();

        var getNextItem = function getNextItem(old) {
          var handleUnderflow = function handleUnderflow(index, length) {
            return index + (index >= 0 ? 0 : length);
          };

          var handleOverflow = function handleOverflow(index, length) {
            return index - (index < length ? 0 : length);
          }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


          var index = Math.max(items.indexOf(old) + direction, -1);
          return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
        };

        getNextItem(start).focus();
      };

      _this._handleKeyDown = function (event) {
        var keyCodes = {
          37: _this.constructor.NAVIGATE.BACKWARD,
          // left arrow
          39: _this.constructor.NAVIGATE.FORWARD // right arrow

        };
        var keyCodeMatches = keyCodes[event.which];

        if (keyCodeMatches) {
          _this.navigate(keyCodeMatches);
        }
      };

      _this.manage(on(_this.element, 'keydown', _this._handleKeyDown));

      return _this;
    }
    /**
     * The map associating DOM element and Header instance.
     * @member HeaderNav.components
     * @type {WeakMap}
     */


    _createClass$A(HeaderNav, null, [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode HeaderNav.create .create()}, or
       * {@linkcode HeaderNav.init .init()},
       * properties in this object are overriden for the instance being create and
       * how {@linkcode HeaderNav.init .init()} works.
       * @member HeaderNav.options
       * @type {object}
       * @property {string} selectorInit The data attribute to find side navs.
       * @property {string} [selectorSubmenu] The CSS selector to find sub menus.
       * @property {string} [selectorSubmenuLink] The CSS selector to find the trigger buttons of sub menus.
       * @property {string} [selectorSubmenuItem] The CSS selector to find the sub menu items.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-header-nav]',
          selectorNavKind: '[data-header-nav-kind]',
          selectorSubmenu: ".".concat(prefix, "--header__submenu"),
          selectorSubmenuLink: ".".concat(prefix, "--header__menu-title"),
          selectorSubmenuItem: ".".concat(prefix, "--header__menu-title > .").concat(prefix, "--header__menu-item")
        };
      }
      /**
       * Enum for navigating backward/forward.
       * @readonly
       * @member Header.NAVIGATE
       * @type {object}
       * @property {number} BACKWARD Navigating backward.
       * @property {number} FORWARD Navigating forward.
       */

    }]);

    HeaderNav.components = new WeakMap();
    HeaderNav.NAVIGATE = {
      BACKWARD: -1,
      FORWARD: 1
    };
    return HeaderNav;
  }(mixin(createComponent, initComponentBySearch, handles));

  function _typeof$C(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$C = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$C = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$C(obj);
  }

  function _classCallCheck$D(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$B(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$B(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$B(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$B(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$C(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$C(subClass, superClass);
  }

  function _setPrototypeOf$C(o, p) {
    _setPrototypeOf$C = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$C(o, p);
  }

  function _createSuper$C(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$C();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$C(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$C(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$C(this, result);
    };
  }

  function _possibleConstructorReturn$C(self, call) {
    if (call && (_typeof$C(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$C(self);
  }

  function _assertThisInitialized$C(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$C() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$C(o) {
    _getPrototypeOf$C = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$C(o);
  }

  var NavigationMenuPanel = /*#__PURE__*/function (_mixin) {
    _inherits$C(NavigationMenuPanel, _mixin);

    var _super = _createSuper$C(NavigationMenuPanel);

    function NavigationMenuPanel() {
      var _this;

      _classCallCheck$D(this, NavigationMenuPanel);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.createdByLauncher = function (event) {
        var isExpanded = !_this.element.hasAttribute('hidden');
        var newState = isExpanded ? 'collapsed' : 'expanded';
        _this.triggerButton = event.delegateTarget;

        _this.changeState(newState);
      };

      _this.shouldStateBeChanged = function (state) {
        return state === 'expanded' === _this.element.hasAttribute('hidden');
      };

      _this._changeState = function (state, callback) {
        toggleAttribute(_this.element, 'hidden', state !== 'expanded');

        if (_this.triggerButton) {
          if (state === 'expanded') {
            var focusableMenuItems = _this.element.querySelector(_this.options.selectorFocusableMenuItem);

            if (focusableMenuItems) {
              focusableMenuItems.focus();
            }
          }

          var label = state === 'expanded' ? _this.triggerButton.getAttribute(_this.options.attribLabelCollapse) : _this.triggerButton.getAttribute(_this.options.attribLabelExpand);

          _this.triggerButton.classList.toggle(_this.options.classNavigationMenuPanelHeaderActionActive, state === 'expanded');

          _this.triggerButton.setAttribute('aria-label', label);

          _this.triggerButton.setAttribute('title', label);
        }

        callback();
      };

      return _this;
    }

    _createClass$B(NavigationMenuPanel, null, [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor,
       * {@linkcode NavigationMenuPanel.create .create()}, or
       * {@linkcode NavigationMenuPanel.init .init()},
       * properties in this object are overriden for the instance being create and
       * how {@linkcode NavigationMenuPanel.init .init()} works.
       * @member NavigationMenuPanel.options
       * @type {object}
       * @property {string} selectorInit The CSS class to find popup navs.
       * @property {string} attribInitTarget The attribute name in the launcher buttons to find target popup nav.
       * @property {string[]} initEventNames The events that the component will handles
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          initEventNames: ['click'],
          eventBeforeExpanded: 'navigation-menu-being-expanded',
          eventAfterExpanded: 'navigation-menu-expanded',
          eventBeforeCollapsed: 'navigation-menu-being-collapsed',
          eventAfterCollapsed: 'navigation-menu-collapsed',
          selectorFocusableMenuItem: ".".concat(prefix, "--navigation__category-toggle, .").concat(prefix, "--navigation-link"),
          classNavigationMenuPanelHeaderActionActive: "".concat(prefix, "--header__action--active"),
          attribLabelExpand: 'data-navigation-menu-panel-label-expand',
          attribLabelCollapse: 'data-navigation-menu-panel-label-collapse'
        };
      }
    }]);

    NavigationMenuPanel.components = new WeakMap();
    return NavigationMenuPanel;
  }(mixin(createComponent, initComponentByLauncher, exports$1, handles, eventedState));

  function _typeof$D(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$D = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$D = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$D(obj);
  }

  function _classCallCheck$E(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$C(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$C(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$C(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$C(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$D(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$D(subClass, superClass);
  }

  function _setPrototypeOf$D(o, p) {
    _setPrototypeOf$D = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$D(o, p);
  }

  function _createSuper$D(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$D();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$D(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$D(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$D(this, result);
    };
  }

  function _possibleConstructorReturn$D(self, call) {
    if (call && (_typeof$D(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$D(self);
  }

  function _assertThisInitialized$D(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _isNativeReflectConstruct$D() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _getPrototypeOf$D(o) {
    _getPrototypeOf$D = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$D(o);
  }

  var PaginationNav = /*#__PURE__*/function (_mixin) {
    _inherits$D(PaginationNav, _mixin);

    var _super = _createSuper$D(PaginationNav);
    /**
     * Pagination Nav component
     * @extends CreateComponent
     * @extends InitComponentBySearch
     * @extends Handles
     * @param {HTMLElement} element The element working as a pagination nav.
     */


    function PaginationNav(element, options) {
      var _this;

      _classCallCheck$E(this, PaginationNav);

      _this = _super.call(this, element, options);

      _this.getActivePageNumber = function () {
        var pageNum;

        var activePageElement = _this.element.querySelector(_this.options.selectorPageActive);

        if (activePageElement) {
          pageNum = Number(activePageElement.getAttribute(_this.options.attribPage));
        }

        return pageNum;
      };

      _this.clearActivePage = function (evt) {
        var pageButtonNodeList = _this.element.querySelectorAll(_this.options.selectorPageButton);

        var pageSelectElement = _this.element.querySelector(_this.options.selectorPageSelect);

        Array.prototype.forEach.call(pageButtonNodeList, function (el) {
          el.classList.remove(_this.options.classActive, _this.options.classDisabled);
          el.removeAttribute(_this.options.attribActive);
          el.removeAttribute('aria-disabled');
          el.removeAttribute('aria-current');
        });

        if (pageSelectElement) {
          pageSelectElement.removeAttribute('aria-current');
          var pageSelectElementOptions = pageSelectElement.options;
          Array.prototype.forEach.call(pageSelectElementOptions, function (el) {
            el.removeAttribute(_this.options.attribActive);
          });

          if (!evt.target.matches(_this.options.selectorPageSelect)) {
            pageSelectElement.classList.remove(_this.options.classActive);
            pageSelectElement.value = '';
          }
        }
      };

      _this.handleClick = function (evt) {
        if (!evt.target.getAttribute('aria-disabled') === true) {
          var nextActivePageNumber = _this.getActivePageNumber();

          var pageElementNodeList = _this.element.querySelectorAll(_this.options.selectorPageElement);

          var pageSelectElement = _this.element.querySelector(_this.options.selectorPageSelect);

          _this.clearActivePage(evt);

          if (evt.target.matches(_this.options.selectorPageButton)) {
            nextActivePageNumber = Number(evt.target.getAttribute(_this.options.attribPage));
          }

          if (evt.target.matches(_this.options.selectorPagePrevious)) {
            nextActivePageNumber -= 1;
          }

          if (evt.target.matches(_this.options.selectorPageNext)) {
            nextActivePageNumber += 1;
          }

          var pageTargetElement = pageElementNodeList[nextActivePageNumber - 1];
          pageTargetElement.setAttribute(_this.options.attribActive, true);

          if (pageTargetElement.tagName === 'OPTION') {
            pageSelectElement.value = _this.getActivePageNumber();
            pageSelectElement.classList.add(_this.options.classActive);
            pageSelectElement.setAttribute('aria-current', 'page');
          } else {
            pageTargetElement.classList.add(_this.options.classActive, _this.options.classDisabled);
            pageTargetElement.setAttribute('aria-disabled', true);
            pageTargetElement.setAttribute('aria-current', 'page');
          }

          _this.setPrevNextStates();
        }
      };

      _this.handleSelectChange = function (evt) {
        _this.clearActivePage(evt);

        var pageSelectElement = _this.element.querySelector(_this.options.selectorPageSelect);

        var pageSelectElementOptions = pageSelectElement.options;
        pageSelectElementOptions[pageSelectElementOptions.selectedIndex].setAttribute(_this.options.attribActive, true);
        evt.target.setAttribute('aria-current', 'page');
        evt.target.classList.add(_this.options.classActive);

        _this.setPrevNextStates();
      };

      _this.setPrevNextStates = function () {
        var pageElementNodeList = _this.element.querySelectorAll(_this.options.selectorPageElement);

        var totalPages = pageElementNodeList.length;

        var pageDirectionElementPrevious = _this.element.querySelector(_this.options.selectorPagePrevious);

        var pageDirectionElementNext = _this.element.querySelector(_this.options.selectorPageNext);

        if (pageDirectionElementPrevious) {
          if (_this.getActivePageNumber() <= 1) {
            pageDirectionElementPrevious.setAttribute('aria-disabled', true);
            pageDirectionElementPrevious.classList.add(_this.options.classDisabled);
          } else {
            pageDirectionElementPrevious.removeAttribute('aria-disabled');
            pageDirectionElementPrevious.classList.remove(_this.options.classDisabled);
          }
        }

        if (pageDirectionElementNext) {
          if (_this.getActivePageNumber() >= totalPages) {
            pageDirectionElementNext.setAttribute('aria-disabled', true);
            pageDirectionElementNext.classList.add(_this.options.classDisabled);
          } else {
            pageDirectionElementNext.removeAttribute('aria-disabled');
            pageDirectionElementNext.classList.remove(_this.options.classDisabled);
          }
        }
      };

      _this.manage(on(_this.element, 'click', function (evt) {
        return _this.handleClick(evt);
      }));

      _this.manage(on(_this.element, 'change', function (evt) {
        if (evt.target.matches(_this.options.selectorPageSelect)) {
          _this.handleSelectChange(evt);
        }
      }));

      return _this;
    }
    /**
     * Get active page number
     */


    _createClass$C(PaginationNav, null, [{
      key: "options",

      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode PaginationNav.create .create()},
       * or {@linkcode PaginationNav.init .init()},
       * properties in this object are overriden for the instance being create and how {@linkcode PaginationNav.init .init()} works.
       * @member PaginationNav.options
       * @type {object}
       * @property {string} selectorInit The data attribute to find pagination nav.
       * @property {string} selectorPageElement The data attribute to find page element.
       * @property {string} selectorPageButton The data attribute to find page interactive element.
       * @property {string} selectorPageDirection The data attribute to find page change element.
       * @property {string} selectorPageSelect The data attribute to find page select element.
       * @property {string} selectorPageActive The data attribute to find active page element.
       * @property {string} [classActive] The CSS class for page's selected state.
       * @property {string} [classDisabled] The CSS class for page's disabled state.
       */
      get: function get() {
        var prefix = settings_1.prefix;
        return {
          selectorInit: '[data-pagination-nav]',
          selectorPageElement: '[data-page]',
          selectorPageButton: '[data-page-button]',
          selectorPagePrevious: '[data-page-previous]',
          selectorPageNext: '[data-page-next]',
          selectorPageSelect: '[data-page-select]',
          selectorPageActive: '[data-page-active="true"]',
          attribPage: 'data-page',
          attribActive: 'data-page-active',
          classActive: "".concat(prefix, "--pagination-nav__page--active"),
          classDisabled: "".concat(prefix, "--pagination-nav__page--disabled")
        };
      }
    }]);

    PaginationNav.components = new WeakMap();
    return PaginationNav;
  }(mixin(createComponent, initComponentBySearch, handles));

  var classnames = createCommonjsModule(function (module) {
    /*!
      Copyright (c) 2017 Jed Watson.
      Licensed under the MIT License (MIT), see
      http://jedwatson.github.io/classnames
    */

    /* global define */
    (function () {

      var hasOwn = {}.hasOwnProperty;

      function classNames() {
        var classes = [];

        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg) continue;

          var argType = _typeof(arg);

          if (argType === 'string' || argType === 'number') {
            classes.push(arg);
          } else if (Array.isArray(arg) && arg.length) {
            var inner = classNames.apply(null, arg);

            if (inner) {
              classes.push(inner);
            }
          } else if (argType === 'object') {
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }

        return classes.join(' ');
      }

      if ( module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else {
        window.classNames = classNames;
      }
    })();
  });

  var prefix$1 = settings_1.prefix;

  function Accordion$1(_ref) {
    var align = _ref.align,
        children = _ref.children,
        customClassName = _ref.className,
        rest = _objectWithoutProperties(_ref, ["align", "children", "className"]);

    var className = classnames("".concat(prefix$1, "--accordion"), customClassName, _defineProperty({}, "".concat(prefix$1, "--accordion--").concat(align), align));
    return /*#__PURE__*/React__default.createElement("ul", _extends({
      className: className
    }, rest), children);
  }

  Accordion$1.defaultProps = {
    align: 'end'
  };
  Accordion$1.propTypes = {
    /**
     * Pass in the children that will be rendered within the Accordion
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify the alignment of the accordion heading title and chevron.
     */
    align: PropTypes.oneOf(['start', 'end'])
  };

  function _defineProperty$5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$2(Object(source), true).forEach(function (key) {
          _defineProperty$5(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$2(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties$1(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$1(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
  /**
   * Copyright IBM Corp. 2018, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */


  var defaultAttributes = {
    // Reference:
    // https://github.com/IBM/carbon-components-react/issues/1392
    // https://github.com/PolymerElements/iron-iconset-svg/pull/47
    // `focusable` is a string attribute which is why we do not use a boolean here
    focusable: 'false',
    preserveAspectRatio: 'xMidYMid meet'
  };
  /**
   * Get supplementary HTML attributes for a given <svg> element based on existing
   * attributes.
   */

  function getAttributes() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$viewBox = _ref.viewBox,
        viewBox = _ref$viewBox === void 0 ? "0 0 ".concat(width, " ").concat(height) : _ref$viewBox,
        attributes = _objectWithoutProperties$1(_ref, ["width", "height", "viewBox"]);

    var tabindex = attributes.tabindex,
        rest = _objectWithoutProperties$1(attributes, ["tabindex"]);

    var iconAttributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, defaultAttributes), rest), {}, {
      width: width,
      height: height,
      viewBox: viewBox
    }); // TODO: attributes.title assumes that the consumer will implement <title> and
    // correctly set `aria-labelledby`.


    if (iconAttributes['aria-label'] || iconAttributes['aria-labelledby'] || iconAttributes.title) {
      iconAttributes.role = 'img'; // Reference:
      // https://allyjs.io/tutorials/focusing-in-svg.html

      if (tabindex !== undefined && tabindex !== null) {
        iconAttributes.focusable = 'true';
        iconAttributes.tabindex = tabindex;
      }
    } else {
      iconAttributes['aria-hidden'] = true;
    }

    return iconAttributes;
  }

  function _defineProperty$6(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  function ownKeys$3(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2$2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$3(Object(source), true).forEach(function (key) {
          _defineProperty$6(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$3(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties$2(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$2(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var Icon = /*#__PURE__*/React__default.forwardRef(function Icon(_ref, ref) {
    var className = _ref.className,
        children = _ref.children,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties$2(_ref, ["className", "children", "tabIndex"]);

    var _getAttributes = getAttributes(_objectSpread2$2(_objectSpread2$2({}, rest), {}, {
      tabindex: tabIndex
    })),
        tabindex = _getAttributes.tabindex,
        props = _objectWithoutProperties$2(_getAttributes, ["tabindex"]);

    if (className) {
      props.className = className;
    }

    if (tabindex !== undefined && tabindex !== null) {
      props.tabIndex = tabindex;
    }

    if (ref) {
      props.ref = ref;
    }

    return /*#__PURE__*/React__default.createElement('svg', props, children);
  });
  Icon.displayName = 'Icon';
  Icon.propTypes = {
    'aria-hidden': PropTypes.string,
    'aria-label': PropTypes.string,
    'aria-labelledby': PropTypes.string,
    className: PropTypes.string,
    children: PropTypes.node,
    height: PropTypes.number,
    preserveAspectRatio: PropTypes.string,
    tabIndex: PropTypes.string,
    viewBox: PropTypes.string,
    width: PropTypes.number,
    xmlns: PropTypes.string
  };
  Icon.defaultProps = {
    xmlns: 'http://www.w3.org/2000/svg',
    preserveAspectRatio: 'xMidYMid meet'
  };

  var _ref2 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M16,2C8.4,2,2,8.4,2,16s6.4,14,14,14s14-6.4,14-14S23.6,2,16,2z M24,17h-7v7h-2v-7H8v-2h7V8h2v7h7V17z"
  });

  var _ref3 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    fill: "none",
    d: "M24 17L17 17 17 24 15 24 15 17 8 17 8 15 15 15 15 8 17 8 17 15 24 15z",
    "data-icon-path": "inner-path"
  });

  var AddFilled16 = /*#__PURE__*/React__default.forwardRef(function AddFilled16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2, _ref3, children);
  });

  var _ref2$1 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M16 4L6 14 7.41 15.41 15 7.83 15 30 17 30 17 7.83 24.59 15.41 26 14 16 4z"
  });

  var ArrowUp20 = /*#__PURE__*/React__default.forwardRef(function ArrowUp20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$1, children);
  });

  var _ref2$2 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M27.6 20.6L24 24.2 24 4 22 4 22 24.2 18.4 20.6 17 22 23 28 29 22zM9 4L3 10 4.4 11.4 8 7.8 8 28 10 28 10 7.8 13.6 11.4 15 10z"
  });

  var ArrowsVertical20 = /*#__PURE__*/React__default.forwardRef(function ArrowsVertical20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$2, children);
  });

  var _ref2$3 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M26,4h-4V2h-2v2h-8V2h-2v2H6C4.9,4,4,4.9,4,6v20c0,1.1,0.9,2,2,2h20c1.1,0,2-0.9,2-2V6C28,4.9,27.1,4,26,4z M26,26H6V12h20\tV26z M26,10H6V6h4v2h2V6h8v2h2V6h4V10z"
  });

  var Calendar16 = /*#__PURE__*/React__default.forwardRef(function Calendar16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$3, children);
  });

  var _ref2$4 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8 0L4 4 0 0z"
  });

  var CaretDownGlyph = /*#__PURE__*/React__default.forwardRef(function CaretDownGlyph(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 8,
      height: 4,
      viewBox: "0 0 8 4",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$4, children);
  });

  var _ref2$5 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M20 24L10 16 20 8z"
  });

  var CaretLeft16 = /*#__PURE__*/React__default.forwardRef(function CaretLeft16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$5, children);
  });

  var _ref2$6 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M12 8L22 16 12 24z"
  });

  var CaretRight16 = /*#__PURE__*/React__default.forwardRef(function CaretRight16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$6, children);
  });

  var _ref2$7 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M0 4L4 0 8 4z"
  });

  var CaretUpGlyph = /*#__PURE__*/React__default.forwardRef(function CaretUpGlyph(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 8,
      height: 4,
      viewBox: "0 0 8 4",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$7, children);
  });

  var _ref2$8 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z"
  });

  var Checkmark16 = /*#__PURE__*/React__default.forwardRef(function Checkmark16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$8, children);
  });

  var _ref2$9 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z"
  });

  var _ref3$1 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    fill: "none",
    d: "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z",
    "data-icon-path": "inner-path",
    opacity: "0"
  });

  var CheckmarkFilled20 = /*#__PURE__*/React__default.forwardRef(function CheckmarkFilled20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$9, _ref3$1, children);
  });

  var _ref2$a =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8,1C4.1,1,1,4.1,1,8c0,3.9,3.1,7,7,7s7-3.1,7-7C15,4.1,11.9,1,8,1z M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z"
  });

  var _ref3$2 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z",
    "data-icon-path": "inner-path",
    opacity: "0"
  });

  var CheckmarkFilled16 = /*#__PURE__*/React__default.forwardRef(function CheckmarkFilled16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$a, _ref3$2, children);
  });

  var _ref2$b =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z"
  });

  var _ref3$3 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"
  });

  var CheckmarkOutline16 = /*#__PURE__*/React__default.forwardRef(function CheckmarkOutline16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$b, _ref3$3, children);
  });

  var _ref2$c =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M16 22L6 12 7.4 10.6 16 19.2 24.6 10.6 26 12z"
  });

  var ChevronDown20 = /*#__PURE__*/React__default.forwardRef(function ChevronDown20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$c, children);
  });

  var _ref2$d =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"
  });

  var ChevronDown16 = /*#__PURE__*/React__default.forwardRef(function ChevronDown16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$d, children);
  });

  var _ref2$e =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M22 16L12 26 10.6 24.6 19.2 16 10.6 7.4 12 6z"
  });

  var ChevronRight20 = /*#__PURE__*/React__default.forwardRef(function ChevronRight20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$e, children);
  });

  var _ref2$f =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"
  });

  var ChevronRight16 = /*#__PURE__*/React__default.forwardRef(function ChevronRight16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$f, children);
  });

  var _ref2$g =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("circle", {
    cx: "16",
    cy: "16",
    r: "10"
  });

  var _ref3$4 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"
  });

  var CircleFilled16 = /*#__PURE__*/React__default.forwardRef(function CircleFilled16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$g, _ref3$4, children);
  });

  var _ref2$h =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"
  });

  var Close20 = /*#__PURE__*/React__default.forwardRef(function Close20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$h, children);
  });

  var _ref2$i =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"
  });

  var Close16 = /*#__PURE__*/React__default.forwardRef(function Close16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$i, children);
  });

  var _ref2$j =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"
  });

  var _ref3$5 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"
  });

  var Copy16 = /*#__PURE__*/React__default.forwardRef(function Copy16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$j, _ref3$5, children);
  });

  var _ref2$k =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z"
  });

  var _ref3$6 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z",
    "data-icon-path": "inner-path",
    opacity: "0"
  });

  var ErrorFilled20 = /*#__PURE__*/React__default.forwardRef(function ErrorFilled20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$k, _ref3$6, children);
  });

  var _ref2$l =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M10.7,11.5L4.5,5.3l0.8-0.8l6.2,6.2L10.7,11.5z"
  });

  var _ref3$7 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    fill: "none",
    d: "M10.7,11.5L4.5,5.3l0.8-0.8l6.2,6.2L10.7,11.5z",
    "data-icon-path": "inner-path",
    opacity: "0"
  });

  var ErrorFilled16 = /*#__PURE__*/React__default.forwardRef(function ErrorFilled16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$l, _ref3$7, children);
  });

  var _ref2$m =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M18,28H14a2,2,0,0,1-2-2V18.41L4.59,11A2,2,0,0,1,4,9.59V6A2,2,0,0,1,6,4H26a2,2,0,0,1,2,2V9.59A2,2,0,0,1,27.41,11L20,18.41V26A2,2,0,0,1,18,28ZM6,6V9.59l8,8V26h4V17.59l8-8V6Z"
  });

  var Filter16 = /*#__PURE__*/React__default.forwardRef(function Filter16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$m, children);
  });

  var _ref2$n =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M12 4H6A2 2 0 004 6v6a2 2 0 002 2h6a2 2 0 002-2V6A2 2 0 0012 4zm0 8H6V6h6zM26 4H20a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V6A2 2 0 0026 4zm0 8H20V6h6zM12 18H6a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V20A2 2 0 0012 18zm0 8H6V20h6zM26 18H20a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V20A2 2 0 0026 18zm0 8H20V20h6z"
  });

  var Grid16 = /*#__PURE__*/React__default.forwardRef(function Grid16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$n, children);
  });

  var _ref2$o =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8.5 11L8.5 6.5 6.5 6.5 6.5 7.5 7.5 7.5 7.5 11 6 11 6 12 10 12 10 11zM8 3.5c-.4 0-.8.3-.8.8S7.6 5 8 5c.4 0 .8-.3.8-.8S8.4 3.5 8 3.5z"
  });

  var _ref3$8 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8,15c-3.9,0-7-3.1-7-7s3.1-7,7-7s7,3.1,7,7S11.9,15,8,15z M8,2C4.7,2,2,4.7,2,8s2.7,6,6,6s6-2.7,6-6S11.3,2,8,2z"
  });

  var Information16 = /*#__PURE__*/React__default.forwardRef(function Information16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$o, _ref3$8, children);
  });

  var _ref2$p =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17.125h-8v-2.25h2.875v-6.75h-1.875v-2.25h4.125v9h2.875Z"
  });

  var _ref3$9 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    fill: "none",
    d: "M16,7a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17.125h-8v-2.25h2.875v-6.75h-1.875v-2.25h4.125v9h2.875Z",
    "data-icon-path": "inner-path"
  });

  var InformationFilled20 = /*#__PURE__*/React__default.forwardRef(function InformationFilled20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$p, _ref3$9, children);
  });

  var _ref2$q =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM16,7a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17H12V22h3V15H13V13h4v9h3Z"
  });

  var _ref3$a =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    fill: "none",
    d: "M20,22v2H12V22h3V15H13V13h4v9ZM16,7a1.5,1.5,0,1,0,1.5,1.5A1.5,1.5,0,0,0,16,7Z",
    "data-icon-path": "inner-path"
  });

  var InformationSquareFilled20 = /*#__PURE__*/React__default.forwardRef(function InformationSquareFilled20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$q, _ref3$a, children);
  });

  var _ref2$r =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("circle", {
    cx: "3.5",
    cy: "4.5",
    r: "1.5"
  });

  var _ref3$b =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("circle", {
    cx: "3.5",
    cy: "11.5",
    r: "1.5"
  });

  var _ref4 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8 11H15V12H8zM8 4H15V5H8z"
  });

  var ListBulleted16 = /*#__PURE__*/React__default.forwardRef(function ListBulleted16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$r, _ref3$b, _ref4, children);
  });

  var _ref2$s =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M2 14.8H18V16H2zM2 11.2H18V12.399999999999999H2zM2 7.6H18V8.799999999999999H2zM2 4H18V5.2H2z"
  });

  var Menu20 = /*#__PURE__*/React__default.forwardRef(function Menu20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$s, children);
  });

  var _ref2$t =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("circle", {
    cx: "16",
    cy: "8",
    r: "2"
  });

  var _ref3$c =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("circle", {
    cx: "16",
    cy: "16",
    r: "2"
  });

  var _ref4$1 =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("circle", {
    cx: "16",
    cy: "24",
    r: "2"
  });

  var OverflowMenuVertical16 = /*#__PURE__*/React__default.forwardRef(function OverflowMenuVertical16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$t, _ref3$c, _ref4$1, children);
  });

  var _ref2$u =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"
  });

  var RadioButton16 = /*#__PURE__*/React__default.forwardRef(function RadioButton16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$u, children);
  });

  var _ref2$v =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M15,14.3L10.7,10c1.9-2.3,1.6-5.8-0.7-7.7S4.2,0.7,2.3,3S0.7,8.8,3,10.7c2,1.7,5,1.7,7,0l4.3,4.3L15,14.3z M2,6.5\tC2,4,4,2,6.5,2S11,4,11,6.5S9,11,6.5,11S2,9,2,6.5z"
  });

  var Search16 = /*#__PURE__*/React__default.forwardRef(function Search16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$v, children);
  });

  var _ref2$w =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M13.5,8.4c0-0.1,0-0.3,0-0.4c0-0.1,0-0.3,0-0.4l1-0.8c0.4-0.3,0.4-0.9,0.2-1.3l-1.2-2C13.3,3.2,13,3,12.6,3\tc-0.1,0-0.2,0-0.3,0.1l-1.2,0.4c-0.2-0.1-0.4-0.3-0.7-0.4l-0.3-1.3C10.1,1.3,9.7,1,9.2,1H6.8c-0.5,0-0.9,0.3-1,0.8L5.6,3.1\tC5.3,3.2,5.1,3.3,4.9,3.4L3.7,3C3.6,3,3.5,3,3.4,3C3,3,2.7,3.2,2.5,3.5l-1.2,2C1.1,5.9,1.2,6.4,1.6,6.8l0.9,0.9c0,0.1,0,0.3,0,0.4\tc0,0.1,0,0.3,0,0.4L1.6,9.2c-0.4,0.3-0.5,0.9-0.2,1.3l1.2,2C2.7,12.8,3,13,3.4,13c0.1,0,0.2,0,0.3-0.1l1.2-0.4\tc0.2,0.1,0.4,0.3,0.7,0.4l0.3,1.3c0.1,0.5,0.5,0.8,1,0.8h2.4c0.5,0,0.9-0.3,1-0.8l0.3-1.3c0.2-0.1,0.4-0.2,0.7-0.4l1.2,0.4\tc0.1,0,0.2,0.1,0.3,0.1c0.4,0,0.7-0.2,0.9-0.5l1.1-2c0.2-0.4,0.2-0.9-0.2-1.3L13.5,8.4z M12.6,12l-1.7-0.6c-0.4,0.3-0.9,0.6-1.4,0.8\tL9.2,14H6.8l-0.4-1.8c-0.5-0.2-0.9-0.5-1.4-0.8L3.4,12l-1.2-2l1.4-1.2c-0.1-0.5-0.1-1.1,0-1.6L2.2,6l1.2-2l1.7,0.6\tC5.5,4.2,6,4,6.5,3.8L6.8,2h2.4l0.4,1.8c0.5,0.2,0.9,0.5,1.4,0.8L12.6,4l1.2,2l-1.4,1.2c0.1,0.5,0.1,1.1,0,1.6l1.4,1.2L12.6,12z"
  });

  var _ref3$d =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8,11c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3C11,9.6,9.7,11,8,11C8,11,8,11,8,11z M8,6C6.9,6,6,6.8,6,7.9C6,7.9,6,8,6,8\tc0,1.1,0.8,2,1.9,2c0,0,0.1,0,0.1,0c1.1,0,2-0.8,2-1.9c0,0,0-0.1,0-0.1C10,6.9,9.2,6,8,6C8.1,6,8,6,8,6z"
  });

  var Settings16 = /*#__PURE__*/React__default.forwardRef(function Settings16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$w, _ref3$d, children);
  });

  var _ref2$x =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M15.5,7.8C14.3,4.7,11.3,2.6,8,2.5C4.7,2.6,1.7,4.7,0.5,7.8c0,0.1,0,0.2,0,0.3c1.2,3.1,4.1,5.2,7.5,5.3\tc3.3-0.1,6.3-2.2,7.5-5.3C15.5,8.1,15.5,7.9,15.5,7.8z M8,12.5c-2.7,0-5.4-2-6.5-4.5c1-2.5,3.8-4.5,6.5-4.5s5.4,2,6.5,4.5\tC13.4,10.5,10.6,12.5,8,12.5z"
  });

  var _ref3$e =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8,5C6.3,5,5,6.3,5,8s1.3,3,3,3s3-1.3,3-3S9.7,5,8,5z M8,10c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S9.1,10,8,10z"
  });

  var View16 = /*#__PURE__*/React__default.forwardRef(function View16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$x, _ref3$e, children);
  });

  var _ref2$y =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M2.6,11.3l0.7-0.7C2.6,9.8,1.9,9,1.5,8c1-2.5,3.8-4.5,6.5-4.5c0.7,0,1.4,0.1,2,0.4l0.8-0.8C9.9,2.7,9,2.5,8,2.5\tC4.7,2.6,1.7,4.7,0.5,7.8c0,0.1,0,0.2,0,0.3C1,9.3,1.7,10.4,2.6,11.3z"
  });

  var _ref3$f =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M6 7.9c.1-1 .9-1.8 1.8-1.8l.9-.9C7.2 4.7 5.5 5.6 5.1 7.2 5 7.7 5 8.3 5.1 8.8L6 7.9zM15.5 7.8c-.6-1.5-1.6-2.8-2.9-3.7L15 1.7 14.3 1 1 14.3 1.7 15l2.6-2.6c1.1.7 2.4 1 3.7 1.1 3.3-.1 6.3-2.2 7.5-5.3C15.5 8.1 15.5 7.9 15.5 7.8zM10 8c0 1.1-.9 2-2 2-.3 0-.7-.1-1-.3L9.7 7C9.9 7.3 10 7.6 10 8zM8 12.5c-1 0-2.1-.3-3-.8l1.3-1.3c1.4.9 3.2.6 4.2-.8.7-1 .7-2.4 0-3.4l1.4-1.4c1.1.8 2 1.9 2.6 3.2C13.4 10.5 10.6 12.5 8 12.5z"
  });

  var ViewOff16 = /*#__PURE__*/React__default.forwardRef(function ViewOff16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$y, _ref3$f, children);
  });

  var _ref2$z =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S11.3,14,8,14z"
  });

  var _ref3$g =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M7.5 4H8.5V9H7.5zM8 10.2c-.4 0-.8.3-.8.8s.3.8.8.8c.4 0 .8-.3.8-.8S8.4 10.2 8 10.2z"
  });

  var Warning16 = /*#__PURE__*/React__default.forwardRef(function Warning16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$z, _ref3$g, children);
  });

  var _ref2$A =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M29.879,27.5212l-13-25.0363a1.04,1.04,0,0,0-1.7583,0l-13,25.0363A1.0015,1.0015,0,0,0,3,29H29a1.001,1.001,0,0,0,.8789-1.4788ZM14.8751,10.0086h2.25V20h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z"
  });

  var _ref3$h =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    fill: "none",
    d: "M14.8751,10.0086h2.25V20h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z",
    "data-icon-path": "inner-path"
  });

  var WarningAltFilled20 = /*#__PURE__*/React__default.forwardRef(function WarningAltFilled20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$A, _ref3$h, children);
  });

  var _ref2$B =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1\ts1,0.4,1,1S10.6,16,10,16z"
  });

  var _ref3$i =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z",
    "data-icon-path": "inner-path",
    opacity: "0"
  });

  var WarningFilled20 = /*#__PURE__*/React__default.forwardRef(function WarningFilled20(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 20,
      height: 20,
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$B, _ref3$i, children);
  });

  var _ref2$C =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M8,1C4.2,1,1,4.2,1,8s3.2,7,7,7s7-3.1,7-7S11.9,1,8,1z M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2\tc-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8c0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z"
  });

  var _ref3$j =
  /*#__PURE__*/

  /*#__PURE__*/
  React__default.createElement("path", {
    d: "M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2c-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8\tc0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z",
    "data-icon-path": "inner-path",
    opacity: "0"
  });

  var WarningFilled16 = /*#__PURE__*/React__default.forwardRef(function WarningFilled16(_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(Icon, _extends$1({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _ref2$C, _ref3$j, children);
  });

  var Enter = {
    key: 'Enter',
    which: 13,
    keyCode: 13
  };
  var Escape = {
    key: ['Escape', // IE11 Escape
    'Esc'],
    which: 27,
    keyCode: 27
  };
  var Space = {
    key: ' ',
    which: 32,
    keyCode: 32
  };
  var ArrowLeft = {
    key: 'ArrowLeft',
    which: 37,
    keyCode: 37
  };
  var ArrowUp = {
    key: 'ArrowUp',
    which: 38,
    keyCode: 38
  };
  var ArrowRight = {
    key: 'ArrowRight',
    which: 39,
    keyCode: 39
  };
  var ArrowDown = {
    key: 'ArrowDown',
    which: 40,
    keyCode: 40
  };

  /**
   * @typedef Key
   * @property key {Array<string>|string}
   * @property which {number}
   * @property keyCode {number}
   */

  /**
   * Check to see if at least one key code matches the key code of the
   * given event.
   *
   * @example
   * import * as keys from '../keys';
   * import { matches } from '../match';
   *
   * function handleOnKeyDown(event) {
   *   if (matches(event, [keys.Enter, keys.Space]) {
   *     // ...
   *   }
   * }
   *
   * @param {Event} event
   * @param {Array<Key>} keysToMatch
   * @returns {boolean}
   */
  function matches(event, keysToMatch) {
    for (var i = 0; i < keysToMatch.length; i++) {
      if (match(event, keysToMatch[i])) {
        return true;
      }
    }

    return false;
  }
  /**
   * Check to see if the given key matches the corresponding keyboard event. Also
   * supports passing in the value directly if you can't used the given event.
   *
   * @example
   * import * as keys from '../keys';
   * import { matches } from '../match';
   *
   * function handleOnKeyDown(event) {
   *   if (match(event, keys.Enter) {
   *     // ...
   *   }
   * }
   *
   * @param {Event|number|string} eventOrCode
   * @param {Key} key
   * @returns {boolean}
   */

  function match(eventOrCode) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        key = _ref.key,
        which = _ref.which,
        keyCode = _ref.keyCode;

    if (typeof eventOrCode === 'string') {
      return eventOrCode === key;
    }

    if (typeof eventOrCode === 'number') {
      return eventOrCode === which || eventOrCode === keyCode;
    }

    if (eventOrCode.key && Array.isArray(key)) {
      return key.indexOf(eventOrCode.key) !== -1;
    }

    return eventOrCode.key === key || eventOrCode.which === which || eventOrCode.keyCode === keyCode;
  }

  /**
   * Various utilities to help with a11y work
   */

  /**
   * A "ring buffer" function that takes an array and depending on an ArrowRight
   * or ArrowLeft key input loops from last index to first or first index to last.
   *
   * @param {string} key - the left or right arrow keys
   * @param {number} index - the current index in a given array
   * @param {number} arrayLength - the total length of the array
   *
   * @example
   * 	getNextIndex(keyCodes.RIGHT, 0, 4)
   */

  var getNextIndex = function getNextIndex(key, index, arrayLength) {
    if (match(key, ArrowRight)) {
      return (index + 1) % arrayLength;
    }

    if (match(key, ArrowLeft)) {
      return (index + arrayLength - 1) % arrayLength;
    }
  };
  /**
   * A flag `node.compareDocumentPosition(target)` returns,
   * that indicates `target` is located earlier than `node` in the document or `target` contains `node`.
   */

  var DOCUMENT_POSITION_BROAD_PRECEDING = // Checks `typeof Node` for `react-docgen`
  typeof Node !== 'undefined' && Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS;
  /**
   * A flag `node.compareDocumentPosition(target)` returns,
   * that indicates `target` is located later than `node` in the document or `node` contains `target`.
   */

  var DOCUMENT_POSITION_BROAD_FOLLOWING = // Checks `typeof Node` for `react-docgen`
  typeof Node !== 'undefined' && Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY;
  /**
   * CSS selector that selects major nodes that are sequential-focusable.
   */

  var selectorTabbable = "\n  a[href], area[href], input:not([disabled]):not([tabindex='-1']),\n  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),\n  textarea:not([disabled]):not([tabindex='-1']),\n  iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]\n";
  /**
   * CSS selector that selects major nodes that are click focusable
   */

  var selectorFocusable = "\n  a[href], area[href], input:not([disabled]),\n  button:not([disabled]),select:not([disabled]),\n  textarea:not([disabled]),\n  iframe, object, embed, *[tabindex], *[contenteditable=true]\n";

  /**
   * Generic utility to initialize a method that will return a unique instance id
   * for a component.
   */
  function setupGetInstanceId() {
    var instanceId = 0;
    return function getInstanceId() {
      return ++instanceId;
    };
  }

  var getId = setupGetInstanceId();
  var useIsomorphicLayoutEffect = canUseDOM() ? React.useLayoutEffect : React.useEffect;

  function canUseDOM() {
    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  }

  var serverHandoffCompleted = false;
  /**
   * Generate a unique ID with an optional prefix prepended to it
   * @param {string} [prefix]
   * @returns {string}
   */

  function useId() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';

    var _useState = React.useState(function () {
      if (serverHandoffCompleted) {
        return "".concat(prefix, "-").concat(getId());
      }

      return null;
    }),
        _useState2 = _slicedToArray(_useState, 2),
        id = _useState2[0],
        setId = _useState2[1];

    useIsomorphicLayoutEffect(function () {
      if (id === null) {
        setId("".concat(prefix, "-").concat(getId()));
      }
    }, [getId]);
    React.useEffect(function () {
      if (serverHandoffCompleted === false) {
        serverHandoffCompleted = true;
      }
    }, []);
    return id;
  }

  var didWarnAboutDeprecation = {};
  function deprecate(propType, message) {
    function checker(props, propName, componentName) {
      if (props[propName] === undefined) {
        return;
      }

      if (!didWarnAboutDeprecation[componentName] || !didWarnAboutDeprecation[componentName][propName]) {
        didWarnAboutDeprecation[componentName] = _objectSpread2(_objectSpread2({}, didWarnAboutDeprecation[componentName]), {}, _defineProperty({}, propName, true));
         warning_1(false, message || "The prop `".concat(propName, "` has been deprecated for the ") + "".concat(componentName, " component. It will be removed in the next major ") + "release") ;
      }

      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(void 0, [props, propName, componentName].concat(rest));
    }

    return checker;
  }

  var prefix$2 = settings_1.prefix;

  var defaultRenderExpando = function defaultRenderExpando(props) {
    return /*#__PURE__*/React__default.createElement("button", props);
  };

  function AccordionItem(_ref) {
    var _cx;

    var children = _ref.children,
        customClassName = _ref.className,
        iconDescription = _ref.iconDescription,
        _ref$open = _ref.open,
        open = _ref$open === void 0 ? false : _ref$open,
        onHeadingClick = _ref.onHeadingClick,
        _ref$renderExpando = _ref.renderExpando,
        Expando = _ref$renderExpando === void 0 ? defaultRenderExpando : _ref$renderExpando,
        _ref$title = _ref.title,
        title = _ref$title === void 0 ? 'title' : _ref$title,
        rest = _objectWithoutProperties(_ref, ["children", "className", "iconDescription", "open", "onHeadingClick", "renderExpando", "title"]);

    var _useState = React.useState(open),
        _useState2 = _slicedToArray(_useState, 2),
        isOpen = _useState2[0],
        setIsOpen = _useState2[1];

    var _useState3 = React.useState(open),
        _useState4 = _slicedToArray(_useState3, 2),
        prevIsOpen = _useState4[0],
        setPrevIsOpen = _useState4[1];

    var _useState5 = React.useState(''),
        _useState6 = _slicedToArray(_useState5, 2),
        animation = _useState6[0],
        setAnimation = _useState6[1];

    var id = useId('accordion-item');
    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$2, "--accordion__item"), true), _defineProperty(_cx, "".concat(prefix$2, "--accordion__item--active"), isOpen), _defineProperty(_cx, "".concat(prefix$2, "--accordion__item--").concat(animation), animation), _defineProperty(_cx, customClassName, !!customClassName), _cx));

    if (open !== prevIsOpen) {
      setIsOpen(open);
      setPrevIsOpen(open);
    } // When the AccordionItem heading is clicked, toggle the open state of the
    // panel


    function onClick(event) {
      var nextValue = !isOpen;
      setAnimation(isOpen ? 'collapsing' : 'expanding');
      setIsOpen(nextValue);

      if (onHeadingClick) {
        // TODO: normalize signature, potentially:
        // onHeadingClick :: (event: Event, state: { isOpen: Boolean }) => any
        onHeadingClick({
          isOpen: nextValue,
          event: event
        });
      }
    } // If the AccordionItem is open, and the user hits the ESC key, then close it


    function onKeyDown(event) {
      if (isOpen && match(event, Escape)) {
        setIsOpen(false);
      }
    }

    function handleAnimationEnd(event) {
      if (rest.handleAnimationEnd) {
        rest.handleAnimationEnd(event);
      }

      setAnimation('');
    }

    return /*#__PURE__*/React__default.createElement("li", _extends({
      className: className
    }, rest, {
      onAnimationEnd: handleAnimationEnd
    }), /*#__PURE__*/React__default.createElement(Expando, {
      "aria-controls": id,
      "aria-expanded": isOpen,
      className: "".concat(prefix$2, "--accordion__heading"),
      onClick: onClick,
      onKeyDown: onKeyDown,
      type: "button"
    }, /*#__PURE__*/React__default.createElement(ChevronRight16, {
      className: "".concat(prefix$2, "--accordion__arrow")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$2, "--accordion__title")
    }, title)), /*#__PURE__*/React__default.createElement("div", {
      id: id,
      className: "".concat(prefix$2, "--accordion__content")
    }, children));
  }

  AccordionItem.propTypes = {
    /**
     * Provide the contents of your AccordionItem
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * The accordion title.
     */
    title: PropTypes.node,

    /**
     * The callback function to render the expando button.
     * Can be a React component class.
     */
    renderExpando: PropTypes.func,

    /**
     * The description of the expando icon.
     */
    iconDescription: deprecate(PropTypes.string, 'The `iconDescription` prop has been deprecated as it is no longer ' + 'required. Feel free to remove this prop from <AccordionItem>. This ' + 'prop will be removed in the next major release of ' + '`carbon-components-react`'),

    /**
     * `true` to open the expando.
     */
    open: PropTypes.bool,

    /**
     * The handler of the massaged `click` event.
     */
    onClick: PropTypes.func,

    /**
     * The handler of the massaged `click` event on the heading.
     */
    onHeadingClick: PropTypes.func
  };

  var prefix$3 = settings_1.prefix;
  var randoms = [0.973051493507435, 0.15334737213558558, 0.5671034553053769];

  function getRandomInt(min, max, n) {
    return Math.floor(randoms[n % 3] * (max - min + 1)) + min;
  }

  var SkeletonText = function SkeletonText(_ref) {
    var _classNames;

    var paragraph = _ref.paragraph,
        lineCount = _ref.lineCount,
        width = _ref.width,
        heading = _ref.heading,
        className = _ref.className,
        other = _objectWithoutProperties(_ref, ["paragraph", "lineCount", "width", "heading", "className"]);

    var skeletonTextClasses = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$3, "--skeleton__text"), true), _defineProperty(_classNames, "".concat(prefix$3, "--skeleton__heading"), heading), _defineProperty(_classNames, className, className), _classNames));
    var widthNum = parseInt(width, 10);
    var widthPx = width.includes('px');
    var widthPercent = width.includes('%');

    if (widthPercent && paragraph) {
      var lines = [];

      for (var i = 0; i < lineCount; i++) {
        var randomWidth = getRandomInt(0, 75, i) + 'px';
        lines.push( /*#__PURE__*/React__default.createElement("p", _extends({
          className: skeletonTextClasses,
          style: {
            width: "calc(".concat(width, " - ").concat(randomWidth, ")")
          },
          key: i
        }, other)));
      }

      return /*#__PURE__*/React__default.createElement("div", null, lines);
    }

    if (widthPx && paragraph) {
      var _lines = [];

      for (var j = 0; j < lineCount; j++) {
        var _randomWidth = getRandomInt(widthNum - 75, widthNum, j) + 'px';

        _lines.push( /*#__PURE__*/React__default.createElement("p", _extends({
          className: skeletonTextClasses,
          style: {
            width: _randomWidth
          },
          key: j
        }, other)));
      }

      return /*#__PURE__*/React__default.createElement("div", null, _lines);
    }

    return /*#__PURE__*/React__default.createElement("p", _extends({
      className: skeletonTextClasses,
      style: {
        width: width
      }
    }, other));
  };

  SkeletonText.propTypes = {
    /**
     * will generate multiple lines of text
     */
    paragraph: PropTypes.bool,

    /**
     * the number of lines in a paragraph
     */
    lineCount: PropTypes.number,

    /**
     * width (in px or %) of single line of text or max-width of paragraph lines
     */
    width: PropTypes.string,

    /**
     * generates skeleton text at a larger size
     */
    heading: PropTypes.bool,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string
  };
  SkeletonText.defaultProps = {
    paragraph: false,
    width: '100%',
    heading: false,
    lineCount: 3
  };

  var prefix$4 = settings_1.prefix;

  function AccordionSkeleton(_ref) {
    var align = _ref.align,
        open = _ref.open,
        count = _ref.count,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["align", "open", "count", "className"]);

    var classes = classnames("".concat(prefix$4, "--accordion"), "".concat(prefix$4, "--skeleton"), className, _defineProperty({}, "".concat(prefix$4, "--accordion--").concat(align), align));
    var numSkeletonItems = open ? count - 1 : count;
    return /*#__PURE__*/React__default.createElement("ul", _extends({
      className: classes
    }, rest), open && /*#__PURE__*/React__default.createElement("li", {
      className: "".concat(prefix$4, "--accordion__item ").concat(prefix$4, "--accordion__item--active")
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$4, "--accordion__heading")
    }, /*#__PURE__*/React__default.createElement(ChevronRight16, {
      className: "".concat(prefix$4, "--accordion__arrow")
    }), /*#__PURE__*/React__default.createElement(SkeletonText, {
      className: "".concat(prefix$4, "--accordion__title")
    })), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$4, "--accordion__content")
    }, /*#__PURE__*/React__default.createElement(SkeletonText, {
      width: "90%"
    }), /*#__PURE__*/React__default.createElement(SkeletonText, {
      width: "80%"
    }), /*#__PURE__*/React__default.createElement(SkeletonText, {
      width: "95%"
    }))), Array.from({
      length: numSkeletonItems
    }).map(function (_, i) {
      return /*#__PURE__*/React__default.createElement(AccordionSkeletonItem, {
        key: i
      });
    }));
  }

  AccordionSkeleton.propTypes = {
    /**
     * `false` to not display the first item opened
     */
    open: PropTypes.bool,

    /**
     * Set number of items to render
     */
    count: PropTypes.number,

    /**
     * Set unique identifier to generate unique item keys
     */
    uid: deprecate(PropTypes.any),

    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string,

    /**
     * Specify the alignment of the accordion heading title and chevron.
     */
    align: PropTypes.oneOf(['start', 'end'])
  };
  AccordionSkeleton.defaultProps = {
    open: true,
    count: 4,
    align: 'end'
  };

  function AccordionSkeletonItem() {
    return /*#__PURE__*/React__default.createElement("li", {
      className: "".concat(prefix$4, "--accordion__item")
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$4, "--accordion__heading")
    }, /*#__PURE__*/React__default.createElement(ChevronRight16, {
      className: "".concat(prefix$4, "--accordion__arrow")
    }), /*#__PURE__*/React__default.createElement(SkeletonText, {
      className: "".concat(prefix$4, "--accordion__title")
    })));
  }

  // Alias for import paths for build tools that rely on this

  var prefix$5 = settings_1.prefix;

  var Breadcrumb = function Breadcrumb(_ref) {
    var _cx;

    var ariaLabel = _ref['aria-label'],
        children = _ref.children,
        customClassNameNav = _ref.className,
        noTrailingSlash = _ref.noTrailingSlash,
        rest = _objectWithoutProperties(_ref, ["aria-label", "children", "className", "noTrailingSlash"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$5, "--breadcrumb"), true), _defineProperty(_cx, "".concat(prefix$5, "--breadcrumb--no-trailing-slash"), noTrailingSlash), _cx));
    return /*#__PURE__*/React__default.createElement("nav", _extends({
      className: customClassNameNav,
      "aria-label": ariaLabel ? ariaLabel : 'Breadcrumb'
    }, rest), /*#__PURE__*/React__default.createElement("ol", {
      className: className
    }, children));
  };

  Breadcrumb.propTypes = {
    /**
     * Specify the label for the breadcrumb container
     */
    'aria-label': PropTypes.string,

    /**
     * Pass in the BreadcrumbItem's for your Breadcrumb
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Optional prop to omit the trailing slash for the breadcrumbs
     */
    noTrailingSlash: PropTypes.bool
  };

  var prefix$6 = settings_1.prefix;

  var Link = function Link(_ref) {
    var _classnames;

    var children = _ref.children,
        className = _ref.className,
        href = _ref.href,
        disabled = _ref.disabled,
        inline = _ref.inline,
        visited = _ref.visited,
        other = _objectWithoutProperties(_ref, ["children", "className", "href", "disabled", "inline", "visited"]);

    var classNames = classnames("".concat(prefix$6, "--link"), className, (_classnames = {}, _defineProperty(_classnames, "".concat(prefix$6, "--link--disabled"), disabled), _defineProperty(_classnames, "".concat(prefix$6, "--link--inline"), inline), _defineProperty(_classnames, "".concat(prefix$6, "--link--visited"), visited), _classnames));
    var Tag = disabled ? 'p' : 'a';
    return /*#__PURE__*/React__default.createElement(Tag, _extends({
      href: disabled ? null : href,
      className: classNames
    }, other), children);
  };

  Link.propTypes = {
    /**
     * Provide the content for the Link
     */
    children: PropTypes.node,

    /**
     * Provide a custom className to be applied to the containing <a> node
     */
    className: PropTypes.string,

    /**
     * Provide the `href` attribute for the <a> node
     */
    href: PropTypes.string,

    /**
     * Specify if the control should be disabled, or not
     */
    disabled: PropTypes.bool,

    /**
     * Specify whether you want the inline version of this control
     */
    inline: PropTypes.bool,

    /**
     * Specify whether you want the link to receive visited styles after the link has been clicked
     */
    visited: PropTypes.bool
  };

  var prefix$7 = settings_1.prefix;

  var BreadcrumbItem = function BreadcrumbItem(_ref) {
    var _cx;

    var ariaCurrent = _ref['aria-current'],
        children = _ref.children,
        customClassName = _ref.className,
        href = _ref.href,
        isCurrentPage = _ref.isCurrentPage,
        rest = _objectWithoutProperties(_ref, ["aria-current", "children", "className", "href", "isCurrentPage"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$7, "--breadcrumb-item"), true), _defineProperty(_cx, "".concat(prefix$7, "--breadcrumb-item--current"), isCurrentPage && ariaCurrent !== 'page'), _defineProperty(_cx, customClassName, !!customClassName), _cx));

    if (typeof children === 'string' && href) {
      return /*#__PURE__*/React__default.createElement("li", _extends({
        className: className
      }, rest), /*#__PURE__*/React__default.createElement(Link, {
        href: href,
        "aria-current": ariaCurrent
      }, children));
    }

    return /*#__PURE__*/React__default.createElement("li", _extends({
      className: className
    }, rest), /*#__PURE__*/React__default.cloneElement(children, {
      'aria-current': ariaCurrent,
      className: "".concat(prefix$7, "--link")
    }));
  };

  BreadcrumbItem.propTypes = {
    'aria-current': PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),

    /**
     * Pass in content that will be inside of the BreadcrumbItem
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Optional string representing the link location for the BreadcrumbItem
     */
    href: PropTypes.string,

    /**
     * Provide if this breadcrumb item represents the current page
     */
    isCurrentPage: PropTypes.bool
  };

  var prefix$8 = settings_1.prefix;
  var item = /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(prefix$8, "--breadcrumb-item")
  }, /*#__PURE__*/React__default.createElement("span", {
    className: "".concat(prefix$8, "--link")
  }, "\xA0"));

  function BreadcrumbSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["className"]);

    var classes = classnames("".concat(prefix$8, "--breadcrumb"), "".concat(prefix$8, "--skeleton"), className);
    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classes
    }, rest), item, item, item);
  }

  BreadcrumbSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$9 = settings_1.prefix;

  var ButtonSkeleton = function ButtonSkeleton(_ref) {
    var _cx;

    var className = _ref.className,
        small = _ref.small,
        href = _ref.href,
        rest = _objectWithoutProperties(_ref, ["className", "small", "href"]);

    var buttonClasses = classnames(className, (_cx = {}, _defineProperty(_cx, "".concat(prefix$9, "--skeleton"), true), _defineProperty(_cx, "".concat(prefix$9, "--btn"), true), _defineProperty(_cx, "".concat(prefix$9, "--btn--sm"), small), _cx));

    var commonProps = _objectSpread2({
      className: buttonClasses
    }, rest);

    var button = /*#__PURE__*/React__default.createElement("div", commonProps);
    var anchor = /*#__PURE__*/React__default.createElement("a", _extends({}, commonProps, {
      href: href,
      role: "button"
    })); // eslint-disable-line

    return href ? anchor : button;
  };

  ButtonSkeleton.propTypes = {
    /**
     * Specify whether the Button should be a small variant
     */
    small: PropTypes.bool,

    /**
     * Optionally specify an href for your Button to become an <a> element
     */
    href: PropTypes.string,

    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };
  ButtonSkeleton.defaultProps = {
    small: false
  };

  var ButtonKinds = ['primary', 'secondary', 'danger', 'ghost', 'danger--primary', 'tertiary'];

  var prefix$a = settings_1.prefix;
  var Button = /*#__PURE__*/React__default.forwardRef(function Button(_ref, ref) {
    var _classNames;

    var children = _ref.children,
        as = _ref.as,
        className = _ref.className,
        disabled = _ref.disabled,
        small = _ref.small,
        size = _ref.size,
        kind = _ref.kind,
        href = _ref.href,
        tabIndex = _ref.tabIndex,
        type = _ref.type,
        ButtonImageElement = _ref.renderIcon,
        iconDescription = _ref.iconDescription,
        hasIconOnly = _ref.hasIconOnly,
        tooltipPosition = _ref.tooltipPosition,
        tooltipAlignment = _ref.tooltipAlignment,
        other = _objectWithoutProperties(_ref, ["children", "as", "className", "disabled", "small", "size", "kind", "href", "tabIndex", "type", "renderIcon", "iconDescription", "hasIconOnly", "tooltipPosition", "tooltipAlignment"]);

    var buttonClasses = classnames(className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$a, "--btn"), true), _defineProperty(_classNames, "".concat(prefix$a, "--btn--field"), size === 'field'), _defineProperty(_classNames, "".concat(prefix$a, "--btn--sm"), size === 'small' || small), _defineProperty(_classNames, "".concat(prefix$a, "--btn--").concat(kind), kind), _defineProperty(_classNames, "".concat(prefix$a, "--btn--disabled"), disabled), _defineProperty(_classNames, "".concat(prefix$a, "--btn--icon-only"), hasIconOnly), _defineProperty(_classNames, "".concat(prefix$a, "--tooltip__trigger"), hasIconOnly), _defineProperty(_classNames, "".concat(prefix$a, "--tooltip--a11y"), hasIconOnly), _defineProperty(_classNames, "".concat(prefix$a, "--tooltip--").concat(tooltipPosition), hasIconOnly && tooltipPosition), _defineProperty(_classNames, "".concat(prefix$a, "--tooltip--align-").concat(tooltipAlignment), hasIconOnly && tooltipAlignment), _classNames));
    var commonProps = {
      tabIndex: tabIndex,
      className: buttonClasses,
      ref: ref
    };
    var buttonImage = !ButtonImageElement ? null : /*#__PURE__*/React__default.createElement(ButtonImageElement, {
      "aria-label": iconDescription,
      className: "".concat(prefix$a, "--btn__icon"),
      "aria-hidden": "true"
    });
    var component = 'button';
    var otherProps = {
      disabled: disabled,
      type: type
    };
    var anchorProps = {
      href: href
    };
    var assistiveText = hasIconOnly ? /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$a, "--assistive-text")
    }, iconDescription) : null;

    if (as) {
      component = as;
      otherProps = _objectSpread2(_objectSpread2({}, otherProps), anchorProps);
    } else if (href && !disabled) {
      component = 'a';
      otherProps = anchorProps;
    }

    return /*#__PURE__*/React__default.createElement(component, _objectSpread2(_objectSpread2(_objectSpread2({}, other), commonProps), otherProps), assistiveText, children, buttonImage);
  });
  Button.propTypes = {
    /**
     * Specify the content of your Button
     */
    children: PropTypes.node,

    /**
     * Specify how the button itself should be rendered.
     * Make sure to apply all props to the root node and render children appropriately
     */
    as: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.elementType]),

    /**
     * Specify an optional className to be added to your Button
     */
    className: PropTypes.string,

    /**
     * Specify whether the Button should be disabled, or not
     */
    disabled: PropTypes.bool,

    /**
     * Specify the size of the button, from a list of available sizes.
     * For `default` buttons, this prop can remain unspecified.
     */
    size: PropTypes.oneOf(['default', 'field', 'small']),

    /**
     * Deprecated in v10 in favor of `size`.
     * Specify whether the Button should be a small variant
     */
    small: deprecate(PropTypes.bool, "\nThe prop `small` for Button has been deprecated in favor of `size`. Please use `size=\"small\"` instead."),

    /**
     * Specify the kind of Button you want to create
     */
    kind: PropTypes.oneOf(ButtonKinds).isRequired,

    /**
     * Optionally specify an href for your Button to become an <a> element
     */
    href: PropTypes.string,

    /**
     * Optional prop to specify the tabIndex of the Button
     */
    tabIndex: PropTypes.number,

    /**
     * Optional prop to specify the type of the Button
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit']),

    /**
     * Optional prop to specify the role of the Button
     */
    role: PropTypes.string,

    /**
     * Optional prop to allow overriding the icon rendering.
     * Can be a React component class
     */
    renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),

    /**
     * If specifying the `renderIcon` prop, provide a description for that icon that can
     * be read by screen readers
     */
    iconDescription: function iconDescription(props) {
      if (props.renderIcon && !props.children && !props.iconDescription) {
        return new Error('renderIcon property specified without also providing an iconDescription property.');
      }

      return undefined;
    },

    /**
     * Specify if the button is an icon-only button
     */
    hasIconOnly: PropTypes.bool,

    /**
     * Specify the direction of the tooltip for icon-only buttons.
     * Can be either top, right, bottom, or left.
     */
    tooltipPosition: PropTypes.oneOf(['top', 'right', 'bottom', 'left']),

    /**
     * Specify the alignment of the tooltip to the icon-only button.
     * Can be one of: start, center, or end.
     */
    tooltipAlignment: PropTypes.oneOf(['start', 'center', 'end'])
  };
  Button.defaultProps = {
    tabIndex: 0,
    type: 'button',
    disabled: false,
    kind: 'primary'
  };

  var prefix$b = settings_1.prefix;

  var CheckboxSkeleton = function CheckboxSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$b, "--form-item"), "".concat(prefix$b, "--checkbox-wrapper"), "".concat(prefix$b, "--checkbox-label"), className)
    }, rest), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$b, "--checkbox-label-text ").concat(prefix$b, "--skeleton")
    }));
  };

  CheckboxSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$c = settings_1.prefix;
  var Checkbox$1 = /*#__PURE__*/React__default.forwardRef(function Checkbox(_ref, _ref2) {
    var className = _ref.className,
        id = _ref.id,
        labelText = _ref.labelText,
        _onChange = _ref.onChange,
        indeterminate = _ref.indeterminate,
        hideLabel = _ref.hideLabel,
        wrapperClassName = _ref.wrapperClassName,
        _ref$title = _ref.title,
        title = _ref$title === void 0 ? '' : _ref$title,
        other = _objectWithoutProperties(_ref, ["className", "id", "labelText", "onChange", "indeterminate", "hideLabel", "wrapperClassName", "title"]);

    var labelClasses = classnames("".concat(prefix$c, "--checkbox-label"), className);
    var innerLabelClasses = classnames("".concat(prefix$c, "--checkbox-label-text"), _defineProperty({}, "".concat(prefix$c, "--visually-hidden"), hideLabel));
    var wrapperClasses = classnames("".concat(prefix$c, "--form-item"), "".concat(prefix$c, "--checkbox-wrapper"), wrapperClassName);
    return /*#__PURE__*/React__default.createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default.createElement("input", _extends({}, other, {
      type: "checkbox",
      onChange: function onChange(evt) {
        _onChange(evt.target.checked, id, evt);
      },
      className: "".concat(prefix$c, "--checkbox"),
      id: id,
      ref: function ref(el) {
        if (el) {
          el.indeterminate = indeterminate;
        }

        if (typeof _ref2 === 'function') {
          _ref2(el);
        } else if (Object(_ref2) === _ref2) {
          _ref2.current = el;
        }
      }
    })), /*#__PURE__*/React__default.createElement("label", {
      htmlFor: id,
      className: labelClasses,
      title: title || null
    }, /*#__PURE__*/React__default.createElement("span", {
      className: innerLabelClasses
    }, labelText)));
  });
  Checkbox$1.propTypes = {
    /**
     * Specify whether the underlying input should be checked
     */
    checked: PropTypes.bool,

    /**
     * Specify whether the underlying input should be checked by default
     */
    defaultChecked: PropTypes.bool,

    /**
     * Specify whether the Checkbox is in an indeterminate state
     */
    indeterminate: PropTypes.bool,

    /**
     * Specify an optional className to be applied to the <label> node
     */
    className: PropTypes.string,

    /**
     * Specify whether the Checkbox should be disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide an `id` to uniquely identify the Checkbox input
     */
    id: PropTypes.string.isRequired,

    /**
     * Provide a label to provide a description of the Checkbox input that you are
     * exposing to the user
     */
    labelText: PropTypes.node.isRequired,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes.bool,

    /**
     * Receives three arguments: true/false, the checkbox's id, and the dom event.
     * `(value, id, event) => console.log({value, id, event})`
     */
    onChange: PropTypes.func,

    /**
     * Specify a title for the <label> node for the Checkbox
     */
    title: PropTypes.string,

    /**
     * The CSS class name to be placed on the wrapping element
     */
    wrapperClassName: PropTypes.string
  };
  Checkbox$1.defaultProps = {
    onChange: function onChange() {},
    indeterminate: false
  };
  Checkbox$1.displayName = 'Checkbox';

  var prefix$d = settings_1.prefix;

  function CodeSnippetSkeleton(_ref) {
    var _cx;

    var containerClassName = _ref.className,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'single' : _ref$type,
        rest = _objectWithoutProperties(_ref, ["className", "type"]);

    var className = classnames(containerClassName, (_cx = {}, _defineProperty(_cx, "".concat(prefix$d, "--snippet"), true), _defineProperty(_cx, "".concat(prefix$d, "--skeleton"), true), _defineProperty(_cx, "".concat(prefix$d, "--snippet--single"), type === 'single'), _defineProperty(_cx, "".concat(prefix$d, "--snippet--multi"), type === 'multi'), _cx));

    if (type === 'single') {
      return /*#__PURE__*/React__default.createElement("div", _extends({
        className: className
      }, rest), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$d, "--snippet-container")
      }, /*#__PURE__*/React__default.createElement("span", null)));
    }

    if (type === 'multi') {
      return /*#__PURE__*/React__default.createElement("div", _extends({
        className: className
      }, rest), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$d, "--snippet-container")
      }, /*#__PURE__*/React__default.createElement("span", null), /*#__PURE__*/React__default.createElement("span", null), /*#__PURE__*/React__default.createElement("span", null)));
    }
  }

  CodeSnippetSkeleton.propTypes = {
    /**
     * The type of the code snippet, including single or multi
     */
    type: PropTypes.oneOf(['single', 'multi']),

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string
  };

  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = function () {
    if (typeof Map !== 'undefined') {
      return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */


    function getIndex(arr, key) {
      var result = -1;
      arr.some(function (entry, index) {
        if (entry[0] === key) {
          result = index;
          return true;
        }

        return false;
      });
      return result;
    }

    return (
      /** @class */
      function () {
        function class_1() {
          this.__entries__ = [];
        }

        Object.defineProperty(class_1.prototype, "size", {
          /**
           * @returns {boolean}
           */
          get: function get() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */

        class_1.prototype.get = function (key) {
          var index = getIndex(this.__entries__, key);
          var entry = this.__entries__[index];
          return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */


        class_1.prototype.set = function (key, value) {
          var index = getIndex(this.__entries__, key);

          if (~index) {
            this.__entries__[index][1] = value;
          } else {
            this.__entries__.push([key, value]);
          }
        };
        /**
         * @param {*} key
         * @returns {void}
         */


        class_1.prototype.delete = function (key) {
          var entries = this.__entries__;
          var index = getIndex(entries, key);

          if (~index) {
            entries.splice(index, 1);
          }
        };
        /**
         * @param {*} key
         * @returns {void}
         */


        class_1.prototype.has = function (key) {
          return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */


        class_1.prototype.clear = function () {
          this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */


        class_1.prototype.forEach = function (callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }

          for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
            var entry = _a[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };

        return class_1;
      }()
    );
  }();
  /**
   * Detects whether window and document objects are available in current environment.
   */


  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

  var global$1 = function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
      return global;
    }

    if (typeof self !== 'undefined' && self.Math === Math) {
      return self;
    }

    if (typeof window !== 'undefined' && window.Math === Math) {
      return window;
    } // eslint-disable-next-line no-new-func


    return Function('return this')();
  }();
  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */


  var requestAnimationFrame$1 = function () {
    if (typeof requestAnimationFrame === 'function') {
      // It's required to use a bounded function because IE sometimes throws
      // an "Invalid calling object" error if rAF is invoked without the global
      // object on the left hand side.
      return requestAnimationFrame.bind(global$1);
    }

    return function (callback) {
      return setTimeout(function () {
        return callback(Date.now());
      }, 1000 / 60);
    };
  }(); // Defines minimum timeout before adding a trailing call.


  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */

  function throttle(callback, delay) {
    var leadingCall = false,
        trailingCall = false,
        lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */

    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }

      if (trailingCall) {
        proxy();
      }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */


    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */


    function proxy() {
      var timeStamp = Date.now();

      if (leadingCall) {
        // Reject immediately following calls.
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        } // Schedule new call to be in invoked when the pending one is resolved.
        // This is important for "transitions" which never actually start
        // immediately so there is a chance that we might miss one if change
        // happens amids the pending invocation.


        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }

      lastCallTime = timeStamp;
    }

    return proxy;
  } // Minimum delay before invoking the update of observers.


  var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.

  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

  var mutationObserverSupported = typeof MutationObserver !== 'undefined';
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */

  var ResizeObserverController =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
      /**
       * Indicates whether DOM listeners have been added.
       *
       * @private {boolean}
       */
      this.connected_ = false;
      /**
       * Tells that controller has subscribed for Mutation Events.
       *
       * @private {boolean}
       */

      this.mutationEventsAdded_ = false;
      /**
       * Keeps reference to the instance of MutationObserver.
       *
       * @private {MutationObserver}
       */

      this.mutationsObserver_ = null;
      /**
       * A list of connected observers.
       *
       * @private {Array<ResizeObserverSPI>}
       */

      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */


    ResizeObserverController.prototype.addObserver = function (observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      } // Add listeners if they haven't been added yet.


      if (!this.connected_) {
        this.connect_();
      }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */


    ResizeObserverController.prototype.removeObserver = function (observer) {
      var observers = this.observers_;
      var index = observers.indexOf(observer); // Remove observer if it's present in registry.

      if (~index) {
        observers.splice(index, 1);
      } // Remove listeners if controller has no connected observers.


      if (!observers.length && this.connected_) {
        this.disconnect_();
      }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */


    ResizeObserverController.prototype.refresh = function () {
      var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
      // be future ones caused by CSS transitions.

      if (changesDetected) {
        this.refresh();
      }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */


    ResizeObserverController.prototype.updateObservers_ = function () {
      // Collect observers that have active observations.
      var activeObservers = this.observers_.filter(function (observer) {
        return observer.gatherActive(), observer.hasActive();
      }); // Deliver notifications in a separate cycle in order to avoid any
      // collisions between observers, e.g. when multiple instances of
      // ResizeObserver are tracking the same element and the callback of one
      // of them changes content dimensions of the observed target. Sometimes
      // this may result in notifications being blocked for the rest of observers.

      activeObservers.forEach(function (observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */


    ResizeObserverController.prototype.connect_ = function () {
      // Do nothing if running in a non-browser environment or if listeners
      // have been already added.
      if (!isBrowser || this.connected_) {
        return;
      } // Subscription to the "Transitionend" event is used as a workaround for
      // delayed transitions. This way it's possible to capture at least the
      // final state of an element.


      document.addEventListener('transitionend', this.onTransitionEnd_);
      window.addEventListener('resize', this.refresh);

      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener('DOMSubtreeModified', this.refresh);
        this.mutationEventsAdded_ = true;
      }

      this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */


    ResizeObserverController.prototype.disconnect_ = function () {
      // Do nothing if running in a non-browser environment or if listeners
      // have been already removed.
      if (!isBrowser || !this.connected_) {
        return;
      }

      document.removeEventListener('transitionend', this.onTransitionEnd_);
      window.removeEventListener('resize', this.refresh);

      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }

      if (this.mutationEventsAdded_) {
        document.removeEventListener('DOMSubtreeModified', this.refresh);
      }

      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */


    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
      var _b = _a.propertyName,
          propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

      var isReflowProperty = transitionKeys.some(function (key) {
        return !!~propertyName.indexOf(key);
      });

      if (isReflowProperty) {
        this.refresh();
      }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */


    ResizeObserverController.getInstance = function () {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController();
      }

      return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */


    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
  }();
  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */


  var defineConfigurable = function defineConfigurable(target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
      var key = _a[_i];
      Object.defineProperty(target, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }

    return target;
  };
  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */


  var getWindowOf = function getWindowOf(target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
    // provided element.

    return ownerGlobal || global$1;
  }; // Placeholder of an empty content rectangle.


  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */

  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */


  function getBordersSize(styles) {
    var positions = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }

    return positions.reduce(function (size, position) {
      var value = styles['border-' + position + '-width'];
      return size + toFloat(value);
    }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */


  function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};

    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position = positions_1[_i];
      var value = styles['padding-' + position];
      paddings[position] = toFloat(value);
    }

    return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */


  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */


  function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth,
        clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.

    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }

    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.

    var width = toFloat(styles.width),
        height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).

    if (styles.boxSizing === 'border-box') {
      // Following conditions are required to handle Internet Explorer which
      // doesn't include paddings and borders to computed CSS dimensions.
      //
      // We can say that if CSS dimensions + paddings are equal to the "client"
      // properties then it's either IE, and thus we don't need to subtract
      // anything, or an element merely doesn't have paddings/borders styles.
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, 'left', 'right') + horizPad;
      }

      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
      }
    } // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.


    if (!isDocumentElement(target)) {
      // In some browsers (only in Firefox, actually) CSS width & height
      // include scroll bars size which can be removed at this step as scroll
      // bars are the only difference between rounded dimensions + paddings
      // and "client" properties, though that is not always true in Chrome.
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
      // E.g. for an element with content width of 314.2px it sometimes gives
      // the client width of 315px and for the width of 314.7px it may give
      // 314px. And it doesn't happen all the time. So just ignore this delta
      // as a non-relevant.

      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }

      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }

    return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */


  var isSVGGraphicsElement = function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
      return function (target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    } // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens


    return function (target) {
      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
    };
  }();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */


  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */


  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }

    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }

    return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */


  function createReadOnlyRect(_a) {
    var x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

    defineConfigurable(rect, {
      x: x,
      y: y,
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: height + y,
      left: x
    });
    return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */


  function createRectInit(x, y, width, height) {
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }
  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */


  var ResizeObservation =
  /** @class */
  function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
      /**
       * Broadcasted width of content rectangle.
       *
       * @type {number}
       */
      this.broadcastWidth = 0;
      /**
       * Broadcasted height of content rectangle.
       *
       * @type {number}
       */

      this.broadcastHeight = 0;
      /**
       * Reference to the last observed content rectangle.
       *
       * @private {DOMRectInit}
       */

      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */


    ResizeObservation.prototype.isActive = function () {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */


    ResizeObservation.prototype.broadcastRect = function () {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };

    return ResizeObservation;
  }();

  var ResizeObserverEntry =
  /** @class */
  function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
      // and are also not enumerable in the native implementation.
      //
      // Property accessors are not being used as they'd require to define a
      // private WeakMap storage which may cause memory leaks in browsers that
      // don't support this type of collections.

      defineConfigurable(this, {
        target: target,
        contentRect: contentRect
      });
    }

    return ResizeObserverEntry;
  }();

  var ResizeObserverSPI =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
      /**
       * Collection of resize observations that have detected changes in dimensions
       * of elements.
       *
       * @private {Array<ResizeObservation>}
       */
      this.activeObservations_ = [];
      /**
       * Registry of the ResizeObservation instances.
       *
       * @private {Map<Element, ResizeObservation>}
       */

      this.observations_ = new MapShim();

      if (typeof callback !== 'function') {
        throw new TypeError('The callback provided as parameter 1 is not a function.');
      }

      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */


    ResizeObserverSPI.prototype.observe = function (target) {
      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      } // Do nothing if current environment doesn't have the Element interface.


      if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
      }

      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }

      var observations = this.observations_; // Do nothing if element is already being observed.

      if (observations.has(target)) {
        return;
      }

      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this); // Force the update of observations.

      this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */


    ResizeObserverSPI.prototype.unobserve = function (target) {
      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      } // Do nothing if current environment doesn't have the Element interface.


      if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
      }

      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }

      var observations = this.observations_; // Do nothing if element is not being observed.

      if (!observations.has(target)) {
        return;
      }

      observations.delete(target);

      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.disconnect = function () {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.gatherActive = function () {
      var _this = this;

      this.clearActive();
      this.observations_.forEach(function (observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.broadcastActive = function () {
      // Do nothing if observer doesn't have active observations.
      if (!this.hasActive()) {
        return;
      }

      var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

      var entries = this.activeObservations_.map(function (observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.clearActive = function () {
      this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */


    ResizeObserverSPI.prototype.hasActive = function () {
      return this.activeObservations_.length > 0;
    };

    return ResizeObserverSPI;
  }(); // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.


  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */

  var ResizeObserver =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
      if (!(this instanceof ResizeObserver)) {
        throw new TypeError('Cannot call a class as a function.');
      }

      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      }

      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }

    return ResizeObserver;
  }(); // Expose public methods of ResizeObserver.


  ['observe', 'unobserve', 'disconnect'].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
      var _a;

      return (_a = observers.get(this))[method].apply(_a, arguments);
    };
  });

  var index = function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
      return global$1.ResizeObserver;
    }

    return ResizeObserver;
  }();

  function _interopDefault(ex) {
    return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
  }

  var ResizeObserver$1 = _interopDefault(index);

  function _extends$2() {
    _extends$2 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$2.apply(this, arguments);
  }

  function index$1(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        ref = _ref.ref,
        onResize = _ref.onResize; // `defaultRef` Has to be non-conditionally declared here whether or not it'll
    // be used as that's how hooks work.
    // @see https://reactjs.org/docs/hooks-rules.html#explanation


    var defaultRef = React__default.useRef(null);
    ref = ref || defaultRef;

    var _useState = React__default.useState({
      width: undefined,
      height: undefined
    }),
        size = _useState[0],
        setSize = _useState[1]; // Using a ref to track the previous width / height to avoid unnecessary renders


    var previous = React__default.useRef({
      width: undefined,
      height: undefined
    });
    React__default.useEffect(function () {
      if (_typeof(ref) !== "object" || ref === null || !(ref.current instanceof Element)) {
        return;
      }

      var element = ref.current;
      var resizeObserver = new ResizeObserver$1(function (entries) {
        if (!Array.isArray(entries)) {
          return;
        } // Since we only observe the one element, we don't need to loop over the
        // array


        if (!entries.length) {
          return;
        }

        var entry = entries[0]; // `Math.round` is in line with how CSS resolves sub-pixel values

        var newWidth = Math.round(entry.contentRect.width);
        var newHeight = Math.round(entry.contentRect.height);

        if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
          var newSize = {
            width: newWidth,
            height: newHeight
          };

          if (onResize) {
            onResize(newSize);
          } else {
            previous.current.width = newWidth;
            previous.current.height = newHeight;
            setSize(newSize);
          }
        }
      });
      resizeObserver.observe(element);
      return function () {
        return resizeObserver.unobserve(element);
      };
    }, [ref, onResize]);
    return React__default.useMemo(function () {
      return _extends$2({
        ref: ref
      }, size);
    }, [ref, size ? size.width : null, size ? size.height : null]);
  }

  var polyfilled = index$1;

  /**
   * Generic utility to compose event handlers so that consumers can supply their
   * own event listeners on table components. The default heuristic here is to
   * iterate through the given functions until `preventDefault` is called on the
   * given event.
   *
   * @param {Array<Function>} fns array of functions to apply to the event
   * @returns {Function}
   */
  var composeEventHandlers = function composeEventHandlers(fns) {
    return function (event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      for (var i = 0; i < fns.length; i++) {
        if (event.defaultPrevented) {
          break;
        }

        if (typeof fns[i] === 'function') {
          fns[i].apply(fns, [event].concat(args));
        }
      }
    };
  };

  var prefix$e = settings_1.prefix;
  function Copy(_ref) {
    var _classnames;

    var children = _ref.children,
        className = _ref.className,
        feedback = _ref.feedback,
        feedbackTimeout = _ref.feedbackTimeout,
        onAnimationEnd = _ref.onAnimationEnd,
        onClick = _ref.onClick,
        other = _objectWithoutProperties(_ref, ["children", "className", "feedback", "feedbackTimeout", "onAnimationEnd", "onClick"]);

    var _useState = React.useState(''),
        _useState2 = _slicedToArray(_useState, 2),
        animation = _useState2[0],
        setAnimation = _useState2[1];

    var classNames = classnames(className, "".concat(prefix$e, "--copy"), (_classnames = {}, _defineProperty(_classnames, "".concat(prefix$e, "--copy-btn--animating"), animation), _defineProperty(_classnames, "".concat(prefix$e, "--copy-btn--").concat(animation), animation), _classnames)); // eslint-disable-next-line react-hooks/exhaustive-deps

    var handleFadeOut = React.useCallback(lodash_debounce(function () {
      setAnimation('fade-out');
    }, feedbackTimeout), [feedbackTimeout]);
    var handleClick = React.useCallback(function () {
      setAnimation('fade-in');
      handleFadeOut();
    }, [handleFadeOut]);

    var handleAnimationEnd = function handleAnimationEnd(event) {
      if (event.animationName === 'hide-feedback') {
        setAnimation('');
      }
    };

    React.useEffect(function () {
      return function () {
        handleFadeOut.cancel();
      };
    }, [handleFadeOut]);
    return /*#__PURE__*/React__default.createElement("button", _extends({
      type: "button",
      className: classNames,
      onClick: composeEventHandlers([onClick, handleClick]),
      onAnimationEnd: composeEventHandlers([onAnimationEnd, handleAnimationEnd])
    }, other, {
      "aria-live": "polite",
      "aria-label": !children && (animation ? feedback : other['aria-label']) || null
    }), children, animation ? feedback : other['aria-label'], /*#__PURE__*/React__default.createElement("span", {
      "aria-hidden": "true",
      className: "".concat(prefix$e, "--assistive-text ").concat(prefix$e, "--copy-btn__feedback")
    }, feedback));
  }
  Copy.propTypes = {
    /**
     * Pass in content to be rendred in the underlying <button>
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the underlying <button>
     */
    className: PropTypes.string,

    /**
     * Specify the string that is displayed when the button is clicked and the
     * content is copied
     */
    feedback: PropTypes.string,

    /**
     * Specify the time it takes for the feedback message to timeout
     */
    feedbackTimeout: PropTypes.number,

    /**
     * Specify an optional `onClick` handler that is called when the underlying
     * <button> is clicked
     */
    onClick: PropTypes.func,

    /**
     * Specify an optional `onAnimationEnd` handler that is called when the underlying
     * animation ends
     */
    onAnimationEnd: PropTypes.func
  };
  Copy.defaultProps = {
    feedback: 'Copied!',
    feedbackTimeout: 2000,
    onClick: function onClick() {}
  };

  var prefix$f = settings_1.prefix;
  function CopyButton$1(_ref) {
    var iconDescription = _ref.iconDescription,
        className = _ref.className,
        other = _objectWithoutProperties(_ref, ["iconDescription", "className"]);

    return /*#__PURE__*/React__default.createElement(Copy, _extends({
      className: classnames(className, "".concat(prefix$f, "--copy-btn")),
      "aria-label": iconDescription,
      title: iconDescription
    }, other), /*#__PURE__*/React__default.createElement(Copy16, {
      className: "".concat(prefix$f, "--snippet__icon")
    }));
  }
  CopyButton$1.propTypes = {
    /**
     * Specify an optional className to be applied to the underlying <button>
     */
    className: PropTypes.string,

    /**
     * Provide a description for the icon representing the copy action that can
     * be read by screen readers
     */
    iconDescription: PropTypes.string,

    /**
     * Specify the string that is displayed when the button is clicked and the
     * content is copied
     */
    feedback: PropTypes.string,

    /**
     * Specify the time it takes for the feedback message to timeout
     */
    feedbackTimeout: PropTypes.number,

    /**
     * Specify an optional `onClick` handler that is called when the underlying
     * <button> is clicked
     */
    onClick: PropTypes.func
  };
  CopyButton$1.defaultProps = {
    iconDescription: 'Copy to clipboard',
    feedback: 'Copied!',
    feedbackTimeout: 2000,
    onClick: function onClick() {}
  };

  var lastId = 0;
  function uid () {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';
    lastId++;
    return "".concat(prefix).concat(lastId);
  }

  var prefix$g = settings_1.prefix;

  function CodeSnippet$1(_ref) {
    var _classNames;

    var className = _ref.className,
        type = _ref.type,
        children = _ref.children,
        feedback = _ref.feedback,
        onClick = _ref.onClick,
        ariaLabel = _ref.ariaLabel,
        copyLabel = _ref.copyLabel,
        copyButtonDescription = _ref.copyButtonDescription,
        light = _ref.light,
        showMoreText = _ref.showMoreText,
        showLessText = _ref.showLessText,
        rest = _objectWithoutProperties(_ref, ["className", "type", "children", "feedback", "onClick", "ariaLabel", "copyLabel", "copyButtonDescription", "light", "showMoreText", "showLessText"]);

    var _useState = React.useState(false),
        _useState2 = _slicedToArray(_useState, 2),
        expandedCode = _useState2[0],
        setExpandedCode = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray(_useState3, 2),
        shouldShowMoreLessBtn = _useState4[0],
        setShouldShowMoreLessBtn = _useState4[1];

    var _useRef = React.useRef(uid()),
        uid$1 = _useRef.current;

    var codeContentRef = React.useRef();
    polyfilled({
      ref: codeContentRef,
      onResize: function onResize() {
        if (codeContentRef.current) {
          var _codeContentRef$curre = codeContentRef.current.getBoundingClientRect(),
              height = _codeContentRef$curre.height;

          setShouldShowMoreLessBtn(type === 'multi' && height > 255);
        }
      }
    });
    var codeSnippetClasses = classnames(className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$g, "--snippet"), true), _defineProperty(_classNames, "".concat(prefix$g, "--snippet--").concat(type), type), _defineProperty(_classNames, "".concat(prefix$g, "--snippet--expand"), expandedCode), _defineProperty(_classNames, "".concat(prefix$g, "--snippet--light"), light), _classNames));
    var expandCodeBtnText = expandedCode ? showLessText : showMoreText;

    if (type === 'inline') {
      return /*#__PURE__*/React__default.createElement(Copy, _extends({}, rest, {
        onClick: onClick,
        "aria-label": copyLabel || ariaLabel,
        "aria-describedby": uid$1,
        className: codeSnippetClasses,
        feedback: feedback
      }), /*#__PURE__*/React__default.createElement("code", {
        id: uid$1
      }, children));
    }

    return /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
      className: codeSnippetClasses
    }), /*#__PURE__*/React__default.createElement("div", {
      role: type === 'single' ? 'textbox' : null,
      tabIndex: type === 'single' ? 0 : null,
      className: "".concat(prefix$g, "--snippet-container"),
      "aria-label": ariaLabel || copyLabel || 'code-snippet'
    }, /*#__PURE__*/React__default.createElement("code", null, /*#__PURE__*/React__default.createElement("pre", {
      ref: codeContentRef
    }, children))), /*#__PURE__*/React__default.createElement(CopyButton$1, {
      onClick: onClick,
      feedback: feedback,
      iconDescription: copyButtonDescription
    }), shouldShowMoreLessBtn && /*#__PURE__*/React__default.createElement(Button, {
      kind: "ghost",
      size: "small",
      className: "".concat(prefix$g, "--snippet-btn--expand"),
      onClick: function onClick() {
        return setExpandedCode(!expandedCode);
      }
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$g, "--snippet-btn--text")
    }, expandCodeBtnText), /*#__PURE__*/React__default.createElement(ChevronDown16, {
      "aria-label": expandCodeBtnText,
      className: "".concat(prefix$g, "--icon-chevron--down ").concat(prefix$g, "--snippet__icon"),
      name: "chevron--down",
      role: "img"
    })));
  }

  CodeSnippet$1.propTypes = {
    /**
     * Provide the type of Code Snippet
     */
    type: PropTypes.oneOf(['single', 'inline', 'multi']),

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Provide the content of your CodeSnippet as a string
     */
    children: PropTypes.string,

    /**
     * Specify the string displayed when the snippet is copied
     */
    feedback: PropTypes.string,

    /**
     * Specify the description for the Copy Button
     */
    copyButtonDescription: PropTypes.string,

    /**
     * An optional handler to listen to the `onClick` even fired by the Copy
     * Button
     */
    onClick: PropTypes.func,

    /**
     * Specify a label to be read by screen readers on the containing <textbox>
     * node
     */
    copyLabel: PropTypes.string,

    /**
     * Specify a label to be read by screen readers on the containing <textbox>
     * node
     */
    ariaLabel: PropTypes.string,

    /**
     * Specify a string that is displayed when the Code Snippet text is more
     * than 15 lines
     */
    showMoreText: PropTypes.string,

    /**
     * Specify a string that is displayed when the Code Snippet has been
     * interacted with to show more lines
     */
    showLessText: PropTypes.string,

    /**
     * Specify whether you are using the light variant of the Code Snippet,
     * typically used for inline snippet to display an alternate color
     */
    light: PropTypes.bool
  };
  CodeSnippet$1.defaultProps = {
    type: 'single',
    showMoreText: 'Show more',
    showLessText: 'Show less'
  };

  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _extends$3() {
    _extends$3 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$3.apply(this, arguments);
  }

  function _assertThisInitialized$E(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var reactIs_production_min = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var b = "function" === typeof Symbol && Symbol.for,
        c = b ? Symbol.for("react.element") : 60103,
        d = b ? Symbol.for("react.portal") : 60106,
        e = b ? Symbol.for("react.fragment") : 60107,
        f = b ? Symbol.for("react.strict_mode") : 60108,
        g = b ? Symbol.for("react.profiler") : 60114,
        h = b ? Symbol.for("react.provider") : 60109,
        k = b ? Symbol.for("react.context") : 60110,
        l = b ? Symbol.for("react.async_mode") : 60111,
        m = b ? Symbol.for("react.concurrent_mode") : 60111,
        n = b ? Symbol.for("react.forward_ref") : 60112,
        p = b ? Symbol.for("react.suspense") : 60113,
        q = b ? Symbol.for("react.suspense_list") : 60120,
        r = b ? Symbol.for("react.memo") : 60115,
        t = b ? Symbol.for("react.lazy") : 60116,
        v = b ? Symbol.for("react.fundamental") : 60117,
        w = b ? Symbol.for("react.responder") : 60118;

    function x(a) {
      if ("object" === _typeof(a) && null !== a) {
        var u = a.$$typeof;

        switch (u) {
          case c:
            switch (a = a.type, a) {
              case l:
              case m:
              case e:
              case g:
              case f:
              case p:
                return a;

              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n:
                  case h:
                    return a;

                  default:
                    return u;
                }

            }

          case t:
          case r:
          case d:
            return u;
        }
      }
    }

    function y(a) {
      return x(a) === m;
    }

    exports.typeOf = x;
    exports.AsyncMode = l;
    exports.ConcurrentMode = m;
    exports.ContextConsumer = k;
    exports.ContextProvider = h;
    exports.Element = c;
    exports.ForwardRef = n;
    exports.Fragment = e;
    exports.Lazy = t;
    exports.Memo = r;
    exports.Portal = d;
    exports.Profiler = g;
    exports.StrictMode = f;
    exports.Suspense = p;

    exports.isValidElementType = function (a) {
      return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === _typeof(a) && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === v || a.$$typeof === w);
    };

    exports.isAsyncMode = function (a) {
      return y(a) || x(a) === l;
    };

    exports.isConcurrentMode = y;

    exports.isContextConsumer = function (a) {
      return x(a) === k;
    };

    exports.isContextProvider = function (a) {
      return x(a) === h;
    };

    exports.isElement = function (a) {
      return "object" === _typeof(a) && null !== a && a.$$typeof === c;
    };

    exports.isForwardRef = function (a) {
      return x(a) === n;
    };

    exports.isFragment = function (a) {
      return x(a) === e;
    };

    exports.isLazy = function (a) {
      return x(a) === t;
    };

    exports.isMemo = function (a) {
      return x(a) === r;
    };

    exports.isPortal = function (a) {
      return x(a) === d;
    };

    exports.isProfiler = function (a) {
      return x(a) === g;
    };

    exports.isStrictMode = function (a) {
      return x(a) === f;
    };

    exports.isSuspense = function (a) {
      return x(a) === p;
    };
  });
  unwrapExports(reactIs_production_min);
  var reactIs_production_min_1 = reactIs_production_min.typeOf;
  var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
  var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
  var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
  var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
  var reactIs_production_min_6 = reactIs_production_min.Element;
  var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
  var reactIs_production_min_8 = reactIs_production_min.Fragment;
  var reactIs_production_min_9 = reactIs_production_min.Lazy;
  var reactIs_production_min_10 = reactIs_production_min.Memo;
  var reactIs_production_min_11 = reactIs_production_min.Portal;
  var reactIs_production_min_12 = reactIs_production_min.Profiler;
  var reactIs_production_min_13 = reactIs_production_min.StrictMode;
  var reactIs_production_min_14 = reactIs_production_min.Suspense;
  var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
  var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
  var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
  var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
  var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
  var reactIs_production_min_20 = reactIs_production_min.isElement;
  var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
  var reactIs_production_min_22 = reactIs_production_min.isFragment;
  var reactIs_production_min_23 = reactIs_production_min.isLazy;
  var reactIs_production_min_24 = reactIs_production_min.isMemo;
  var reactIs_production_min_25 = reactIs_production_min.isPortal;
  var reactIs_production_min_26 = reactIs_production_min.isProfiler;
  var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
  var reactIs_production_min_28 = reactIs_production_min.isSuspense;

  var reactIs_development = createCommonjsModule(function (module, exports) {

    {
      (function () {

        Object.defineProperty(exports, '__esModule', {
          value: true
        }); // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.

        var hasSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
        // (unstable) APIs that have been removed. Can we remove the symbols?

        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;

        function isValidElementType(type) {
          return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || _typeof(type) === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE);
        }
        /**
         * Forked from fbjs/warning:
         * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
         *
         * Only change is we use console.warn instead of console.error,
         * and do nothing when 'console' is not supported.
         * This really simplifies the code.
         * ---
         * Similar to invariant but only logs a warning if the condition is not met.
         * This can be used to log issues in development environments in critical
         * paths. Removing the logging code for production environments will keep the
         * same logic and follow the same code paths.
         */


        var lowPriorityWarning = function lowPriorityWarning() {};

        {
          var printWarning = function printWarning(format) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            var argIndex = 0;
            var message = 'Warning: ' + format.replace(/%s/g, function () {
              return args[argIndex++];
            });

            if (typeof console !== 'undefined') {
              console.warn(message);
            }

            try {
              // --- Welcome to debugging React ---
              // This error was thrown as a convenience so that you can use this stack
              // to find the callsite that caused this warning to fire.
              throw new Error(message);
            } catch (x) {}
          };

          lowPriorityWarning = function lowPriorityWarning(condition, format) {
            if (format === undefined) {
              throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
            }

            if (!condition) {
              for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                args[_key2 - 2] = arguments[_key2];
              }

              printWarning.apply(undefined, [format].concat(args));
            }
          };
        }
        var lowPriorityWarning$1 = lowPriorityWarning;

        function typeOf(object) {
          if (_typeof(object) === 'object' && object !== null) {
            var $$typeof = object.$$typeof;

            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;

                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;

                  default:
                    var $$typeofType = type && type.$$typeof;

                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;

                      default:
                        return $$typeof;
                    }

                }

              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }

          return undefined;
        } // AsyncMode is deprecated along with isAsyncMode


        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }

        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }

        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }

        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }

        function isElement(object) {
          return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }

        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }

        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }

        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }

        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }

        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }

        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }

        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }

        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }

        exports.typeOf = typeOf;
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isValidElementType = isValidElementType;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
      })();
    }
  });
  unwrapExports(reactIs_development);
  var reactIs_development_1 = reactIs_development.typeOf;
  var reactIs_development_2 = reactIs_development.AsyncMode;
  var reactIs_development_3 = reactIs_development.ConcurrentMode;
  var reactIs_development_4 = reactIs_development.ContextConsumer;
  var reactIs_development_5 = reactIs_development.ContextProvider;
  var reactIs_development_6 = reactIs_development.Element;
  var reactIs_development_7 = reactIs_development.ForwardRef;
  var reactIs_development_8 = reactIs_development.Fragment;
  var reactIs_development_9 = reactIs_development.Lazy;
  var reactIs_development_10 = reactIs_development.Memo;
  var reactIs_development_11 = reactIs_development.Portal;
  var reactIs_development_12 = reactIs_development.Profiler;
  var reactIs_development_13 = reactIs_development.StrictMode;
  var reactIs_development_14 = reactIs_development.Suspense;
  var reactIs_development_15 = reactIs_development.isValidElementType;
  var reactIs_development_16 = reactIs_development.isAsyncMode;
  var reactIs_development_17 = reactIs_development.isConcurrentMode;
  var reactIs_development_18 = reactIs_development.isContextConsumer;
  var reactIs_development_19 = reactIs_development.isContextProvider;
  var reactIs_development_20 = reactIs_development.isElement;
  var reactIs_development_21 = reactIs_development.isForwardRef;
  var reactIs_development_22 = reactIs_development.isFragment;
  var reactIs_development_23 = reactIs_development.isLazy;
  var reactIs_development_24 = reactIs_development.isMemo;
  var reactIs_development_25 = reactIs_development.isPortal;
  var reactIs_development_26 = reactIs_development.isProfiler;
  var reactIs_development_27 = reactIs_development.isStrictMode;
  var reactIs_development_28 = reactIs_development.isSuspense;

  var reactIs = createCommonjsModule(function (module) {

    {
      module.exports = reactIs_development;
    }
  });
  var reactIs_1 = reactIs.isForwardRef;

  function isElement(el) {
    return el != null && _typeof(el) === 'object' && el.nodeType === 1;
  }

  function canOverflow(overflow, skipOverflowHiddenElements) {
    if (skipOverflowHiddenElements && overflow === 'hidden') {
      return false;
    }

    return overflow !== 'visible' && overflow !== 'clip';
  }

  function getFrameElement(el) {
    if (!el.ownerDocument || !el.ownerDocument.defaultView) {
      return null;
    }

    try {
      return el.ownerDocument.defaultView.frameElement;
    } catch (e) {
      return null;
    }
  }

  function isHiddenByFrame(el) {
    var frame = getFrameElement(el);

    if (!frame) {
      return false;
    }

    return frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth;
  }

  function isScrollable(el, skipOverflowHiddenElements) {
    if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {
      var style = getComputedStyle(el, null);
      return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements) || isHiddenByFrame(el);
    }

    return false;
  }

  function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
    if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {
      return 0;
    }

    if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {
      return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
    }

    if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {
      return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
    }

    return 0;
  }

  var computeScrollIntoView = (function (target, options) {
    var scrollMode = options.scrollMode,
        block = options.block,
        inline = options.inline,
        boundary = options.boundary,
        skipOverflowHiddenElements = options.skipOverflowHiddenElements;
    var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {
      return node !== boundary;
    };

    if (!isElement(target)) {
      throw new TypeError('Invalid target');
    }

    var scrollingElement = document.scrollingElement || document.documentElement;
    var frames = [];
    var cursor = target;

    while (isElement(cursor) && checkBoundary(cursor)) {
      cursor = cursor.parentNode;

      if (cursor === scrollingElement) {
        frames.push(cursor);
        break;
      }

      if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {
        continue;
      }

      if (isScrollable(cursor, skipOverflowHiddenElements)) {
        frames.push(cursor);
      }
    }

    var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;
    var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;
    var viewportX = window.scrollX || pageXOffset;
    var viewportY = window.scrollY || pageYOffset;

    var _target$getBoundingCl = target.getBoundingClientRect(),
        targetHeight = _target$getBoundingCl.height,
        targetWidth = _target$getBoundingCl.width,
        targetTop = _target$getBoundingCl.top,
        targetRight = _target$getBoundingCl.right,
        targetBottom = _target$getBoundingCl.bottom,
        targetLeft = _target$getBoundingCl.left;

    var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;
    var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;
    var computations = [];

    for (var index = 0; index < frames.length; index++) {
      var frame = frames[index];

      var _frame$getBoundingCli = frame.getBoundingClientRect(),
          height = _frame$getBoundingCli.height,
          width = _frame$getBoundingCli.width,
          top = _frame$getBoundingCli.top,
          right = _frame$getBoundingCli.right,
          bottom = _frame$getBoundingCli.bottom,
          left = _frame$getBoundingCli.left;

      if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= top && targetBottom <= bottom && targetLeft >= left && targetRight <= right) {
        return computations;
      }

      var frameStyle = getComputedStyle(frame);
      var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
      var borderTop = parseInt(frameStyle.borderTopWidth, 10);
      var borderRight = parseInt(frameStyle.borderRightWidth, 10);
      var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
      var blockScroll = 0;
      var inlineScroll = 0;
      var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;
      var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;

      if (scrollingElement === frame) {
        if (block === 'start') {
          blockScroll = targetBlock;
        } else if (block === 'end') {
          blockScroll = targetBlock - viewportHeight;
        } else if (block === 'nearest') {
          blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
        } else {
          blockScroll = targetBlock - viewportHeight / 2;
        }

        if (inline === 'start') {
          inlineScroll = targetInline;
        } else if (inline === 'center') {
          inlineScroll = targetInline - viewportWidth / 2;
        } else if (inline === 'end') {
          inlineScroll = targetInline - viewportWidth;
        } else {
          inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
        }

        blockScroll = Math.max(0, blockScroll + viewportY);
        inlineScroll = Math.max(0, inlineScroll + viewportX);
      } else {
        if (block === 'start') {
          blockScroll = targetBlock - top - borderTop;
        } else if (block === 'end') {
          blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
        } else if (block === 'nearest') {
          blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
        } else {
          blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
        }

        if (inline === 'start') {
          inlineScroll = targetInline - left - borderLeft;
        } else if (inline === 'center') {
          inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
        } else if (inline === 'end') {
          inlineScroll = targetInline - right + borderRight + scrollbarWidth;
        } else {
          inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
        }

        var scrollLeft = frame.scrollLeft,
            scrollTop = frame.scrollTop;
        blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - height + scrollbarHeight));
        inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - width + scrollbarWidth));
        targetBlock += scrollTop - blockScroll;
        targetInline += scrollLeft - inlineScroll;
      }

      computations.push({
        el: frame,
        top: blockScroll,
        left: inlineScroll
      });
    }

    return computations;
  });

  var idCounter = 0;
  /**
   * Accepts a parameter and returns it if it's a function
   * or a noop function if it's not. This allows us to
   * accept a callback, but not worry about it if it's not
   * passed.
   * @param {Function} cb the callback
   * @return {Function} a function
   */

  function cbToCb(cb) {
    return typeof cb === 'function' ? cb : noop;
  }

  function noop() {}
  /**
   * Scroll node into view if necessary
   * @param {HTMLElement} node the element that should scroll into view
   * @param {HTMLElement} menuNode the menu element of the component
   */


  function scrollIntoView(node, menuNode) {
    if (node === null) {
      return;
    }

    var actions = computeScrollIntoView(node, {
      boundary: menuNode,
      block: 'nearest',
      scrollMode: 'if-needed'
    });
    actions.forEach(function (_ref) {
      var el = _ref.el,
          top = _ref.top,
          left = _ref.left;
      el.scrollTop = top;
      el.scrollLeft = left;
    });
  }
  /**
   * @param {HTMLElement} parent the parent node
   * @param {HTMLElement} child the child node
   * @return {Boolean} whether the parent is the child or the child is in the parent
   */


  function isOrContainsNode(parent, child) {
    return parent === child || parent.contains && parent.contains(child);
  }
  /**
   * Simple debounce implementation. Will call the given
   * function once after the time given has passed since
   * it was last called.
   * @param {Function} fn the function to call after the time
   * @param {Number} time the time to wait
   * @return {Function} the debounced function
   */


  function debounce$1(fn, time) {
    var timeoutId;

    function cancel() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    }

    function wrapper() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      cancel();
      timeoutId = setTimeout(function () {
        timeoutId = null;
        fn.apply(void 0, args);
      }, time);
    }

    wrapper.cancel = cancel;
    return wrapper;
  }
  /**
   * This is intended to be used to compose event handlers.
   * They are executed in order until one of them sets
   * `event.preventDownshiftDefault = true`.
   * @param {...Function} fns the event handler functions
   * @return {Function} the event handler to add to an element
   */


  function callAllEventHandlers() {
    for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      fns[_key2] = arguments[_key2];
    }

    return function (event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return fns.some(function (fn) {
        if (fn) {
          fn.apply(void 0, [event].concat(args));
        }

        return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;
      });
    };
  }

  function handleRefs() {
    for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      refs[_key4] = arguments[_key4];
    }

    return function (node) {
      refs.forEach(function (ref) {
        if (typeof ref === 'function') {
          ref(node);
        } else if (ref) {
          ref.current = node;
        }
      });
    };
  }
  /**
   * This generates a unique ID for an instance of Downshift
   * @return {String} the unique ID
   */


  function generateId() {
    return String(idCounter++);
  }
  /**
   * Default implementation for status message. Only added when menu is open.
   * Will specift if there are results in the list, and if so, how many,
   * and what keys are relevant.
   *
   * @param {Object} param the downshift state and other relevant properties
   * @return {String} the a11y status message
   */


  function getA11yStatusMessage(_ref2) {
    var isOpen = _ref2.isOpen,
        resultCount = _ref2.resultCount,
        previousResultCount = _ref2.previousResultCount;

    if (!isOpen) {
      return '';
    }

    if (!resultCount) {
      return 'No results are available.';
    }

    if (resultCount !== previousResultCount) {
      return resultCount + " result" + (resultCount === 1 ? ' is' : 's are') + " available, use up and down arrow keys to navigate. Press Enter key to select.";
    }

    return '';
  }
  /**
   * Takes an argument and if it's an array, returns the first item in the array
   * otherwise returns the argument
   * @param {*} arg the maybe-array
   * @param {*} defaultValue the value if arg is falsey not defined
   * @return {*} the arg or it's first item
   */


  function unwrapArray(arg, defaultValue) {
    arg = Array.isArray(arg) ?
    /* istanbul ignore next (preact) */
    arg[0] : arg;

    if (!arg && defaultValue) {
      return defaultValue;
    } else {
      return arg;
    }
  }
  /**
   * @param {Object} element (P)react element
   * @return {Boolean} whether it's a DOM element
   */


  function isDOMElement(element) {
    // then we assume this is react
    return typeof element.type === 'string';
  }
  /**
   * @param {Object} element (P)react element
   * @return {Object} the props
   */


  function getElementProps(element) {
    return element.props;
  }
  /**
   * Throws a helpful error message for required properties. Useful
   * to be used as a default in destructuring or object params.
   * @param {String} fnName the function name
   * @param {String} propName the prop name
   */


  function requiredProp(fnName, propName) {
    // eslint-disable-next-line no-console
    console.error("The property \"" + propName + "\" is required in \"" + fnName + "\"");
  }

  var stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];
  /**
   * @param {Object} state the state object
   * @return {Object} state that is relevant to downshift
   */

  function pickState(state) {
    if (state === void 0) {
      state = {};
    }

    var result = {};
    stateKeys.forEach(function (k) {
      if (state.hasOwnProperty(k)) {
        result[k] = state[k];
      }
    });
    return result;
  }
  /**
   * This will perform a shallow merge of the given state object
   * with the state coming from props
   * (for the controlled component scenario)
   * This is used in state updater functions so they're referencing
   * the right state regardless of where it comes from.
   *
   * @param {Object} state The state of the component/hook.
   * @param {Object} props The props that may contain controlled values.
   * @returns {Object} The merged controlled state.
   */


  function getState(state, props) {
    return Object.keys(state).reduce(function (prevState, key) {
      prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
      return prevState;
    }, {});
  }
  /**
   * This determines whether a prop is a "controlled prop" meaning it is
   * state which is controlled by the outside of this component rather
   * than within this component.
   *
   * @param {Object} props The props that may contain controlled values.
   * @param {String} key the key to check
   * @return {Boolean} whether it is a controlled controlled prop
   */


  function isControlledProp(props, key) {
    return props[key] !== undefined;
  }
  /**
   * Normalizes the 'key' property of a KeyboardEvent in IE/Edge
   * @param {Object} event a keyboardEvent object
   * @return {String} keyboard key
   */


  function normalizeArrowKey(event) {
    var key = event.key,
        keyCode = event.keyCode;
    /* istanbul ignore next (ie) */

    if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {
      return "Arrow" + key;
    }

    return key;
  }
  /**
   * Simple check if the value passed is object literal
   * @param {*} obj any things
   * @return {Boolean} whether it's object literal
   */


  function isPlainObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  }
  /**
   * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,
   * it will wrap to either 0 or itemCount - 1.
   *
   * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
   * @param {number} baseIndex The initial position to move from.
   * @param {number} itemCount The total number of items.
   * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
   * @param {boolean} circular Specify if navigation is circular. Default is true.
   * @returns {number} The new index after the move.
   */


  function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
    if (circular === void 0) {
      circular = true;
    }

    var itemsLastIndex = itemCount - 1;

    if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {
      baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
    }

    var newIndex = baseIndex + moveAmount;

    if (newIndex < 0) {
      newIndex = circular ? itemsLastIndex : 0;
    } else if (newIndex > itemsLastIndex) {
      newIndex = circular ? 0 : itemsLastIndex;
    }

    var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
    return nonDisabledNewIndex === -1 ? baseIndex : nonDisabledNewIndex;
  }
  /**
   * Returns the next index in the list of an item that is not disabled.
   *
   * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
   * @param {number} baseIndex The initial position to move from.
   * @param {number} itemCount The total number of items.
   * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
   * @param {boolean} circular Specify if navigation is circular. Default is true.
   * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.
   */


  function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
    var currentElementNode = getItemNodeFromIndex(baseIndex);

    if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {
      return baseIndex;
    }

    if (moveAmount > 0) {
      for (var index = baseIndex + 1; index < itemCount; index++) {
        if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {
          return index;
        }
      }
    } else {
      for (var _index = baseIndex - 1; _index >= 0; _index--) {
        if (!getItemNodeFromIndex(_index).hasAttribute('disabled')) {
          return _index;
        }
      }
    }

    if (circular) {
      return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
    }

    return -1;
  }
  /**
   * Checks if event target is within the downshift elements.
   *
   * @param {EventTarget} target Target to check.
   * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).
   * @param {Document} document The document.
   * @param {boolean} checkActiveElement Whether to also check activeElement.
   *
   * @returns {boolean} Whether or not the target is within downshift elements.
   */


  function targetWithinDownshift(target, downshiftElements, document, checkActiveElement) {
    if (checkActiveElement === void 0) {
      checkActiveElement = true;
    }

    return downshiftElements.some(function (contextNode) {
      return contextNode && (isOrContainsNode(contextNode, target) || checkActiveElement && isOrContainsNode(contextNode, document.activeElement));
    });
  }

  var cleanupStatus = debounce$1(function () {
    getStatusDiv().textContent = '';
  }, 500);
  /**
   * @param {String} status the status message
   * @param {Object} documentProp document passed by the user.
   */

  function setStatus(status, documentProp) {
    var div = getStatusDiv(documentProp);

    if (!status) {
      return;
    }

    div.textContent = status;
    cleanupStatus();
  }
  /**
   * Get the status node or create it if it does not already exist.
   * @param {Object} documentProp document passed by the user.
   * @return {HTMLElement} the status node.
   */


  function getStatusDiv(documentProp) {
    if (documentProp === void 0) {
      documentProp = document;
    }

    var statusDiv = documentProp.getElementById('a11y-status-message');

    if (statusDiv) {
      return statusDiv;
    }

    statusDiv = documentProp.createElement('div');
    statusDiv.setAttribute('id', 'a11y-status-message');
    statusDiv.setAttribute('role', 'status');
    statusDiv.setAttribute('aria-live', 'polite');
    statusDiv.setAttribute('aria-relevant', 'additions text');
    Object.assign(statusDiv.style, {
      border: '0',
      clip: 'rect(0 0 0 0)',
      height: '1px',
      margin: '-1px',
      overflow: 'hidden',
      padding: '0',
      position: 'absolute',
      width: '1px'
    });
    documentProp.body.appendChild(statusDiv);
    return statusDiv;
  }

  var unknown =  '__autocomplete_unknown__' ;
  var mouseUp =  '__autocomplete_mouseup__' ;
  var itemMouseEnter =  '__autocomplete_item_mouseenter__' ;
  var keyDownArrowUp =  '__autocomplete_keydown_arrow_up__' ;
  var keyDownArrowDown =  '__autocomplete_keydown_arrow_down__' ;
  var keyDownEscape =  '__autocomplete_keydown_escape__' ;
  var keyDownEnter =  '__autocomplete_keydown_enter__' ;
  var keyDownHome =  '__autocomplete_keydown_home__' ;
  var keyDownEnd =  '__autocomplete_keydown_end__' ;
  var clickItem =  '__autocomplete_click_item__' ;
  var blurInput =  '__autocomplete_blur_input__' ;
  var changeInput =  '__autocomplete_change_input__' ;
  var keyDownSpaceButton =  '__autocomplete_keydown_space_button__' ;
  var clickButton =  '__autocomplete_click_button__' ;
  var blurButton =  '__autocomplete_blur_button__' ;
  var controlledPropUpdatedSelectedItem =  '__autocomplete_controlled_prop_updated_selected_item__' ;
  var touchEnd =  '__autocomplete_touchend__' ;
  var stateChangeTypes$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    unknown: unknown,
    mouseUp: mouseUp,
    itemMouseEnter: itemMouseEnter,
    keyDownArrowUp: keyDownArrowUp,
    keyDownArrowDown: keyDownArrowDown,
    keyDownEscape: keyDownEscape,
    keyDownEnter: keyDownEnter,
    keyDownHome: keyDownHome,
    keyDownEnd: keyDownEnd,
    clickItem: clickItem,
    blurInput: blurInput,
    changeInput: changeInput,
    keyDownSpaceButton: keyDownSpaceButton,
    clickButton: clickButton,
    blurButton: blurButton,
    controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,
    touchEnd: touchEnd
  });

  var Downshift = /*#__PURE__*/function () {
    var Downshift = /*#__PURE__*/function (_Component) {
      _inheritsLoose(Downshift, _Component);

      function Downshift(_props) {
        var _this = _Component.call(this, _props) || this;

        _this.id = _this.props.id || "downshift-" + generateId();
        _this.menuId = _this.props.menuId || _this.id + "-menu";
        _this.labelId = _this.props.labelId || _this.id + "-label";
        _this.inputId = _this.props.inputId || _this.id + "-input";

        _this.getItemId = _this.props.getItemId || function (index) {
          return _this.id + "-item-" + index;
        };

        _this.input = null;
        _this.items = [];
        _this.itemCount = null;
        _this.previousResultCount = 0;
        _this.timeoutIds = [];

        _this.internalSetTimeout = function (fn, time) {
          var id = setTimeout(function () {
            _this.timeoutIds = _this.timeoutIds.filter(function (i) {
              return i !== id;
            });
            fn();
          }, time);

          _this.timeoutIds.push(id);
        };

        _this.setItemCount = function (count) {
          _this.itemCount = count;
        };

        _this.unsetItemCount = function () {
          _this.itemCount = null;
        };

        _this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {
          if (highlightedIndex === void 0) {
            highlightedIndex = _this.props.defaultHighlightedIndex;
          }

          if (otherStateToSet === void 0) {
            otherStateToSet = {};
          }

          otherStateToSet = pickState(otherStateToSet);

          _this.internalSetState(_extends$3({
            highlightedIndex: highlightedIndex
          }, otherStateToSet));
        };

        _this.clearSelection = function (cb) {
          _this.internalSetState({
            selectedItem: null,
            inputValue: '',
            highlightedIndex: _this.props.defaultHighlightedIndex,
            isOpen: _this.props.defaultIsOpen
          }, cb);
        };

        _this.selectItem = function (item, otherStateToSet, cb) {
          otherStateToSet = pickState(otherStateToSet);

          _this.internalSetState(_extends$3({
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            selectedItem: item,
            inputValue: _this.props.itemToString(item)
          }, otherStateToSet), cb);
        };

        _this.selectItemAtIndex = function (itemIndex, otherStateToSet, cb) {
          var item = _this.items[itemIndex];

          if (item == null) {
            return;
          }

          _this.selectItem(item, otherStateToSet, cb);
        };

        _this.selectHighlightedItem = function (otherStateToSet, cb) {
          return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
        };

        _this.internalSetState = function (stateToSet, cb) {
          var isItemSelected, onChangeArg;
          var onStateChangeArg = {};
          var isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call
          // so someone controlling the `inputValue` state gets notified of
          // the input change as soon as possible. This avoids issues with
          // preserving the cursor position.
          // See https://github.com/downshift-js/downshift/issues/217 for more info.

          if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {
            _this.props.onInputValueChange(stateToSet.inputValue, _extends$3({}, _this.getStateAndHelpers(), {}, stateToSet));
          }

          return _this.setState(function (state) {
            state = _this.getState(state);
            var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.

            newStateToSet = _this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from
            // what was selected before
            // used to determine if onSelect and onChange callbacks should be called

            isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState

            var nextState = {}; // this is just used to tell whether the state changed

            var nextFullState = {}; // we need to call on change if the outside world is controlling any of our state
            // and we're trying to update that state. OR if the selection has changed and we're
            // trying to update the selection

            if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
              onChangeArg = newStateToSet.selectedItem;
            }

            newStateToSet.type = newStateToSet.type || unknown;
            Object.keys(newStateToSet).forEach(function (key) {
              // onStateChangeArg should only have the state that is
              // actually changing
              if (state[key] !== newStateToSet[key]) {
                onStateChangeArg[key] = newStateToSet[key];
              } // the type is useful for the onStateChangeArg
              // but we don't actually want to set it in internal state.
              // this is an undocumented feature for now... Not all internalSetState
              // calls support it and I'm not certain we want them to yet.
              // But it enables users controlling the isOpen state to know when
              // the isOpen state changes due to mouseup events which is quite handy.


              if (key === 'type') {
                return;
              }

              nextFullState[key] = newStateToSet[key]; // if it's coming from props, then we don't care to set it internally

              if (!isControlledProp(_this.props, key)) {
                nextState[key] = newStateToSet[key];
              }
            }); // if stateToSet is a function, then we weren't able to call onInputValueChange
            // earlier, so we'll call it now that we know what the inputValue state will be.

            if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {
              _this.props.onInputValueChange(newStateToSet.inputValue, _extends$3({}, _this.getStateAndHelpers(), {}, newStateToSet));
            }

            return nextState;
          }, function () {
            // call the provided callback if it's a function
            cbToCb(cb)(); // only call the onStateChange and onChange callbacks if
            // we have relevant information to pass them.

            var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;

            if (hasMoreStateThanType) {
              _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
            }

            if (isItemSelected) {
              _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
            }

            if (onChangeArg !== undefined) {
              _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
            } // this is currently undocumented and therefore subject to change
            // We'll try to not break it, but just be warned.


            _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
          });
        };

        _this.rootRef = function (node) {
          return _this._rootNode = node;
        };

        _this.getRootProps = function (_temp, _temp2) {
          var _extends2;

          var _ref = _temp === void 0 ? {} : _temp,
              _ref$refKey = _ref.refKey,
              refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
              ref = _ref.ref,
              rest = _objectWithoutPropertiesLoose$3(_ref, ["refKey", "ref"]);

          var _ref2 = _temp2 === void 0 ? {} : _temp2,
              _ref2$suppressRefErro = _ref2.suppressRefError,
              suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro; // this is used in the render to know whether the user has called getRootProps.
          // It uses that to know whether to apply the props automatically


          _this.getRootProps.called = true;
          _this.getRootProps.refKey = refKey;
          _this.getRootProps.suppressRefError = suppressRefError;

          var _this$getState = _this.getState(),
              isOpen = _this$getState.isOpen;

          return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref, _this.rootRef), _extends2.role = 'combobox', _extends2['aria-expanded'] = isOpen, _extends2['aria-haspopup'] = 'listbox', _extends2['aria-owns'] = isOpen ? _this.menuId : null, _extends2['aria-labelledby'] = _this.labelId, _extends2), rest);
        };

        _this.keyDownHandlers = {
          ArrowDown: function ArrowDown(event) {
            var _this2 = this;

            event.preventDefault();

            if (this.getState().isOpen) {
              var amount = event.shiftKey ? 5 : 1;
              this.moveHighlightedIndex(amount, {
                type: keyDownArrowDown
              });
            } else {
              this.internalSetState({
                isOpen: true,
                type: keyDownArrowDown
              }, function () {
                var itemCount = _this2.getItemCount();

                if (itemCount > 0) {
                  var _this2$getState = _this2.getState(),
                      highlightedIndex = _this2$getState.highlightedIndex;

                  var nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, function (index) {
                    return _this2.getItemNodeFromIndex(index);
                  });

                  _this2.setHighlightedIndex(nextHighlightedIndex, {
                    type: keyDownArrowDown
                  });
                }
              });
            }
          },
          ArrowUp: function ArrowUp(event) {
            var _this3 = this;

            event.preventDefault();

            if (this.getState().isOpen) {
              var amount = event.shiftKey ? -5 : -1;
              this.moveHighlightedIndex(amount, {
                type: keyDownArrowUp
              });
            } else {
              this.internalSetState({
                isOpen: true,
                type: keyDownArrowUp
              }, function () {
                var itemCount = _this3.getItemCount();

                if (itemCount > 0) {
                  var _this3$getState = _this3.getState(),
                      highlightedIndex = _this3$getState.highlightedIndex;

                  var nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, function (index) {
                    return _this3.getItemNodeFromIndex(index);
                  });

                  _this3.setHighlightedIndex(nextHighlightedIndex, {
                    type: keyDownArrowUp
                  });
                }
              });
            }
          },
          Enter: function Enter(event) {
            if (event.which === 229) {
              return;
            }

            var _this$getState2 = this.getState(),
                isOpen = _this$getState2.isOpen,
                highlightedIndex = _this$getState2.highlightedIndex;

            if (isOpen && highlightedIndex != null) {
              event.preventDefault();
              var item = this.items[highlightedIndex];
              var itemNode = this.getItemNodeFromIndex(highlightedIndex);

              if (item == null || itemNode && itemNode.hasAttribute('disabled')) {
                return;
              }

              this.selectHighlightedItem({
                type: keyDownEnter
              });
            }
          },
          Escape: function Escape(event) {
            event.preventDefault();
            this.reset({
              type: keyDownEscape,
              selectedItem: null,
              inputValue: ''
            });
          }
        };
        _this.buttonKeyDownHandlers = _extends$3({}, _this.keyDownHandlers, {
          ' ': function _(event) {
            event.preventDefault();
            this.toggleMenu({
              type: keyDownSpaceButton
            });
          }
        });
        _this.inputKeyDownHandlers = _extends$3({}, _this.keyDownHandlers, {
          Home: function Home(event) {
            var _this4 = this;

            event.preventDefault();
            var itemCount = this.getItemCount();

            var _this$getState3 = this.getState(),
                isOpen = _this$getState3.isOpen;

            if (itemCount <= 0 || !isOpen) {
              return;
            } // get next non-disabled starting downwards from 0 if that's disabled.


            var newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, function (index) {
              return _this4.getItemNodeFromIndex(index);
            }, false);
            this.setHighlightedIndex(newHighlightedIndex, {
              type: keyDownHome
            });
          },
          End: function End(event) {
            var _this5 = this;

            event.preventDefault();
            var itemCount = this.getItemCount();

            var _this$getState4 = this.getState(),
                isOpen = _this$getState4.isOpen;

            if (itemCount <= 0 || !isOpen) {
              return;
            } // get next non-disabled starting upwards from last index if that's disabled.


            var newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, function (index) {
              return _this5.getItemNodeFromIndex(index);
            }, false);
            this.setHighlightedIndex(newHighlightedIndex, {
              type: keyDownEnd
            });
          }
        });

        _this.getToggleButtonProps = function (_temp3) {
          var _ref3 = _temp3 === void 0 ? {} : _temp3,
              onClick = _ref3.onClick,
              onPress = _ref3.onPress,
              onKeyDown = _ref3.onKeyDown,
              onKeyUp = _ref3.onKeyUp,
              onBlur = _ref3.onBlur,
              rest = _objectWithoutPropertiesLoose$3(_ref3, ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"]);

          var _this$getState5 = _this.getState(),
              isOpen = _this$getState5.isOpen;

          var enabledEventHandlers = {
            onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
            onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
            onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
            onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
          };
          var eventHandlers = rest.disabled ? {} : enabledEventHandlers;
          return _extends$3({
            type: 'button',
            role: 'button',
            'aria-label': isOpen ? 'close menu' : 'open menu',
            'aria-haspopup': true,
            'data-toggle': true
          }, eventHandlers, {}, rest);
        };

        _this.buttonHandleKeyUp = function (event) {
          // Prevent click event from emitting in Firefox
          event.preventDefault();
        };

        _this.buttonHandleKeyDown = function (event) {
          var key = normalizeArrowKey(event);

          if (_this.buttonKeyDownHandlers[key]) {
            _this.buttonKeyDownHandlers[key].call(_assertThisInitialized$E(_this), event);
          }
        };

        _this.buttonHandleClick = function (event) {
          event.preventDefault(); // handle odd case for Safari and Firefox which
          // don't give the button the focus properly.

          /* istanbul ignore if (can't reasonably test this) */

          if (_this.props.environment.document.activeElement === _this.props.environment.document.body) {
            event.target.focus();
          } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout
          // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated
          // when building for production and should therefore have no impact on production code.


          {
            // Ensure that toggle of menu occurs after the potential blur event in iOS
            _this.internalSetTimeout(function () {
              return _this.toggleMenu({
                type: clickButton
              });
            });
          }
        };

        _this.buttonHandleBlur = function (event) {
          var blurTarget = event.target; // Save blur target for comparison with activeElement later
          // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element

          _this.internalSetTimeout(function () {
            if (!_this.isMouseDown && (_this.props.environment.document.activeElement == null || _this.props.environment.document.activeElement.id !== _this.inputId) && _this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)
            ) {
                _this.reset({
                  type: blurButton
                });
              }
          });
        };

        _this.getLabelProps = function (props) {
          return _extends$3({
            htmlFor: _this.inputId,
            id: _this.labelId
          }, props);
        };

        _this.getInputProps = function (_temp4) {
          var _ref4 = _temp4 === void 0 ? {} : _temp4,
              onKeyDown = _ref4.onKeyDown,
              onBlur = _ref4.onBlur,
              onChange = _ref4.onChange,
              onInput = _ref4.onInput,
              onChangeText = _ref4.onChangeText,
              rest = _objectWithoutPropertiesLoose$3(_ref4, ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"]);

          var onChangeKey;
          var eventHandlers = {};
          /* istanbul ignore next (preact) */

          onChangeKey = 'onChange';

          var _this$getState6 = _this.getState(),
              inputValue = _this$getState6.inputValue,
              isOpen = _this$getState6.isOpen,
              highlightedIndex = _this$getState6.highlightedIndex;

          if (!rest.disabled) {
            var _eventHandlers;

            eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.inputHandleBlur), _eventHandlers);
          }
          /* istanbul ignore if (react-native) */


          return _extends$3({
            'aria-autocomplete': 'list',
            'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,
            'aria-controls': isOpen ? _this.menuId : null,
            'aria-labelledby': _this.labelId,
            // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
            // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
            autoComplete: 'off',
            value: inputValue,
            id: _this.inputId
          }, eventHandlers, {}, rest);
        };

        _this.inputHandleKeyDown = function (event) {
          var key = normalizeArrowKey(event);

          if (key && _this.inputKeyDownHandlers[key]) {
            _this.inputKeyDownHandlers[key].call(_assertThisInitialized$E(_this), event);
          }
        };

        _this.inputHandleChange = function (event) {
          _this.internalSetState({
            type: changeInput,
            isOpen: true,
            inputValue: event.target.value,
            highlightedIndex: _this.props.defaultHighlightedIndex
          });
        };

        _this.inputHandleBlur = function () {
          // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element
          _this.internalSetTimeout(function () {
            var downshiftButtonIsActive = _this.props.environment.document && !!_this.props.environment.document.activeElement && !!_this.props.environment.document.activeElement.dataset && _this.props.environment.document.activeElement.dataset.toggle && _this._rootNode && _this._rootNode.contains(_this.props.environment.document.activeElement);

            if (!_this.isMouseDown && !downshiftButtonIsActive) {
              _this.reset({
                type: blurInput
              });
            }
          });
        };

        _this.menuRef = function (node) {
          _this._menuNode = node;
        };

        _this.getMenuProps = function (_temp5, _temp6) {
          var _extends3;

          var _ref5 = _temp5 === void 0 ? {} : _temp5,
              _ref5$refKey = _ref5.refKey,
              refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
              ref = _ref5.ref,
              props = _objectWithoutPropertiesLoose$3(_ref5, ["refKey", "ref"]);

          var _ref6 = _temp6 === void 0 ? {} : _temp6,
              _ref6$suppressRefErro = _ref6.suppressRefError,
              suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;

          _this.getMenuProps.called = true;
          _this.getMenuProps.refKey = refKey;
          _this.getMenuProps.suppressRefError = suppressRefError;
          return _extends$3((_extends3 = {}, _extends3[refKey] = handleRefs(ref, _this.menuRef), _extends3.role = 'listbox', _extends3['aria-labelledby'] = props && props['aria-label'] ? null : _this.labelId, _extends3.id = _this.menuId, _extends3), props);
        };

        _this.getItemProps = function (_temp7) {
          var _enabledEventHandlers;

          var _ref7 = _temp7 === void 0 ? {} : _temp7,
              onMouseMove = _ref7.onMouseMove,
              onMouseDown = _ref7.onMouseDown,
              onClick = _ref7.onClick,
              onPress = _ref7.onPress,
              index = _ref7.index,
              _ref7$item = _ref7.item,
              item = _ref7$item === void 0 ?  requiredProp('getItemProps', 'item') : _ref7$item,
              rest = _objectWithoutPropertiesLoose$3(_ref7, ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"]);

          if (index === undefined) {
            _this.items.push(item);

            index = _this.items.indexOf(item);
          } else {
            _this.items[index] = item;
          }

          var onSelectKey = 'onClick';
          var customClickHandler = onClick;
          var enabledEventHandlers = (_enabledEventHandlers = {
            // onMouseMove is used over onMouseEnter here. onMouseMove
            // is only triggered on actual mouse movement while onMouseEnter
            // can fire on DOM changes, interrupting keyboard navigation
            onMouseMove: callAllEventHandlers(onMouseMove, function () {
              if (index === _this.getState().highlightedIndex) {
                return;
              }

              _this.setHighlightedIndex(index, {
                type: itemMouseEnter
              }); // We never want to manually scroll when changing state based
              // on `onMouseMove` because we will be moving the element out
              // from under the user which is currently scrolling/moving the
              // cursor


              _this.avoidScrolling = true;

              _this.internalSetTimeout(function () {
                return _this.avoidScrolling = false;
              }, 250);
            }),
            onMouseDown: callAllEventHandlers(onMouseDown, function (event) {
              // This prevents the activeElement from being changed
              // to the item so it can remain with the current activeElement
              // which is a more common use case.
              event.preventDefault();
            })
          }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function () {
            _this.selectItemAtIndex(index, {
              type: clickItem
            });
          }), _enabledEventHandlers); // Passing down the onMouseDown handler to prevent redirect
          // of the activeElement if clicking on disabled items

          var eventHandlers = rest.disabled ? {
            onMouseDown: enabledEventHandlers.onMouseDown
          } : enabledEventHandlers;
          return _extends$3({
            id: _this.getItemId(index),
            role: 'option',
            'aria-selected': _this.getState().highlightedIndex === index
          }, eventHandlers, {}, rest);
        };

        _this.clearItems = function () {
          _this.items = [];
        };

        _this.reset = function (otherStateToSet, cb) {
          if (otherStateToSet === void 0) {
            otherStateToSet = {};
          }

          otherStateToSet = pickState(otherStateToSet);

          _this.internalSetState(function (_ref8) {
            var selectedItem = _ref8.selectedItem;
            return _extends$3({
              isOpen: _this.props.defaultIsOpen,
              highlightedIndex: _this.props.defaultHighlightedIndex,
              inputValue: _this.props.itemToString(selectedItem)
            }, otherStateToSet);
          }, cb);
        };

        _this.toggleMenu = function (otherStateToSet, cb) {
          if (otherStateToSet === void 0) {
            otherStateToSet = {};
          }

          otherStateToSet = pickState(otherStateToSet);

          _this.internalSetState(function (_ref9) {
            var isOpen = _ref9.isOpen;
            return _extends$3({
              isOpen: !isOpen
            }, isOpen && {
              highlightedIndex: _this.props.defaultHighlightedIndex
            }, {}, otherStateToSet);
          }, function () {
            var _this$getState7 = _this.getState(),
                isOpen = _this$getState7.isOpen,
                highlightedIndex = _this$getState7.highlightedIndex;

            if (isOpen) {
              if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {
                _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
              }
            }

            cbToCb(cb)();
          });
        };

        _this.openMenu = function (cb) {
          _this.internalSetState({
            isOpen: true
          }, cb);
        };

        _this.closeMenu = function (cb) {
          _this.internalSetState({
            isOpen: false
          }, cb);
        };

        _this.updateStatus = debounce$1(function () {
          var state = _this.getState();

          var item = _this.items[state.highlightedIndex];

          var resultCount = _this.getItemCount();

          var status = _this.props.getA11yStatusMessage(_extends$3({
            itemToString: _this.props.itemToString,
            previousResultCount: _this.previousResultCount,
            resultCount: resultCount,
            highlightedItem: item
          }, state));

          _this.previousResultCount = resultCount;
          setStatus(status, _this.props.environment.document);
        }, 200); // fancy destructuring + defaults + aliases
        // this basically says each value of state should either be set to
        // the initial value or the default value if the initial value is not provided

        var _this$props = _this.props,
            defaultHighlightedIndex = _this$props.defaultHighlightedIndex,
            _this$props$initialHi = _this$props.initialHighlightedIndex,
            _highlightedIndex = _this$props$initialHi === void 0 ? defaultHighlightedIndex : _this$props$initialHi,
            defaultIsOpen = _this$props.defaultIsOpen,
            _this$props$initialIs = _this$props.initialIsOpen,
            _isOpen = _this$props$initialIs === void 0 ? defaultIsOpen : _this$props$initialIs,
            _this$props$initialIn = _this$props.initialInputValue,
            _inputValue = _this$props$initialIn === void 0 ? '' : _this$props$initialIn,
            _this$props$initialSe = _this$props.initialSelectedItem,
            _selectedItem = _this$props$initialSe === void 0 ? null : _this$props$initialSe;

        var _state = _this.getState({
          highlightedIndex: _highlightedIndex,
          isOpen: _isOpen,
          inputValue: _inputValue,
          selectedItem: _selectedItem
        });

        if (_state.selectedItem != null && _this.props.initialInputValue === undefined) {
          _state.inputValue = _this.props.itemToString(_state.selectedItem);
        }

        _this.state = _state;
        return _this;
      }

      var _proto = Downshift.prototype;
      /**
       * Clear all running timeouts
       */

      _proto.internalClearTimeouts = function internalClearTimeouts() {
        this.timeoutIds.forEach(function (id) {
          clearTimeout(id);
        });
        this.timeoutIds = [];
      }
      /**
       * Gets the state based on internal state or props
       * If a state value is passed via props, then that
       * is the value given, otherwise it's retrieved from
       * stateToMerge
       *
       * @param {Object} stateToMerge defaults to this.state
       * @return {Object} the state
       */
      ;

      _proto.getState = function getState$1(stateToMerge) {
        if (stateToMerge === void 0) {
          stateToMerge = this.state;
        }

        return getState(stateToMerge, this.props);
      };

      _proto.getItemCount = function getItemCount() {
        // things read better this way. They're in priority order:
        // 1. `this.itemCount`
        // 2. `this.props.itemCount`
        // 3. `this.items.length`
        var itemCount = this.items.length;

        if (this.itemCount != null) {
          itemCount = this.itemCount;
        } else if (this.props.itemCount !== undefined) {
          itemCount = this.props.itemCount;
        }

        return itemCount;
      };

      _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index) {
        return this.props.environment.document.getElementById(this.getItemId(index));
      };

      _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
        /* istanbul ignore else (react-native) */
        {
          var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
          this.props.scrollIntoView(node, this._menuNode);
        }
      };

      _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
        var _this6 = this;

        var itemCount = this.getItemCount();

        var _this$getState8 = this.getState(),
            highlightedIndex = _this$getState8.highlightedIndex;

        if (itemCount > 0) {
          var nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, function (index) {
            return _this6.getItemNodeFromIndex(index);
          });
          this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
        }
      };

      _proto.getStateAndHelpers = function getStateAndHelpers() {
        var _this$getState9 = this.getState(),
            highlightedIndex = _this$getState9.highlightedIndex,
            inputValue = _this$getState9.inputValue,
            selectedItem = _this$getState9.selectedItem,
            isOpen = _this$getState9.isOpen;

        var itemToString = this.props.itemToString;
        var id = this.id;
        var getRootProps = this.getRootProps,
            getToggleButtonProps = this.getToggleButtonProps,
            getLabelProps = this.getLabelProps,
            getMenuProps = this.getMenuProps,
            getInputProps = this.getInputProps,
            getItemProps = this.getItemProps,
            openMenu = this.openMenu,
            closeMenu = this.closeMenu,
            toggleMenu = this.toggleMenu,
            selectItem = this.selectItem,
            selectItemAtIndex = this.selectItemAtIndex,
            selectHighlightedItem = this.selectHighlightedItem,
            setHighlightedIndex = this.setHighlightedIndex,
            clearSelection = this.clearSelection,
            clearItems = this.clearItems,
            reset = this.reset,
            setItemCount = this.setItemCount,
            unsetItemCount = this.unsetItemCount,
            setState = this.internalSetState;
        return {
          // prop getters
          getRootProps: getRootProps,
          getToggleButtonProps: getToggleButtonProps,
          getLabelProps: getLabelProps,
          getMenuProps: getMenuProps,
          getInputProps: getInputProps,
          getItemProps: getItemProps,
          // actions
          reset: reset,
          openMenu: openMenu,
          closeMenu: closeMenu,
          toggleMenu: toggleMenu,
          selectItem: selectItem,
          selectItemAtIndex: selectItemAtIndex,
          selectHighlightedItem: selectHighlightedItem,
          setHighlightedIndex: setHighlightedIndex,
          clearSelection: clearSelection,
          clearItems: clearItems,
          setItemCount: setItemCount,
          unsetItemCount: unsetItemCount,
          setState: setState,
          // props
          itemToString: itemToString,
          // derived
          id: id,
          // state
          highlightedIndex: highlightedIndex,
          inputValue: inputValue,
          isOpen: isOpen,
          selectedItem: selectedItem
        };
      } //////////////////////////// ROOT
      ;

      _proto.componentDidMount = function componentDidMount() {
        var _this7 = this;
        /* istanbul ignore if (react-native) */


        if ( this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
        }
        /* istanbul ignore if (react-native) */


        {
          // this.isMouseDown helps us track whether the mouse is currently held down.
          // This is useful when the user clicks on an item in the list, but holds the mouse
          // down long enough for the list to disappear (because the blur event fires on the input)
          // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should
          // trigger hiding the menu.
          var onMouseDown = function onMouseDown() {
            _this7.isMouseDown = true;
          };

          var onMouseUp = function onMouseUp(event) {
            _this7.isMouseDown = false; // if the target element or the activeElement is within a downshift node
            // then we don't want to reset downshift

            var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment.document);

            if (!contextWithinDownshift && _this7.getState().isOpen) {
              _this7.reset({
                type: mouseUp
              }, function () {
                return _this7.props.onOuterClick(_this7.getStateAndHelpers());
              });
            }
          }; // Touching an element in iOS gives focus and hover states, but touching out of
          // the element will remove hover, and persist the focus state, resulting in the
          // blur event not being triggered.
          // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.
          // If the user taps outside of Downshift, the component should be reset,
          // but not if the user is swiping


          var onTouchStart = function onTouchStart() {
            _this7.isTouchMove = false;
          };

          var onTouchMove = function onTouchMove() {
            _this7.isTouchMove = true;
          };

          var onTouchEnd = function onTouchEnd(event) {
            var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment.document, false);

            if (!_this7.isTouchMove && !contextWithinDownshift && _this7.getState().isOpen) {
              _this7.reset({
                type: touchEnd
              }, function () {
                return _this7.props.onOuterClick(_this7.getStateAndHelpers());
              });
            }
          };

          var environment = this.props.environment;
          environment.addEventListener('mousedown', onMouseDown);
          environment.addEventListener('mouseup', onMouseUp);
          environment.addEventListener('touchstart', onTouchStart);
          environment.addEventListener('touchmove', onTouchMove);
          environment.addEventListener('touchend', onTouchEnd);

          this.cleanup = function () {
            _this7.internalClearTimeouts();

            _this7.updateStatus.cancel();

            environment.removeEventListener('mousedown', onMouseDown);
            environment.removeEventListener('mouseup', onMouseUp);
            environment.removeEventListener('touchstart', onTouchStart);
            environment.removeEventListener('touchmove', onTouchMove);
            environment.removeEventListener('touchend', onTouchEnd);
          };
        }
      };

      _proto.shouldScroll = function shouldScroll(prevState, prevProps) {
        var _ref10 = this.props.highlightedIndex === undefined ? this.getState() : this.props,
            currentHighlightedIndex = _ref10.highlightedIndex;

        var _ref11 = prevProps.highlightedIndex === undefined ? prevState : prevProps,
            prevHighlightedIndex = _ref11.highlightedIndex;

        var scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
        return scrollWhenOpen || currentHighlightedIndex !== prevHighlightedIndex;
      };

      _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
        {
          validateControlledUnchanged(prevProps, this.props);
          /* istanbul ignore if (react-native) */

          if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
            validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
          }
        }

        if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
          this.internalSetState({
            type: controlledPropUpdatedSelectedItem,
            inputValue: this.props.itemToString(this.props.selectedItem)
          });
        }

        if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
          this.scrollHighlightedItemIntoView();
        }
        /* istanbul ignore else (react-native) */


        this.updateStatus();
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cleanup(); // avoids memory leak
      };

      _proto.render = function render() {
        var children = unwrapArray(this.props.children, noop); // because the items are rerendered every time we call the children
        // we clear this out each render and it will be populated again as
        // getItemProps is called.

        this.clearItems(); // we reset this so we know whether the user calls getRootProps during
        // this render. If they do then we don't need to do anything,
        // if they don't then we need to clone the element they return and
        // apply the props for them.

        this.getRootProps.called = false;
        this.getRootProps.refKey = undefined;
        this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps

        this.getMenuProps.called = false;
        this.getMenuProps.refKey = undefined;
        this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps

        this.getLabelProps.called = false; // and something similar for getInputProps

        this.getInputProps.called = false;
        var element = unwrapArray(children(this.getStateAndHelpers()));

        if (!element) {
          return null;
        }

        if (this.getRootProps.called || this.props.suppressRefError) {
          if ( !this.getRootProps.suppressRefError && !this.props.suppressRefError) {
            validateGetRootPropsCalledCorrectly(element, this.getRootProps);
          }

          return element;
        } else if (isDOMElement(element)) {
          // they didn't apply the root props, but we can clone
          // this and apply the props ourselves
          return /*#__PURE__*/React.cloneElement(element, this.getRootProps(getElementProps(element)));
        }
        /* istanbul ignore else */


        {
          // they didn't apply the root props, but they need to
          // otherwise we can't query around the autocomplete
          throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');
        }
      };

      return Downshift;
    }(React.Component);

    Downshift.defaultProps = {
      defaultHighlightedIndex: null,
      defaultIsOpen: false,
      getA11yStatusMessage: getA11yStatusMessage,
      itemToString: function itemToString(i) {
        if (i == null) {
          return '';
        }

        if ( isPlainObject(i) && !i.hasOwnProperty('toString')) {
          // eslint-disable-next-line no-console
          console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);
        }

        return String(i);
      },
      onStateChange: noop,
      onInputValueChange: noop,
      onUserAction: noop,
      onChange: noop,
      onSelect: noop,
      onOuterClick: noop,
      selectedItemChanged: function selectedItemChanged(prevItem, item) {
        return prevItem !== item;
      },
      environment: typeof window === 'undefined'
      /* istanbul ignore next (ssr) */
      ? {} : window,
      stateReducer: function stateReducer(state, stateToSet) {
        return stateToSet;
      },
      suppressRefError: false,
      scrollIntoView: scrollIntoView
    };
    Downshift.stateChangeTypes = stateChangeTypes$1;
    return Downshift;
  }();

   Downshift.propTypes = {
    children: PropTypes.func,
    defaultHighlightedIndex: PropTypes.number,
    defaultIsOpen: PropTypes.bool,
    initialHighlightedIndex: PropTypes.number,
    initialSelectedItem: PropTypes.any,
    initialInputValue: PropTypes.string,
    initialIsOpen: PropTypes.bool,
    getA11yStatusMessage: PropTypes.func,
    itemToString: PropTypes.func,
    onChange: PropTypes.func,
    onSelect: PropTypes.func,
    onStateChange: PropTypes.func,
    onInputValueChange: PropTypes.func,
    onUserAction: PropTypes.func,
    onOuterClick: PropTypes.func,
    selectedItemChanged: PropTypes.func,
    stateReducer: PropTypes.func,
    itemCount: PropTypes.number,
    id: PropTypes.string,
    environment: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func,
      document: PropTypes.shape({
        getElementById: PropTypes.func,
        activeElement: PropTypes.any,
        body: PropTypes.any
      })
    }),
    suppressRefError: PropTypes.bool,
    scrollIntoView: PropTypes.func,
    // things we keep in state for uncontrolled components
    // but can accept as props for controlled components

    /* eslint-disable react/no-unused-prop-types */
    selectedItem: PropTypes.any,
    isOpen: PropTypes.bool,
    inputValue: PropTypes.string,
    highlightedIndex: PropTypes.number,
    labelId: PropTypes.string,
    inputId: PropTypes.string,
    menuId: PropTypes.string,
    getItemId: PropTypes.func
    /* eslint-enable react/no-unused-prop-types */

  } ;

  function validateGetMenuPropsCalledCorrectly(node, _ref12) {
    var refKey = _ref12.refKey;

    if (!node) {
      // eslint-disable-next-line no-console
      console.error("downshift: The ref prop \"" + refKey + "\" from getMenuProps was not applied correctly on your menu element.");
    }
  }

  function validateGetRootPropsCalledCorrectly(element, _ref13) {
    var refKey = _ref13.refKey;
    var refKeySpecified = refKey !== 'ref';
    var isComposite = !isDOMElement(element);

    if (isComposite && !refKeySpecified && !reactIs_1(element)) {
      // eslint-disable-next-line no-console
      console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');
    } else if (!isComposite && refKeySpecified) {
      // eslint-disable-next-line no-console
      console.error("downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"" + refKey + "\"");
    }

    if (!reactIs_1(element) && !getElementProps(element)[refKey]) {
      // eslint-disable-next-line no-console
      console.error("downshift: You must apply the ref prop \"" + refKey + "\" from getRootProps onto your root element.");
    }
  }

  function validateControlledUnchanged(prevProps, nextProps) {
    var warningDescription = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props";
    ['selectedItem', 'isOpen', 'inputValue', 'highlightedIndex'].forEach(function (propKey) {
      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {
        // eslint-disable-next-line no-console
        console.error("downshift: A component has changed the controlled prop \"" + propKey + "\" to be uncontrolled. " + warningDescription);
      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {
        // eslint-disable-next-line no-console
        console.error("downshift: A component has changed the uncontrolled prop \"" + propKey + "\" to be controlled. " + warningDescription);
      }
    });
  }

  var dropdownDefaultStateValues = {
    highlightedIndex: -1,
    isOpen: false,
    selectedItem: null,
    inputValue: ''
  };

  function callOnChangeProps(action, state, newState) {
    var props = action.props,
        type = action.type;
    var changes = {};
    Object.keys(state).forEach(function (key) {
      invokeOnChangeHandler(key, props, state, newState);

      if (newState[key] !== state[key]) {
        changes[key] = newState[key];
      }
    });

    if (props.onStateChange && Object.keys(changes).length) {
      props.onStateChange(_extends$3({
        type: type
      }, changes));
    }
  }

  function invokeOnChangeHandler(key, props, state, newState) {
    var handler = "on" + capitalizeString(key) + "Change";

    if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {
      props[handler](newState);
    }
  }
  /**
   * Default state reducer that returns the changes.
   *
   * @param {Object} s state.
   * @param {Object} a action with changes.
   * @returns {Object} changes.
   */


  function stateReducer(s, a) {
    return a.changes;
  }
  /**
   * Returns a message to be added to aria-live region when item is selected.
   *
   * @param {Object} selectionParameters Parameters required to build the message.
   * @returns {string} The a11y message.
   */


  function getA11ySelectionMessage(selectionParameters) {
    var selectedItem = selectionParameters.selectedItem,
        itemToStringLocal = selectionParameters.itemToString;
    return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : '';
  }
  /**
   * Debounced call for updating the a11y message.
   */


  var updateA11yStatus = debounce$1(function (getA11yMessage, document) {
    setStatus(getA11yMessage(), document);
  }, 200);

  function getElementIds(_ref) {
    var id = _ref.id,
        labelId = _ref.labelId,
        menuId = _ref.menuId,
        getItemId = _ref.getItemId,
        toggleButtonId = _ref.toggleButtonId;
    var uniqueId = id === undefined ? "downshift-" + generateId() : id;
    return {
      labelId: labelId || uniqueId + "-label",
      menuId: menuId || uniqueId + "-menu",
      getItemId: getItemId || function (index) {
        return uniqueId + "-item-" + index;
      },
      toggleButtonId: toggleButtonId || uniqueId + "-toggle-button"
    };
  }

  function getItemIndex(index, item, items) {
    if (index !== undefined) {
      return index;
    }

    if (items.length === 0) {
      return -1;
    }

    return items.indexOf(item);
  }

  function itemToString(item) {
    return item ? String(item) : '';
  }

  function getPropTypesValidator(caller, propTypes) {
    // istanbul ignore next
    return function (options) {
      if (options === void 0) {
        options = {};
      }

      Object.keys(propTypes).forEach(function (key) {
        PropTypes.checkPropTypes(propTypes, options, key, caller.name);
      });
    };
  }

  function isAcceptedCharacterKey(key) {
    return /^\S{1}$/.test(key);
  }

  function capitalizeString(string) {
    return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
  }
  /**
   * Computes the controlled state using a the previous state, props,
   * two reducers, one from downshift and an optional one from the user.
   * Also calls the onChange handlers for state values that have changed.
   *
   * @param {Function} reducer Reducer function from downshift.
   * @param {Object} initialState Initial state of the hook.
   * @param {Object} props The hook props.
   * @returns {Array} An array with the state and an action dispatcher.
   */


  function useControlledState(reducer, initialState, props) {
    var _useState = React.useState(initialState),
        uncontrolledState = _useState[0],
        setState = _useState[1];

    var state = getState(uncontrolledState, props);

    var dispatch = function dispatch(action) {
      var stateReducerFromProps = action.props.stateReducer;
      var changes = reducer(state, action);
      var newState = stateReducerFromProps(state, _extends$3({}, action, {
        changes: changes
      }));
      callOnChangeProps(action, state, newState);
      setState(newState);
    };

    return [getState(state, props), function dispatchWithProps(action) {
      return dispatch(_extends$3({
        props: props
      }, action));
    }];
  }

  var defaultProps = {
    itemToString: itemToString,
    stateReducer: stateReducer,
    getA11ySelectionMessage: getA11ySelectionMessage,
    scrollIntoView: scrollIntoView,
    circularNavigation: false,
    environment: typeof window === 'undefined'
    /* istanbul ignore next (ssr) */
    ? {} : window
  };

  function getDefaultValue(props, propKey, defaultStateValues) {
    if (defaultStateValues === void 0) {
      defaultStateValues = dropdownDefaultStateValues;
    }

    var defaultPropKey = "default" + capitalizeString(propKey);

    if (defaultPropKey in props) {
      return props[defaultPropKey];
    }

    return defaultStateValues[propKey];
  }

  function getInitialValue(props, propKey, defaultStateValues) {
    if (defaultStateValues === void 0) {
      defaultStateValues = dropdownDefaultStateValues;
    }

    if (propKey in props) {
      return props[propKey];
    }

    var initialPropKey = "initial" + capitalizeString(propKey);

    if (initialPropKey in props) {
      return props[initialPropKey];
    }

    return getDefaultValue(props, propKey, defaultStateValues);
  }

  function getInitialState(props) {
    var selectedItem = getInitialValue(props, 'selectedItem');
    var isOpen = getInitialValue(props, 'isOpen');
    var highlightedIndex = getInitialValue(props, 'highlightedIndex');
    var inputValue = getInitialValue(props, 'inputValue');
    return {
      highlightedIndex: highlightedIndex < 0 && selectedItem ? props.items.indexOf(selectedItem) : highlightedIndex,
      isOpen: isOpen,
      selectedItem: selectedItem,
      inputValue: inputValue
    };
  }

  function getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {
    var items = props.items,
        initialHighlightedIndex = props.initialHighlightedIndex,
        defaultHighlightedIndex = props.defaultHighlightedIndex;
    var selectedItem = state.selectedItem,
        highlightedIndex = state.highlightedIndex; // initialHighlightedIndex will give value to highlightedIndex on initial state only.

    if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {
      return initialHighlightedIndex;
    }

    if (defaultHighlightedIndex !== undefined) {
      return defaultHighlightedIndex;
    }

    if (selectedItem) {
      if (offset === 0) {
        return items.indexOf(selectedItem);
      }

      return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);
    }

    if (offset === 0) {
      return -1;
    }

    return offset < 0 ? items.length - 1 : 0;
  }

  function getItemIndexByCharacterKey(keysSoFar, highlightedIndex, items, itemToStringParam, getItemNodeFromIndex) {
    var lowerCasedItemStrings = items.map(function (item) {
      return itemToStringParam(item).toLowerCase();
    });
    var lowerCasedKeysSoFar = keysSoFar.toLowerCase();

    var isValid = function isValid(itemString, index) {
      var element = getItemNodeFromIndex(index);
      return itemString.startsWith(lowerCasedKeysSoFar) && !(element && element.hasAttribute('disabled'));
    };

    for (var index = highlightedIndex + 1; index < lowerCasedItemStrings.length; index++) {
      var itemString = lowerCasedItemStrings[index];

      if (isValid(itemString, index)) {
        return index;
      }
    }

    for (var _index = 0; _index < highlightedIndex; _index++) {
      var _itemString = lowerCasedItemStrings[_index];

      if (isValid(_itemString, _index)) {
        return _index;
      }
    }

    return highlightedIndex;
  }

  var propTypes = {
    items: PropTypes.array.isRequired,
    itemToString: PropTypes.func,
    getA11yStatusMessage: PropTypes.func,
    getA11ySelectionMessage: PropTypes.func,
    circularNavigation: PropTypes.bool,
    highlightedIndex: PropTypes.number,
    defaultHighlightedIndex: PropTypes.number,
    initialHighlightedIndex: PropTypes.number,
    isOpen: PropTypes.bool,
    defaultIsOpen: PropTypes.bool,
    initialIsOpen: PropTypes.bool,
    selectedItem: PropTypes.any,
    initialSelectedItem: PropTypes.any,
    defaultSelectedItem: PropTypes.any,
    id: PropTypes.string,
    labelId: PropTypes.string,
    menuId: PropTypes.string,
    getItemId: PropTypes.func,
    toggleButtonId: PropTypes.string,
    stateReducer: PropTypes.func,
    onSelectedItemChange: PropTypes.func,
    onHighlightedIndexChange: PropTypes.func,
    onStateChange: PropTypes.func,
    onIsOpenChange: PropTypes.func,
    environment: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func,
      document: PropTypes.shape({
        getElementById: PropTypes.func,
        activeElement: PropTypes.any,
        body: PropTypes.any
      })
    })
  };
  /**
   * Default implementation for status message. Only added when menu is open.
   * Will specift if there are results in the list, and if so, how many,
   * and what keys are relevant.
   *
   * @param {Object} param the downshift state and other relevant properties
   * @return {String} the a11y status message
   */

  function getA11yStatusMessage$1(_ref) {
    var isOpen = _ref.isOpen,
        resultCount = _ref.resultCount,
        previousResultCount = _ref.previousResultCount;

    if (!isOpen) {
      return '';
    }

    if (!resultCount) {
      return 'No results are available.';
    }

    if (resultCount !== previousResultCount) {
      return resultCount + " result" + (resultCount === 1 ? ' is' : 's are') + " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.";
    }

    return '';
  }

  var defaultProps$1 = _extends$3({}, defaultProps, {
    getA11yStatusMessage: getA11yStatusMessage$1
  });

  var MenuKeyDownArrowDown =  '__menu_keydown_arrow_down__' ;
  var MenuKeyDownArrowUp =  '__menu_keydown_arrow_up__' ;
  var MenuKeyDownEscape =  '__menu_keydown_escape__' ;
  var MenuKeyDownHome =  '__menu_keydown_home__' ;
  var MenuKeyDownEnd =  '__menu_keydown_end__' ;
  var MenuKeyDownEnter =  '__menu_keydown_enter__' ;
  var MenuKeyDownSpaceButton =  '__menu_keydown_space_button__' ;
  var MenuKeyDownCharacter =  '__menu_keydown_character__' ;
  var MenuBlur =  '__menu_blur__' ;
  var MenuMouseLeave =  '__menu_mouse_leave__' ;
  var ItemMouseMove =  '__item_mouse_move__' ;
  var ItemClick =  '__item_click__' ;
  var ToggleButtonClick =  '__togglebutton_click__' ;
  var ToggleButtonKeyDownArrowDown =  '__togglebutton_keydown_arrow_down__' ;
  var ToggleButtonKeyDownArrowUp =  '__togglebutton_keydown_arrow_up__' ;
  var ToggleButtonKeyDownCharacter =  '__togglebutton_keydown_character__' ;
  var FunctionToggleMenu =  '__function_toggle_menu__' ;
  var FunctionOpenMenu =  '__function_open_menu__' ;
  var FunctionCloseMenu =  '__function_close_menu__' ;
  var FunctionSetHighlightedIndex =  '__function_set_highlighted_index__' ;
  var FunctionSelectItem =  '__function_select_item__' ;
  var FunctionSetInputValue =  '__function_set_input_value__' ;
  var FunctionReset =  '__function_reset__' ;
  var stateChangeTypes$1$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MenuKeyDownArrowDown: MenuKeyDownArrowDown,
    MenuKeyDownArrowUp: MenuKeyDownArrowUp,
    MenuKeyDownEscape: MenuKeyDownEscape,
    MenuKeyDownHome: MenuKeyDownHome,
    MenuKeyDownEnd: MenuKeyDownEnd,
    MenuKeyDownEnter: MenuKeyDownEnter,
    MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,
    MenuKeyDownCharacter: MenuKeyDownCharacter,
    MenuBlur: MenuBlur,
    MenuMouseLeave: MenuMouseLeave,
    ItemMouseMove: ItemMouseMove,
    ItemClick: ItemClick,
    ToggleButtonClick: ToggleButtonClick,
    ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,
    ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,
    ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,
    FunctionToggleMenu: FunctionToggleMenu,
    FunctionOpenMenu: FunctionOpenMenu,
    FunctionCloseMenu: FunctionCloseMenu,
    FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,
    FunctionSelectItem: FunctionSelectItem,
    FunctionSetInputValue: FunctionSetInputValue,
    FunctionReset: FunctionReset
  });
  /* eslint-disable complexity */

  function downshiftSelectReducer(state, action) {
    var type = action.type,
        props = action.props,
        shiftKey = action.shiftKey;
    var changes;

    switch (type) {
      case ItemMouseMove:
        changes = {
          highlightedIndex: action.index
        };
        break;

      case ItemClick:
        changes = {
          isOpen: getDefaultValue(props, 'isOpen'),
          highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
          selectedItem: props.items[action.index]
        };
        break;

      case ToggleButtonKeyDownCharacter:
        {
          var lowercasedKey = action.key;
          var inputValue = "" + state.inputValue + lowercasedKey;
          var itemIndex = getItemIndexByCharacterKey(inputValue, state.selectedItem ? props.items.indexOf(state.selectedItem) : -1, props.items, props.itemToString, action.getItemNodeFromIndex);
          changes = _extends$3({
            inputValue: inputValue
          }, itemIndex >= 0 && {
            selectedItem: props.items[itemIndex]
          });
        }
        break;

      case ToggleButtonKeyDownArrowDown:
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
          isOpen: true
        };
        break;

      case ToggleButtonKeyDownArrowUp:
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
          isOpen: true
        };
        break;

      case MenuKeyDownEnter:
      case MenuKeyDownSpaceButton:
        changes = _extends$3({
          isOpen: getDefaultValue(props, 'isOpen'),
          highlightedIndex: getDefaultValue(props, 'highlightedIndex')
        }, state.highlightedIndex >= 0 && {
          selectedItem: props.items[state.highlightedIndex]
        });
        break;

      case MenuKeyDownHome:
        changes = {
          highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
        };
        break;

      case MenuKeyDownEnd:
        changes = {
          highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
        };
        break;

      case MenuKeyDownEscape:
        changes = {
          isOpen: false,
          highlightedIndex: -1
        };
        break;

      case MenuBlur:
        changes = {
          isOpen: false,
          highlightedIndex: -1
        };
        break;

      case MenuKeyDownCharacter:
        {
          var _lowercasedKey = action.key;

          var _inputValue = "" + state.inputValue + _lowercasedKey;

          var highlightedIndex = getItemIndexByCharacterKey(_inputValue, state.highlightedIndex, props.items, props.itemToString, action.getItemNodeFromIndex);
          changes = _extends$3({
            inputValue: _inputValue
          }, highlightedIndex >= 0 && {
            highlightedIndex: highlightedIndex
          });
        }
        break;

      case MenuKeyDownArrowDown:
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
        break;

      case MenuKeyDownArrowUp:
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
        break;

      case MenuMouseLeave:
        changes = {
          highlightedIndex: -1
        };
        break;

      case ToggleButtonClick:
      case FunctionToggleMenu:
        changes = {
          isOpen: !state.isOpen,
          highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
        };
        break;

      case FunctionOpenMenu:
        changes = {
          isOpen: true,
          highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
        };
        break;

      case FunctionCloseMenu:
        changes = {
          isOpen: false
        };
        break;

      case FunctionSetHighlightedIndex:
        changes = {
          highlightedIndex: action.highlightedIndex
        };
        break;

      case FunctionSelectItem:
        changes = {
          selectedItem: action.selectedItem
        };
        break;

      case FunctionSetInputValue:
        changes = {
          inputValue: action.inputValue
        };
        break;

      case FunctionReset:
        changes = {
          highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
          isOpen: getDefaultValue(props, 'isOpen'),
          selectedItem: getDefaultValue(props, 'selectedItem'),
          inputValue: getDefaultValue(props, 'inputValue')
        };
        break;

      default:
        throw new Error('Reducer called without proper action type.');
    }

    return _extends$3({}, state, {}, changes);
  }
  /* eslint-enable complexity */


  var validatePropTypes =  getPropTypesValidator(useSelect, propTypes);
  useSelect.stateChangeTypes = stateChangeTypes$1$1;

  function useSelect(userProps) {
    if (userProps === void 0) {
      userProps = {};
    }
    /* istanbul ignore else */


    {
      validatePropTypes(userProps);
    } // Props defaults and destructuring.


    var props = _extends$3({}, defaultProps$1, {}, userProps);

    var items = props.items,
        scrollIntoView = props.scrollIntoView,
        environment = props.environment,
        initialIsOpen = props.initialIsOpen,
        defaultIsOpen = props.defaultIsOpen,
        itemToString = props.itemToString,
        getA11ySelectionMessage = props.getA11ySelectionMessage,
        getA11yStatusMessage = props.getA11yStatusMessage; // Initial state depending on controlled props.

    var initialState = getInitialState(props); // Reducer init.

    var _useControlledState = useControlledState(downshiftSelectReducer, initialState, props),
        _useControlledState$ = _useControlledState[0],
        isOpen = _useControlledState$.isOpen,
        highlightedIndex = _useControlledState$.highlightedIndex,
        selectedItem = _useControlledState$.selectedItem,
        inputValue = _useControlledState$.inputValue,
        dispatch = _useControlledState[1]; // Refs


    var toggleButtonRef = React.useRef(null);
    var menuRef = React.useRef(null);
    var isInitialMount = React.useRef(true);
    var shouldScroll = React.useRef(true);
    var clearTimeout = React.useRef(null);
    var mouseAndTouchTrackers = React.useRef({
      isMouseDown: false,
      isTouchMove: false
    });
    var elementIds = React.useRef(getElementIds(props));
    var previousResultCountRef = React.useRef(); // Some utils.

    var getItemNodeFromIndex = function getItemNodeFromIndex(index) {
      return environment.document.getElementById(elementIds.current.getItemId(index));
    }; // Effects.

    /* Sets a11y status message on changes in state. */


    React.useEffect(function () {
      if (isInitialMount.current) {
        return;
      }

      var previousResultCount = previousResultCountRef.current;
      updateA11yStatus(function () {
        return getA11yStatusMessage({
          isOpen: isOpen,
          highlightedIndex: highlightedIndex,
          selectedItem: selectedItem,
          inputValue: inputValue,
          highlightedItem: items[highlightedIndex],
          resultCount: items.length,
          itemToString: itemToString,
          previousResultCount: previousResultCount
        });
      }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen, highlightedIndex, selectedItem, inputValue]);
    /* Sets a11y status message on changes in selectedItem. */

    React.useEffect(function () {
      if (isInitialMount.current) {
        return;
      }

      var previousResultCount = previousResultCountRef.current;
      updateA11yStatus(function () {
        return getA11ySelectionMessage({
          isOpen: isOpen,
          highlightedIndex: highlightedIndex,
          selectedItem: selectedItem,
          inputValue: inputValue,
          highlightedItem: items[highlightedIndex],
          resultCount: items.length,
          itemToString: itemToString,
          previousResultCount: previousResultCount
        });
      }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectedItem]);
    /* Sets cleanup for the keysSoFar after 500ms. */

    React.useEffect(function () {
      // init the clean function here as we need access to dispatch.
      if (isInitialMount.current) {
        clearTimeout.current = debounce$1(function (outerDispatch) {
          outerDispatch({
            type: FunctionSetInputValue,
            inputValue: ''
          });
        }, 500);
      }

      if (!inputValue) {
        return;
      }

      clearTimeout.current(dispatch); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [inputValue]);
    /* Controls the focus on the menu or the toggle button. */

    React.useEffect(function () {
      // Don't focus menu on first render.
      if (isInitialMount.current) {
        // Unless it was initialised as open.
        if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {
          menuRef.current.focus();
        }

        return;
      } // Focus menu on open.
      // istanbul ignore next


      if (isOpen && menuRef.current) {
        menuRef.current.focus(); // Focus toggleButton on close.
      } else if (environment.document.activeElement === menuRef.current && toggleButtonRef.current) {
        toggleButtonRef.current.focus();
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [isOpen]);
    /* Scroll on highlighted item if change comes from keyboard. */

    React.useEffect(function () {
      if (highlightedIndex < 0 || !isOpen || !items.length) {
        return;
      }

      if (shouldScroll.current === false) {
        shouldScroll.current = true;
      } else {
        scrollIntoView(getItemNodeFromIndex(highlightedIndex), menuRef.current);
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [highlightedIndex]);
    React.useEffect(function () {
      if (isInitialMount.current) {
        return;
      }

      previousResultCountRef.current = items.length;
    });
    /* Make initial ref false. */

    React.useEffect(function () {
      isInitialMount.current = false;
    }, []);
    /* Add mouse/touch events to document. */

    React.useEffect(function () {
      // The same strategy for checking if a click occurred inside or outside downsift
      // as in downshift.js.
      var onMouseDown = function onMouseDown() {
        mouseAndTouchTrackers.current.isMouseDown = true;
      };

      var onMouseUp = function onMouseUp(event) {
        mouseAndTouchTrackers.current.isMouseDown = false;

        if (isOpen && !targetWithinDownshift(event.target, [toggleButtonRef.current, menuRef.current], environment.document)) {
          dispatch({
            type: MenuBlur
          });
        }
      };

      var onTouchStart = function onTouchStart() {
        mouseAndTouchTrackers.current.isTouchMove = false;
      };

      var onTouchMove = function onTouchMove() {
        mouseAndTouchTrackers.current.isTouchMove = true;
      };

      var onTouchEnd = function onTouchEnd(event) {
        if (isOpen && !mouseAndTouchTrackers.current.isTouchMove && !targetWithinDownshift(event.target, [toggleButtonRef.current, menuRef.current], environment.document, false)) {
          dispatch({
            type: MenuBlur
          });
        }
      };

      environment.addEventListener('mousedown', onMouseDown);
      environment.addEventListener('mouseup', onMouseUp);
      environment.addEventListener('touchstart', onTouchStart);
      environment.addEventListener('touchmove', onTouchMove);
      environment.addEventListener('touchend', onTouchEnd);
      return function () {
        environment.removeEventListener('mousedown', onMouseDown);
        environment.removeEventListener('mouseup', onMouseUp);
        environment.removeEventListener('touchstart', onTouchStart);
        environment.removeEventListener('touchmove', onTouchMove);
        environment.removeEventListener('touchend', onTouchEnd);
      };
    }); // Event handler functions.

    var toggleButtonKeyDownHandlers = {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowDown,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowUp,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      }
    };
    var menuKeyDownHandlers = {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownArrowDown,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownArrowUp,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      Home: function Home(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownHome,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      End: function End(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownEnd,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      Escape: function Escape() {
        dispatch({
          type: MenuKeyDownEscape
        });
      },
      Enter: function Enter(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownEnter
        });
      },
      ' ': function _(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownSpaceButton
        });
      }
    }; // Event handlers.

    var menuHandleKeyDown = function menuHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && menuKeyDownHandlers[key]) {
        menuKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: MenuKeyDownCharacter,
          key: key,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      }
    };

    var menuHandleBlur = function menuHandleBlur() {
      var shouldBlur = !mouseAndTouchTrackers.current.isMouseDown;
      /* istanbul ignore else */

      if (shouldBlur) {
        dispatch({
          type: MenuBlur
        });
      }
    };

    var menuHandleMouseLeave = function menuHandleMouseLeave() {
      dispatch({
        type: MenuMouseLeave
      });
    };

    var toggleButtonHandleClick = function toggleButtonHandleClick() {
      dispatch({
        type: ToggleButtonClick
      });
    };

    var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && toggleButtonKeyDownHandlers[key]) {
        toggleButtonKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key: key,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      }
    };

    var itemHandleMouseMove = function itemHandleMouseMove(index) {
      if (index === highlightedIndex) {
        return;
      }

      shouldScroll.current = false;
      dispatch({
        type: ItemMouseMove,
        index: index
      });
    };

    var itemHandleClick = function itemHandleClick(index) {
      dispatch({
        type: ItemClick,
        index: index
      });
    }; // Action functions.


    return {
      // prop getters.
      getToggleButtonProps: function getToggleButtonProps(_temp2) {
        var _extends3;

        var _ref2 = _temp2 === void 0 ? {} : _temp2,
            onClick = _ref2.onClick,
            onKeyDown = _ref2.onKeyDown,
            _ref2$refKey = _ref2.refKey,
            refKey = _ref2$refKey === void 0 ? 'ref' : _ref2$refKey,
            ref = _ref2.ref,
            rest = _objectWithoutPropertiesLoose$3(_ref2, ["onClick", "onKeyDown", "refKey", "ref"]);

        var toggleProps = _extends$3((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function (toggleButtonNode) {
          toggleButtonRef.current = toggleButtonNode;
        }), _extends3.id = elementIds.current.toggleButtonId, _extends3['aria-haspopup'] = 'listbox', _extends3['aria-expanded'] = isOpen, _extends3['aria-labelledby'] = elementIds.current.labelId + " " + elementIds.current.toggleButtonId, _extends3), rest);

        if (!rest.disabled) {
          toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
          toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
        }

        return toggleProps;
      },
      getLabelProps: function getLabelProps(labelProps) {
        return _extends$3({
          id: elementIds.current.labelId,
          htmlFor: elementIds.current.toggleButtonId
        }, labelProps);
      },
      getMenuProps: function getMenuProps(_temp) {
        var _extends2;

        var _ref = _temp === void 0 ? {} : _temp,
            onMouseLeave = _ref.onMouseLeave,
            _ref$refKey = _ref.refKey,
            refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
            onKeyDown = _ref.onKeyDown,
            onBlur = _ref.onBlur,
            ref = _ref.ref,
            rest = _objectWithoutPropertiesLoose$3(_ref, ["onMouseLeave", "refKey", "onKeyDown", "onBlur", "ref"]);

        return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function (menuNode) {
          menuRef.current = menuNode;
        }), _extends2.id = elementIds.current.menuId, _extends2.role = 'listbox', _extends2['aria-labelledby'] = elementIds.current.labelId, _extends2.tabIndex = -1, _extends2), isOpen && highlightedIndex > -1 && {
          'aria-activedescendant': elementIds.current.getItemId(highlightedIndex)
        }, {
          onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),
          onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),
          onBlur: callAllEventHandlers(onBlur, menuHandleBlur)
        }, rest);
      },
      getItemProps: function getItemProps(_temp3) {
        var _ref3 = _temp3 === void 0 ? {} : _temp3,
            item = _ref3.item,
            index = _ref3.index,
            onMouseMove = _ref3.onMouseMove,
            onClick = _ref3.onClick,
            rest = _objectWithoutPropertiesLoose$3(_ref3, ["item", "index", "onMouseMove", "onClick"]);

        var itemIndex = getItemIndex(index, item, items);

        if (itemIndex < 0) {
          throw new Error('Pass either item or item index in getItemProps!');
        }

        var itemProps = _extends$3({
          role: 'option',
          'aria-selected': "" + (itemIndex === highlightedIndex),
          id: elementIds.current.getItemId(itemIndex)
        }, rest);

        if (!rest.disabled) {
          itemProps.onMouseMove = callAllEventHandlers(onMouseMove, function () {
            return itemHandleMouseMove(itemIndex);
          });
          itemProps.onClick = callAllEventHandlers(onClick, function () {
            return itemHandleClick(itemIndex);
          });
        }

        return itemProps;
      },
      // actions.
      toggleMenu: function toggleMenu() {
        dispatch({
          type: FunctionToggleMenu
        });
      },
      openMenu: function openMenu() {
        dispatch({
          type: FunctionOpenMenu
        });
      },
      closeMenu: function closeMenu() {
        dispatch({
          type: FunctionCloseMenu
        });
      },
      setHighlightedIndex: function setHighlightedIndex(newHighlightedIndex) {
        dispatch({
          type: FunctionSetHighlightedIndex,
          highlightedIndex: newHighlightedIndex
        });
      },
      selectItem: function selectItem(newSelectedItem) {
        dispatch({
          type: FunctionSelectItem,
          selectedItem: newSelectedItem
        });
      },
      reset: function reset() {
        dispatch({
          type: FunctionReset
        });
      },
      setInputValue: function setInputValue(newInputValue) {
        dispatch({
          type: FunctionSetInputValue,
          inputValue: newInputValue
        });
      },
      // state.
      highlightedIndex: highlightedIndex,
      isOpen: isOpen,
      selectedItem: selectedItem,
      inputValue: inputValue
    };
  }

  var propTypes$1 = {
    items: PropTypes.array.isRequired,
    itemToString: PropTypes.func,
    getA11yStatusMessage: PropTypes.func,
    getA11ySelectionMessage: PropTypes.func,
    circularNavigation: PropTypes.bool,
    highlightedIndex: PropTypes.number,
    defaultHighlightedIndex: PropTypes.number,
    initialHighlightedIndex: PropTypes.number,
    isOpen: PropTypes.bool,
    defaultIsOpen: PropTypes.bool,
    initialIsOpen: PropTypes.bool,
    selectedItem: PropTypes.any,
    initialSelectedItem: PropTypes.any,
    defaultSelectedItem: PropTypes.any,
    inputValue: PropTypes.string,
    defaultInputValue: PropTypes.string,
    initialInputValue: PropTypes.string,
    id: PropTypes.string,
    labelId: PropTypes.string,
    menuId: PropTypes.string,
    getItemId: PropTypes.func,
    inputId: PropTypes.string,
    toggleButtonId: PropTypes.string,
    stateReducer: PropTypes.func,
    onSelectedItemChange: PropTypes.func,
    onHighlightedIndexChange: PropTypes.func,
    onStateChange: PropTypes.func,
    onIsOpenChange: PropTypes.func,
    onInputValueChange: PropTypes.func,
    environment: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func,
      document: PropTypes.shape({
        getElementById: PropTypes.func,
        activeElement: PropTypes.any,
        body: PropTypes.any
      })
    })
  };

  var defaultProps$2 = _extends$3({}, defaultProps, {
    getA11yStatusMessage: getA11yStatusMessage,
    circularNavigation: true
  });

  var propTypes$2 = {
    selectedItems: PropTypes.array,
    initialSelectedItems: PropTypes.array,
    defaultSelectedItems: PropTypes.array,
    itemToString: PropTypes.func,
    getA11yRemovalMessage: PropTypes.func,
    stateReducer: PropTypes.func,
    activeIndex: PropTypes.number,
    initialActiveIndex: PropTypes.number,
    defaultActiveIndex: PropTypes.number,
    onActiveIndexChange: PropTypes.func,
    onSelectedItemsChange: PropTypes.func,
    keyNavigationNext: PropTypes.string,
    keyNavigationPrevious: PropTypes.string,
    environment: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func,
      document: PropTypes.shape({
        getElementById: PropTypes.func,
        activeElement: PropTypes.any,
        body: PropTypes.any
      })
    })
  };

  var ListBoxType = PropTypes.oneOf(['default', 'inline']);
  var ListBoxSize = PropTypes.oneOf(['sm', 'xl']);

  var prefix$h = settings_1.prefix;

  var handleOnKeyDown = function handleOnKeyDown(event) {
    if (event.keyCode === 27) {
      event.stopPropagation();
    }
  };

  var handleClick = function handleClick(event) {
    event.preventDefault();
    event.stopPropagation();
  };
  /**
   * `ListBox` is a generic container component that handles creating the
   * container class name in response to certain props.
   */


  var ListBox = /*#__PURE__*/React__default.forwardRef(function ListBox(_ref, ref) {
    var _cx;

    var children = _ref.children,
        containerClassName = _ref.className,
        disabled = _ref.disabled,
        type = _ref.type,
        size = _ref.size,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        light = _ref.light,
        isOpen = _ref.isOpen,
        rest = _objectWithoutProperties(_ref, ["children", "className", "disabled", "type", "size", "invalid", "invalidText", "light", "isOpen"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, containerClassName, !!containerClassName), _defineProperty(_cx, "".concat(prefix$h, "--list-box"), true), _defineProperty(_cx, "".concat(prefix$h, "--list-box--").concat(size), size), _defineProperty(_cx, "".concat(prefix$h, "--list-box--inline"), type === 'inline'), _defineProperty(_cx, "".concat(prefix$h, "--list-box--disabled"), disabled), _defineProperty(_cx, "".concat(prefix$h, "--list-box--light"), light), _defineProperty(_cx, "".concat(prefix$h, "--list-box--expanded"), isOpen), _cx));
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
      className: className,
      ref: ref,
      onKeyDown: handleOnKeyDown,
      onClick: handleClick,
      "data-invalid": invalid || undefined
    }), children), invalid ? /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$h, "--form-requirement")
    }, invalidText) : null);
  });
  ListBox.displayName = 'ListBox';
  ListBox.propTypes = {
    /**
     * Provide the contents of your ListBox
     */
    children: PropTypes.node,

    /**
     * Specify a class name to be applied on the containing list box node
     */
    className: PropTypes.string,

    /**
     * Specify whether the ListBox is currently disabled
     */
    disabled: PropTypes.bool.isRequired,

    /**
     * Specify the "type" of the ListBox. Currently supports either `default` or
     * `inline` as an option.
     */
    type: ListBoxType.isRequired,

    /**
     * Specify the size of the ListBox. Currently supports either `sm` or `xl` as an option.
     */
    size: ListBoxSize,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes.bool,

    /**
     * Specify the text to be displayed when the control is invalid
     */
    invalidText: PropTypes.string,

    /**
     * Specify if the control should use the light variant
     */
    light: PropTypes.bool,

    /**
     * Specify if the control should render open
     */
    isOpen: PropTypes.bool
  };
  ListBox.defaultProps = {
    disabled: false,
    type: 'default'
  };

  var prefix$i = settings_1.prefix; // No longer used, left export for backward-compatibility
  /**
   * `ListBoxField` is responsible for creating the containing node for valid
   * elements inside of a field. It also provides a11y-related attributes like
   * `role` to make sure a user can focus the given field.
   */

  function ListBoxField(_ref) {
    var children = _ref.children,
        disabled = _ref.disabled,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties(_ref, ["children", "disabled", "tabIndex"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: "".concat(prefix$i, "--list-box__field"),
      tabIndex: !disabled && tabIndex || -1
    }, rest), children);
  }

  ListBoxField.propTypes = {
    /**
     * Typically set by `getToggleButtonProps`, this should specify whether the
     * field has a popup.
     */
    'aria-haspopup': PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),

    /**
     * The role for the component, should be set by `getToggleButtonProps` coming
     * from Downshift
     */
    role: PropTypes.string,

    /**
     * Provide the contents of your ListBoxField
     */
    children: PropTypes.node,

    /**
     * Specify if the parent <ListBox> is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Optional prop to specify the tabIndex of the <ListBox> trigger button
     */
    tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
  };

  var prefix$j = settings_1.prefix;
  /**
   * `ListBoxMenuItem` is a helper component for managing the container class
   * name, alongside any classes for any corresponding states, for a generic list
   * box menu item.
   */

  var ListBoxMenuItem = function ListBoxMenuItem(_ref) {
    var _cx;

    var children = _ref.children,
        isActive = _ref.isActive,
        isHighlighted = _ref.isHighlighted,
        rest = _objectWithoutProperties(_ref, ["children", "isActive", "isHighlighted"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$j, "--list-box__menu-item"), true), _defineProperty(_cx, "".concat(prefix$j, "--list-box__menu-item--active"), isActive), _defineProperty(_cx, "".concat(prefix$j, "--list-box__menu-item--highlighted"), isHighlighted), _cx));
    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: className
    }, rest), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$j, "--list-box__menu-item__option")
    }, children));
  };

  ListBoxMenuItem.propTypes = {
    /**
     * Specify any children nodes that hsould be rendered inside of the ListBox
     * Menu Item
     */
    children: PropTypes.node,

    /**
     * Specify whether the current menu item is "active".
     */
    isActive: PropTypes.bool.isRequired,

    /**
     * Specify whether the current menu item is "highlighed".
     */
    isHighlighted: PropTypes.bool.isRequired
  };
  ListBoxMenuItem.defaultProps = {
    isActive: false,
    isHighlighted: false
  };

  /**
   * `createChainableTypeChecker` is used inside of our custom prop validators to
   * add in chaining `isRequired` on a given prop validator.
   */
  var createChainableTypeChecker = function createChainableTypeChecker(validate) {
    // `checkType` is borrowed heavily from the `prop-types` package
    var checkType = function checkType(isRequired, props, propName, componentName, location) {
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new Error("The ".concat(location, " `").concat(propName, "` is marked as required in ") + "".concat(componentName, ", but its value is `null`."));
          }

          return new Error("The ".concat(location, " `").concat(propName, "` is marked as required in ") + "".concat(componentName, ", but its value is `undefined`."));
        }

        return null;
      } else {
        return validate(props, propName, componentName, location);
      }
    }; // By default, the validator will have `isRequired` set to false. However, we
    // also define the `isRequired` property on the validtor so that consumers can
    // chain their prop validator and assert that the property is required.


    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  };

  var cachedDisplayNames = new WeakMap();
  /**
   * `getDisplayName` is a utility function for getting a name from a given
   * component type. It supports names from React elements, Stateless Functional
   * Components, and Class-based Components
   */

  var getDisplayName = function getDisplayName(type) {
    if (typeof type === 'string') {
      return type;
    }

    if (cachedDisplayNames.has(type)) {
      return cachedDisplayNames.get(type);
    }

    var displayName;

    if (typeof type.displayName === 'string') {
      displayName = type.displayName;
    }

    if (!displayName) {
      displayName = type.name || 'Unknown';
    }

    cachedDisplayNames.set(type, displayName);
    return displayName;
  };

  /**
   * `childrenOfType` is used for asserting that children of a given React
   * component are only of a given type. Currently, this supports React elements,
   * Stateless Functional Components, and Class-based components.
   *
   * This prop validator also supports chaining through `isRequired`
   */

  var childrenOfType = function childrenOfType(expectedChildType) {
    var expectedDisplayName = getDisplayName( // Support both React elements and components by using `type` if it exists
    expectedChildType.type || expectedChildType);

    var validate = function validate(props, propName, componentName) {
      React.Children.forEach(props[propName], function (child) {
        if (!child) {
          return;
        }

        var childDisplayName = getDisplayName(child.type);

        if (child.type !== expectedChildType.type && child.type !== expectedChildType) {
          throw new Error("Invalid prop `children` of type `".concat(childDisplayName, "` ") + "supplied to `".concat(componentName, "`, expected each child to be a ") + "`".concat(expectedDisplayName, "` component."));
        }
      });
    };

    return createChainableTypeChecker(validate);
  };

  var prefix$k = settings_1.prefix;
  /**
   * `ListBoxMenu` is a simple container node that isolates the `list-box__menu`
   * class into a single component. It is also being used to validate given
   * `children` components.
   */

  var ListBoxMenu = /*#__PURE__*/React__default.forwardRef(function ListBoxMenu(_ref, ref) {
    var children = _ref.children,
        id = _ref.id,
        rest = _objectWithoutProperties(_ref, ["children", "id"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      ref: ref,
      id: id,
      className: "".concat(prefix$k, "--list-box__menu"),
      role: "listbox"
    }, rest), children);
  });
  ListBoxMenu.displayName = 'ListBoxMenu';
  ListBoxMenu.propTypes = {
    /**
     * Provide the contents of your ListBoxMenu
     */
    children: childrenOfType(ListBoxMenuItem),

    /**
     * Specify a custom `id`
     */
    id: PropTypes.string.isRequired
  };

  var _defaultTranslations;
  var prefix$l = settings_1.prefix;
  var translationIds = {
    'close.menu': 'close.menu',
    'open.menu': 'open.menu'
  };
  var defaultTranslations = (_defaultTranslations = {}, _defineProperty(_defaultTranslations, translationIds['close.menu'], 'Close menu'), _defineProperty(_defaultTranslations, translationIds['open.menu'], 'Open menu'), _defaultTranslations);
  /**
   * `ListBoxMenuIcon` is used to orient the icon up or down depending on the
   * state of the menu for a given `ListBox`
   */

  var ListBoxMenuIcon = function ListBoxMenuIcon(_ref) {
    var isOpen = _ref.isOpen,
        t = _ref.translateWithId;
    var className = classnames("".concat(prefix$l, "--list-box__menu-icon"), _defineProperty({}, "".concat(prefix$l, "--list-box__menu-icon--open"), isOpen));
    var description = isOpen ? t('close.menu') : t('open.menu');
    return /*#__PURE__*/React__default.createElement("div", {
      className: className
    }, /*#__PURE__*/React__default.createElement(ChevronDown16, {
      name: "chevron--down",
      "aria-label": description
    }, /*#__PURE__*/React__default.createElement("title", null, description)));
  };

  ListBoxMenuIcon.propTypes = {
    /**
     * Specify whether the menu is currently open, which will influence the
     * direction of the menu icon
     */
    isOpen: PropTypes.bool.isRequired,

    /**
     * i18n hook used to provide the appropriate description for the given menu
     * icon. This function takes in an id defined in `translationIds` and should
     * return a string message for that given message id.
     */
    translateWithId: PropTypes.func.isRequired
  };
  ListBoxMenuIcon.defaultProps = {
    translateWithId: function translateWithId(id) {
      return defaultTranslations[id];
    }
  };

  var _defaultTranslations$1;
  var prefix$m = settings_1.prefix;
  /**
   * `ListBoxSelection` is used to provide controls for clearing a selection, in
   * addition to conditionally rendering a badge if the control has more than one
   * selection.
   */

  var ListBoxSelection = function ListBoxSelection(_ref) {
    var _cx;

    var clearSelection = _ref.clearSelection,
        selectionCount = _ref.selectionCount,
        t = _ref.translateWithId,
        disabled = _ref.disabled,
        onClearSelection = _ref.onClearSelection;
    var className = classnames("".concat(prefix$m, "--list-box__selection"), (_cx = {}, _defineProperty(_cx, "".concat(prefix$m, "--tag--filter"), selectionCount), _defineProperty(_cx, "".concat(prefix$m, "--list-box__selection--multi"), selectionCount), _cx));

    var handleOnClick = function handleOnClick(event) {
      event.stopPropagation();

      if (disabled) {
        return;
      }

      clearSelection(event);

      if (onClearSelection) {
        onClearSelection(event);
      }
    };

    var handleOnKeyDown = function handleOnKeyDown(event) {
      event.stopPropagation();

      if (disabled) {
        return;
      } // When a user hits ENTER, we'll clear the selection


      if (match(event, Enter)) {
        clearSelection(event);

        if (onClearSelection) {
          onClearSelection(event);
        }
      }
    };

    var description = selectionCount ? t('clear.all') : t('clear.selection');
    return /*#__PURE__*/React__default.createElement("div", {
      role: "button",
      className: className,
      tabIndex: disabled ? -1 : 0,
      onClick: handleOnClick,
      onKeyDown: handleOnKeyDown,
      "aria-label": "Clear Selection",
      title: description
    }, selectionCount, /*#__PURE__*/React__default.createElement(Close16, null));
  };

  var translationIds$1 = {
    'clear.all': 'clear.all',
    'clear.selection': 'clear.selection'
  };
  var defaultTranslations$1 = (_defaultTranslations$1 = {}, _defineProperty(_defaultTranslations$1, translationIds$1['clear.all'], 'Clear all selected items'), _defineProperty(_defaultTranslations$1, translationIds$1['clear.selection'], 'Clear selected item'), _defaultTranslations$1);
  ListBoxSelection.propTypes = {
    /**
     * Specify whether or not the clear selection element should be disabled
     */
    disabled: PropTypes.bool,

    /**
     * Specify a function to be invoked when a user interacts with the clear
     * selection element.
     */
    clearSelection: PropTypes.func.isRequired,

    /**
     * Specify an optional `selectionCount` value that will be used to determine
     * whether the selection should display a badge or a single clear icon.
     */
    selectionCount: PropTypes.number,

    /**
     * i18n hook used to provide the appropriate description for the given menu
     * icon. This function takes in an id defined in `translationIds` and should
     * return a string message for that given message id.
     */
    translateWithId: PropTypes.func.isRequired,

    /**
     * Specify an optional `onClick` handler that is called when the underlying
     * clear selection element is clicked
     */
    onClick: PropTypes.func,

    /**
     * Specify an optional `onKeyDown` handler that is called when the underlying
     * clear selection element fires a keydown event
     */
    onKeyDown: PropTypes.func,

    /**
     * Specify an optional `onClearSelection` handler that is called when the underlying
     * element is cleared
     */
    onClearSelection: PropTypes.func
  };
  ListBoxSelection.defaultProps = {
    translateWithId: function translateWithId(id) {
      return defaultTranslations$1[id];
    }
  };

  ListBox.Field = ListBoxField;
  ListBox.Menu = ListBoxMenu;
  ListBox.MenuIcon = ListBoxMenuIcon;
  ListBox.MenuItem = ListBoxMenuItem;
  ListBox.Selection = ListBoxSelection;

  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Create an adapter that converts an object of props with potentially deprecated
   * prop names to the replacement prop names in a newer version. Useful for guarding
   * against breaking changes when a prop has been renamed
   *
   * @param {Array} spec - an array of options which specify a text or regex
   * matcher alongside a replacement if there is a match
   * @returns {Function}
   */
  function createPropAdapter(spec) {
    // if props aren't passed in we should default the prop to empty object
    return function () {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var output = {};
      Object.keys(input).forEach(function (key) {
        var match = spec.find(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              regex = _ref2[0];

          return key.match(regex);
        });

        if (match) {
          var _match = _slicedToArray(match, 2),
              regex = _match[0],
              replacer = _match[1];

          output[key.replace(regex, replacer)] = input[key];
          return;
        }

        output[key] = input[key];
      });
      return output;
    };
  }
  /**
   * TODO: REMOVE IN v11
   * props staring with "default..." were changed to "initial..." in Downshift v3
   *
   * @see https://github.com/downshift-js/downshift/releases/tag/v3.0.0
   */


  var mapDownshiftProps = createPropAdapter([[/^default/g, 'initial']]);

  var prefix$n = settings_1.prefix;

  var defaultItemToString = function defaultItemToString(item) {
    if (typeof item === 'string') {
      return item;
    }

    return item && item.label;
  };

  var defaultShouldFilterItem = function defaultShouldFilterItem() {
    return true;
  };

  var getInputValue = function getInputValue(props, state) {
    if (props.selectedItem) {
      return props.itemToString(props.selectedItem);
    } // TODO: consistent `initialSelectedItem` behavior with other listbox components in v11


    if (props.initialSelectedItem) {
      return props.itemToString(props.initialSelectedItem);
    }

    return state.inputValue || '';
  };

  var findHighlightedIndex = function findHighlightedIndex(_ref, inputValue) {
    var items = _ref.items,
        itemToString = _ref.itemToString;

    if (!inputValue) {
      return -1;
    }

    var searchValue = inputValue.toLowerCase();

    for (var i = 0; i < items.length; i++) {
      var item = itemToString(items[i]).toLowerCase();

      if (item.indexOf(searchValue) !== -1) {
        return i;
      }
    }

    return -1;
  };

  var getInstanceId = setupGetInstanceId();

  var ComboBox = /*#__PURE__*/function (_React$Component) {
    _inherits(ComboBox, _React$Component);

    var _super = _createSuper(ComboBox);

    _createClass(ComboBox, null, [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, state) {
        var prevSelectedItem = state.prevSelectedItem,
            doneInitialSelectedItem = state.doneInitialSelectedItem;
        var selectedItem = nextProps.selectedItem;

        if (!doneInitialSelectedItem || prevSelectedItem !== selectedItem) {
          return {
            doneInitialSelectedItem: true,
            prevSelectedItem: selectedItem,
            inputValue: getInputValue(nextProps, state)
          };
        }

        return null;
      }
    }]);

    function ComboBox(props) {
      var _this;

      _classCallCheck(this, ComboBox);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "filterItems", function (items, itemToString, inputValue) {
        return items.filter(function (item) {
          return _this.props.shouldFilterItem({
            item: item,
            itemToString: itemToString,
            inputValue: inputValue
          });
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnChange", function (selectedItem) {
        if (_this.props.onChange) {
          _this.props.onChange({
            selectedItem: selectedItem
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnInputValueChange", function (inputValue) {
        var onInputChange = _this.props.onInputChange;

        _this.setState(function () {
          return {
            // Default to empty string if we have a false-y `inputValue`
            inputValue: inputValue || ''
          };
        }, function () {
          if (onInputChange) {
            onInputChange(inputValue);
          }
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleSelectionClear", function () {
        var _this$textInput;

        if ((_this$textInput = _this.textInput) === null || _this$textInput === void 0 ? void 0 : _this$textInput.current) {
          _this.textInput.current.focus();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnStateChange", function (newState, _ref2) {
        var setHighlightedIndex = _ref2.setHighlightedIndex;

        if (Object.prototype.hasOwnProperty.call(newState, 'inputValue')) {
          var inputValue = newState.inputValue;

          var items = _this.filterItems(_this.props.items, _this.props.itemToString, inputValue);

          setHighlightedIndex(findHighlightedIndex(_objectSpread2(_objectSpread2({}, _this.props), {}, {
            items: items
          }), inputValue));
        }
      });

      _defineProperty(_assertThisInitialized(_this), "onToggleClick", function (isOpen) {
        return function (event) {
          if (event.target === _this.textInput.current && isOpen) {
            event.preventDownshiftDefault = true;
            event.persist();
          }
        };
      });

      _this.textInput = /*#__PURE__*/React__default.createRef();
      _this.comboBoxInstanceId = getInstanceId();
      _this.state = {
        inputValue: getInputValue(props, {})
      };
      return _this;
    }

    _createClass(ComboBox, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            containerClassName = _this$props.className,
            disabled = _this$props.disabled,
            id = _this$props.id,
            items = _this$props.items,
            itemToString = _this$props.itemToString,
            itemToElement = _this$props.itemToElement,
            titleText = _this$props.titleText,
            helperText = _this$props.helperText,
            placeholder = _this$props.placeholder,
            initialSelectedItem = _this$props.initialSelectedItem,
            selectedItem = _this$props.selectedItem,
            ariaLabel = _this$props.ariaLabel,
            translateWithId = _this$props.translateWithId,
            invalid = _this$props.invalid,
            invalidText = _this$props.invalidText,
            light = _this$props.light,
            type = _this$props.type,
            size = _this$props.size,
            shouldFilterItem = _this$props.shouldFilterItem,
            onChange = _this$props.onChange,
            onInputChange = _this$props.onInputChange,
            downshiftProps = _this$props.downshiftProps,
            direction = _this$props.direction,
            rest = _objectWithoutProperties(_this$props, ["className", "disabled", "id", "items", "itemToString", "itemToElement", "titleText", "helperText", "placeholder", "initialSelectedItem", "selectedItem", "ariaLabel", "translateWithId", "invalid", "invalidText", "light", "type", "size", "shouldFilterItem", "onChange", "onInputChange", "downshiftProps", "direction"]);

        var className = classnames("".concat(prefix$n, "--combo-box"), containerClassName, _defineProperty({}, "".concat(prefix$n, "--list-box--up"), direction === 'top'));
        var titleClasses = classnames("".concat(prefix$n, "--label"), _defineProperty({}, "".concat(prefix$n, "--label--disabled"), disabled));
        var comboBoxHelperId = !helperText ? undefined : "combobox-helper-text-".concat(this.comboBoxInstanceId);
        var helperClasses = classnames("".concat(prefix$n, "--form__helper-text"), _defineProperty({}, "".concat(prefix$n, "--form__helper-text--disabled"), disabled));
        var wrapperClasses = classnames("".concat(prefix$n, "--list-box__wrapper"));
        var inputClasses = classnames("".concat(prefix$n, "--text-input"), _defineProperty({}, "".concat(prefix$n, "--text-input--empty"), !this.state.inputValue)); // needs to be Capitalized for react to render it correctly

        var ItemToElement = itemToElement;
        return /*#__PURE__*/React__default.createElement(Downshift, _extends({}, mapDownshiftProps(downshiftProps), {
          onChange: this.handleOnChange,
          onInputValueChange: this.handleOnInputValueChange,
          onStateChange: this.handleOnStateChange,
          inputValue: this.state.inputValue || '',
          itemToString: itemToString,
          initialSelectedItem: initialSelectedItem,
          inputId: id,
          selectedItem: selectedItem
        }), function (_ref3) {
          var getToggleButtonProps = _ref3.getToggleButtonProps,
              getInputProps = _ref3.getInputProps,
              getItemProps = _ref3.getItemProps,
              getLabelProps = _ref3.getLabelProps,
              isOpen = _ref3.isOpen,
              inputValue = _ref3.inputValue,
              selectedItem = _ref3.selectedItem,
              highlightedIndex = _ref3.highlightedIndex,
              clearSelection = _ref3.clearSelection,
              toggleMenu = _ref3.toggleMenu,
              getMenuProps = _ref3.getMenuProps;
          return /*#__PURE__*/React__default.createElement("div", {
            className: wrapperClasses
          }, titleText && /*#__PURE__*/React__default.createElement("label", _extends({
            className: titleClasses
          }, getLabelProps()), titleText), /*#__PURE__*/React__default.createElement(ListBox, {
            className: className,
            disabled: disabled,
            invalid: invalid,
            "aria-label": ariaLabel,
            invalidText: invalidText,
            isOpen: isOpen,
            light: light,
            size: size
          }, /*#__PURE__*/React__default.createElement(ListBox.Field, getToggleButtonProps({
            disabled: disabled,
            onClick: _this2.onToggleClick(isOpen)
          }), /*#__PURE__*/React__default.createElement("input", _extends({
            disabled: disabled,
            className: inputClasses,
            type: "text",
            tabIndex: "0",
            "aria-autocomplete": "list",
            ref: _this2.textInput
          }, rest, getInputProps({
            disabled: disabled,
            placeholder: placeholder,
            onKeyDown: function onKeyDown(event) {
              if (match(event, Space)) {
                event.stopPropagation();
              }

              if (match(event, Enter)) {
                toggleMenu();
              }
            }
          }))), invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
            className: "".concat(prefix$n, "--list-box__invalid-icon")
          }), inputValue && /*#__PURE__*/React__default.createElement(ListBox.Selection, {
            clearSelection: clearSelection,
            translateWithId: translateWithId,
            disabled: disabled,
            onClearSelection: _this2.handleSelectionClear
          }), /*#__PURE__*/React__default.createElement(ListBox.MenuIcon, {
            isOpen: isOpen,
            translateWithId: translateWithId
          })), isOpen && /*#__PURE__*/React__default.createElement(ListBox.Menu, getMenuProps({
            'aria-label': ariaLabel
          }), _this2.filterItems(items, itemToString, inputValue).map(function (item, index) {
            var itemProps = getItemProps({
              item: item,
              index: index
            });
            return /*#__PURE__*/React__default.createElement(ListBox.MenuItem, _extends({
              key: itemProps.id,
              isActive: selectedItem === item,
              tabIndex: "-1",
              isHighlighted: highlightedIndex === index || selectedItem && selectedItem.id === item.id || false,
              title: itemToElement ? item.text : itemToString(item)
            }, itemProps), itemToElement ? /*#__PURE__*/React__default.createElement(ItemToElement, _extends({
              key: itemProps.id
            }, item)) : itemToString(item), selectedItem === item && /*#__PURE__*/React__default.createElement(Checkmark16, {
              className: "".concat(prefix$n, "--list-box__menu-item__selected-icon")
            }));
          }))), helperText && !invalid && /*#__PURE__*/React__default.createElement("div", {
            id: comboBoxHelperId,
            className: helperClasses
          }, helperText));
        });
      }
    }]);

    return ComboBox;
  }(React__default.Component);

  _defineProperty(ComboBox, "propTypes", {
    /**
     * 'aria-label' of the ListBox component.
     */
    ariaLabel: PropTypes.string,

    /**
     * An optional className to add to the container node
     */
    className: PropTypes.string,

    /**
     * Specify if the control should be disabled, or not
     */
    disabled: PropTypes.bool,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes.string.isRequired,

    /**
     * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
     * from their collection that are pre-selected
     */
    initialSelectedItem: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes.array.isRequired,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list
     */
    itemToString: PropTypes.func,

    /**
     * Optional function to render items as custom components instead of strings.
     * Defaults to null and is overriden by a getter
     */
    itemToElement: PropTypes.func,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component when a specific dropdown item is selected.
     * @param {{ selectedItem }}
     */
    onChange: PropTypes.func.isRequired,

    /**
     * Used to provide a placeholder text node before a user enters any input.
     * This is only present if the control has no items selected
     */
    placeholder: PropTypes.string.isRequired,

    /**
     * Specify your own filtering logic by passing in a `shouldFilterItem`
     * function that takes in the current input and an item and passes back
     * whether or not the item should be filtered.
     */
    shouldFilterItem: PropTypes.func,

    /**
     * Specify if the currently selected value is invalid.
     */
    invalid: PropTypes.bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes.string,

    /**
     * For full control of the selection
     */
    selectedItem: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),

    /**
     * Specify a custom translation function that takes in a message identifier
     * and returns the localized string for the message
     */
    translateWithId: PropTypes.func,

    /**
     * Currently supports either the default type, or an inline variant
     */
    type: ListBoxType,

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `lg` or `xl` as an option.
     */
    size: ListBoxSize,

    /**
     * Callback function to notify consumer when the text input changes.
     * This provides support to change available items based on the text.
     * @param {string} inputText
     */
    onInputChange: PropTypes.func,

    /**
     * should use "light theme" (white background)?
     */
    light: PropTypes.bool,

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes.shape(Downshift.propTypes),

    /**
     * Specify the direction of the combobox dropdown. Can be either top or bottom.
     */
    direction: PropTypes.oneOf(['top', 'bottom']),
    titleText: PropTypes.string,
    helperText: PropTypes.string
  });

  _defineProperty(ComboBox, "defaultProps", {
    disabled: false,
    itemToString: defaultItemToString,
    itemToElement: null,
    shouldFilterItem: defaultShouldFilterItem,
    type: 'default',
    ariaLabel: 'Choose an item',
    light: false,
    direction: 'bottom'
  });

  function toggleClass(element, name, add) {
    if (element.classList.contains(name) === !add) {
      element.classList[add ? 'add' : 'remove'](name);
    }
  }

  /**
   * @param {Function} name The name of the prop that must exist to validate
   * the current prop.
   * @param {Function} propType The original prop type checker.
   * @returns {Function} The new prop type checker for the current prop that
   * becomes required if the prop corresponding to the provided prop name exists.
   */
  function requiredIfGivenPropIsTruthy(name, propType) {
    return function check(props, propName, componentName) {
      if ( props[name] == true && props[propName] == null) {
        return new Error("You must provide a value for `".concat(propName, "` in `").concat(componentName, "` if `").concat(name, "` exists."));
      }

      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(void 0, [props, propName, componentName].concat(rest));
    };
  }

  var lodash_findlast = createCommonjsModule(function (module, exports) {
    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used as the `TypeError` message for "Functions" methods. */

    var FUNC_ERROR_TEXT = 'Expected a function';
    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used to compose bitmasks for comparison styles. */

    var UNORDERED_COMPARE_FLAG = 1,
        PARTIAL_COMPARE_FLAG = 2;
    /** Used as references for various `Number` constants. */

    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /** Used to match property names within property paths. */

    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        reLeadingDot = /^\./,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to match leading and trailing whitespace. */

    var reTrim = /^\s+|\s+$/g;
    /** Used to match backslashes in property paths. */

    var reEscapeChar = /\\(\\)?/g;
    /** Used to detect bad signed hexadecimal string values. */

    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    /** Used to detect binary string values. */

    var reIsBinary = /^0b[01]+$/i;
    /** Used to detect host constructors (Safari). */

    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect octal string values. */

    var reIsOctal = /^0o[0-7]+$/i;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /** Built-in method references without a dependency on `root`. */

    var freeParseInt = parseInt;
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */

    var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */

    var freeExports =  exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        return freeProcess && freeProcess.binding('util');
      } catch (e) {}
    }();
    /* Node.js helper references. */


    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */

    function arraySome(array, predicate) {
      var index = -1,
          length = array ? array.length : 0;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }

      return false;
    }
    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */


    function baseProperty(key) {
      return function (object) {
        return object == null ? undefined : object[key];
      };
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */


    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */


    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */


    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;

      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }

      return result;
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */


    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */


    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */


    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    /** Used for built-in method references. */


    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */

    var coreJsData = root['__core-js_shared__'];
    /** Used to detect methods masquerading as native. */

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    /** Used to resolve the decompiled source of functions. */


    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var objectToString = objectProto.toString;
    /** Used to detect if a method is native. */

    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */

    var _Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min;
    /* Built-in method references that are verified to be native. */

    var DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */

    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */

    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Hash(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */


    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function hashGet(key) {
      var data = this.__data__;

      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */


    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    } // Add methods to `Hash`.


    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function ListCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */


    function listCacheClear() {
      this.__data__ = [];
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */


    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    } // Add methods to `ListCache`.


    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function MapCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */


    function mapCacheClear() {
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function mapCacheDelete(key) {
      return getMapData(this, key)['delete'](key);
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */


    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    } // Add methods to `MapCache`.


    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */

    function SetCache(values) {
      var index = -1,
          length = values ? values.length : 0;
      this.__data__ = new MapCache();

      while (++index < length) {
        this.add(values[index]);
      }
    }
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */


    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);

      return this;
    }
    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */


    function setCacheHas(value) {
      return this.__data__.has(value);
    } // Add methods to `SetCache`.


    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */


    function stackClear() {
      this.__data__ = new ListCache();
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function stackDelete(key) {
      return this.__data__['delete'](key);
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */


    function stackSet(key, value) {
      var cache = this.__data__;

      if (cache instanceof ListCache) {
        var pairs = cache.__data__;

        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }

        cache = this.__data__ = new MapCache(pairs);
      }

      cache.set(key, value);
      return this;
    } // Add methods to `Stack`.


    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      // Safari 9 makes `arguments.length` enumerable in strict mode.
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length,
          skipIndexes = !!length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */


    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }

      return index && index == length ? object : undefined;
    }
    /**
     * The base implementation of `getTag`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    function baseGetTag(value) {
      return objectToString.call(value);
    }
    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */


    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {boolean} [bitmask] The bitmask of comparison flags.
     *  The bitmask may be composed of the following flags:
     *     1 - Unordered comparison
     *     2 - Partial comparison
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */


    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }

      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }

      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }

      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }

      var objIsObj = objTag == objectTag && !isHostObject(object),
          othIsObj = othTag == objectTag && !isHostObject(other),
          isSameTag = objTag == othTag;

      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }

      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }

      if (!isSameTag) {
        return false;
      }

      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */


    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }

      object = Object(object);

      while (index--) {
        var data = matchData[index];

        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }

      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();

          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }

          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */


    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }

      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */


    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */


    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }

      if (value == null) {
        return identity;
      }

      if (_typeof(value) == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }

      return property(value);
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */


    function baseMatches(source) {
      var matchData = getMatchData(source);

      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }

      return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */


    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }

      return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */


    function basePropertyDeep(path) {
      return function (object) {
        return baseGet(object, path);
      };
    }
    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */


    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }

      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }

      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */


    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */


    function createFind(findIndexFunc) {
      return function (collection, predicate, fromIndex) {
        var iterable = Object(collection);

        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate);
          collection = keys(collection);

          predicate = function predicate(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }

        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */


    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(array);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var index = -1,
          result = true,
          seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
      stack.set(array, other);
      stack.set(other, array); // Ignore non-index properties.

      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }

        if (compared !== undefined) {
          if (compared) {
            continue;
          }

          result = false;
          break;
        } // Recursively compare arrays (susceptible to call stack limits).


        if (seen) {
          if (!arraySome(other, function (othValue, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }

      stack['delete'](array);
      stack['delete'](other);
      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }

          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }

          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == other + '';

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          } // Assume cyclic values are equal.


          var stacked = stack.get(object);

          if (stacked) {
            return stacked == other;
          }

          bitmask |= UNORDERED_COMPARE_FLAG; // Recursively compare objects (susceptible to call stack limits).

          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }

      }

      return false;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
          objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }

      var index = objLength;

      while (index--) {
        var key = objProps[index];

        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;

      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        } // Recursively compare objects (susceptible to call stack limits).


        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }

        skipCtor || (skipCtor = key == 'constructor');
      }

      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }

      stack['delete'](object);
      stack['delete'](other);
      return result;
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */


    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */


    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }

      return result;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */


    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
    // for data views in Edge < 14, and promises in Node.js.

    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function getTag(value) {
        var result = objectToString.call(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : undefined;

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;

            case mapCtorString:
              return mapTag;

            case promiseCtorString:
              return promiseTag;

            case setCtorString:
              return setTag;

            case weakMapCtorString:
              return weakMapTag;
          }
        }

        return result;
      };
    }
    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */


    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result,
          index = -1,
          length = path.length;

      while (++index < length) {
        var key = toKey(path[index]);

        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }

        object = object[key];
      }

      if (result) {
        return result;
      }

      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */


    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */


    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }

      var type = _typeof(value);

      if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
      }

      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */


    function isKeyable(value) {
      var type = _typeof(value);

      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */


    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */


    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */


    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */


    function matchesStrictComparable(key, srcValue) {
      return function (object) {
        if (object == null) {
          return false;
        }

        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
      };
    }
    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */


    var stringToPath = memoize(function (string) {
      string = toString(string);
      var result = [];

      if (reLeadingDot.test(string)) {
        result.push('');
      }

      string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
      });
      return result;
    });
    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */

    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }

      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */


    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }
    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */


    function findLastIndex(array, predicate, fromIndex) {
      var length = array ? array.length : 0;

      if (!length) {
        return -1;
      }

      var index = length - 1;

      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }

      return baseFindIndex(array, baseIteratee(predicate), index, true);
    }
    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */


    var findLast = createFind(findLastIndex);
    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */

    function memoize(func, resolver) {
      if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }

      var memoized = function memoized() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }

        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };

      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    } // Assign cache to `_.memoize`.


    memoize.Cache = MapCache;
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */

    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    function isArguments(value) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */


    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */


    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */


    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8-9 which returns 'object' for typed array and other constructors.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */


    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = _typeof(value);

      return !!value && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */


    function isObjectLike(value) {
      return !!value && _typeof(value) == 'object';
    }
    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */


    function isSymbol(value) {
      return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */


    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */

    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }

      value = toNumber(value);

      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }

      return value === value ? value : 0;
    }
    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */


    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */


    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }

      if (isSymbol(value)) {
        return NAN;
      }

      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
      }

      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }

      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */


    function toString(value) {
      return value == null ? '' : baseToString(value);
    }
    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */


    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }
    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */


    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */


    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */


    function identity(value) {
      return value;
    }
    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */


    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    module.exports = findLast;
  });

  var prefix$o = settings_1.prefix;
  /**
   * @param {Node} node A DOM node.
   * @param {string[]} selectorsFloatingMenus The CSS selectors that matches floating menus.
   * @returns {boolean} `true` of the given `node` is in a floating menu.
   */

  function elementOrParentIsFloatingMenu(node) {
    var selectorsFloatingMenus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [".".concat(prefix$o, "--overflow-menu-options"), ".".concat(prefix$o, "--tooltip"), '.flatpickr-calendar'];

    if (node && typeof node.closest === 'function') {
      return selectorsFloatingMenus.some(function (selector) {
        return node.closest(selector);
      });
    }
  }
  /**
   * Ensures the focus is kept in the given `modalNode`, implementing "focus-wrap" behavior.
   * @param {object} options The options.
   * @param {Node} options.modalNode The DOM node of the inner modal.
   * @param {Node} options.startTrapNode The DOM node of the focus sentinel the is placed earlier next to `modalNode`.
   * @param {Node} options.endTrapNode The DOM node of the focus sentinel the is placed next to `modalNode`.
   * @param {Node} options.currentActiveNode The DOM node that has focus.
   * @param {Node} options.oldActiveNode The DOM node that previously had focus.
   * @param {Node} [options.selectorsFloatingMenus] The CSS selectors that matches floating menus.
   */


  function wrapFocus(_ref) {
    var modalNode = _ref.modalNode,
        startTrapNode = _ref.startTrapNode,
        endTrapNode = _ref.endTrapNode,
        currentActiveNode = _ref.currentActiveNode,
        oldActiveNode = _ref.oldActiveNode,
        selectorsFloatingMenus = _ref.selectorsFloatingMenus;

    if (modalNode && currentActiveNode && oldActiveNode && !modalNode.contains(currentActiveNode) && !elementOrParentIsFloatingMenu(currentActiveNode, selectorsFloatingMenus)) {
      var comparisonResult = oldActiveNode.compareDocumentPosition(currentActiveNode);

      if (currentActiveNode === startTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_PRECEDING) {
        var tabbable = lodash_findlast(modalNode.querySelectorAll(selectorTabbable), function (elem) {
          return Boolean(elem.offsetParent);
        });

        if (tabbable) {
          tabbable.focus();
        } else if (modalNode !== oldActiveNode) {
          modalNode.focus();
        }
      } else if (currentActiveNode === endTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_FOLLOWING) {
        var _tabbable = Array.prototype.find.call(modalNode.querySelectorAll(selectorTabbable), function (elem) {
          return Boolean(elem.offsetParent);
        });

        if (_tabbable) {
          _tabbable.focus();
        } else if (modalNode !== oldActiveNode) {
          modalNode.focus();
        }
      }
    }
  }

  var prefix$p = settings_1.prefix;

  var ComposedModal = /*#__PURE__*/function (_Component) {
    _inherits(ComposedModal, _Component);

    var _super = _createSuper(ComposedModal);

    function ComposedModal() {
      var _this;

      _classCallCheck(this, ComposedModal);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {});

      _defineProperty(_assertThisInitialized(_this), "outerModal", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "innerModal", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "button", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "startSentinel", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "endSentinel", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "handleKeyDown", function (evt) {
        // Esc key
        if (evt.which === 27) {
          _this.closeModal(evt);
        }

        _this.props.onKeyDown(evt);
      });

      _defineProperty(_assertThisInitialized(_this), "handleClick", function (evt) {
        if (_this.innerModal.current && !_this.innerModal.current.contains(evt.target)) {
          _this.closeModal(evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleBlur", function (_ref) {
        var oldActiveNode = _ref.target,
            currentActiveNode = _ref.relatedTarget;
        var _this$props = _this.props,
            open = _this$props.open,
            selectorsFloatingMenus = _this$props.selectorsFloatingMenus;

        if (open && currentActiveNode && oldActiveNode) {
          var modalNode = _this.innerModal.current;
          var startSentinelNode = _this.startSentinel.current;
          var endSentinelNode = _this.endSentinel.current;
          wrapFocus({
            modalNode: modalNode,
            startSentinelNode: startSentinelNode,
            endSentinelNode: endSentinelNode,
            currentActiveNode: currentActiveNode,
            oldActiveNode: oldActiveNode,
            selectorsFloatingMenus: selectorsFloatingMenus
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "focusButton", function (focusContainerElement) {
        if (focusContainerElement) {
          var primaryFocusElement = focusContainerElement.querySelector(_this.props.selectorPrimaryFocus);

          if (primaryFocusElement) {
            primaryFocusElement.focus();
            return;
          }

          if (_this.button.current) {
            _this.button.current.focus();
          }
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleTransitionEnd", function (evt) {
        if (_this.outerModal.current.offsetWidth && _this.outerModal.current.offsetHeight && _this.beingOpen) {
          _this.focusButton(evt.currentTarget);

          _this.beingOpen = false;
        }
      });

      _defineProperty(_assertThisInitialized(_this), "closeModal", function (evt) {
        var onClose = _this.props.onClose;

        if (!onClose || onClose(evt) !== false) {
          _this.setState({
            open: false
          });
        }
      });

      return _this;
    }

    _createClass(ComposedModal, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (!prevState.open && this.state.open) {
          this.beingOpen = true;
        } else if (prevState.open && !this.state.open) {
          this.beingOpen = false;
        }

        toggleClass(document.body, "".concat(prefix$p, "--body--with-modal-open"), this.state.open);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        toggleClass(document.body, "".concat(prefix$p, "--body--with-modal-open"), false);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        toggleClass(document.body, "".concat(prefix$p, "--body--with-modal-open"), this.props.open);

        if (!this.props.open) {
          return;
        }

        if (this.innerModal.current) {
          this.focusButton(this.innerModal.current);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames,
            _classNames2,
            _this2 = this;

        var open = this.state.open;

        var _this$props2 = this.props,
            className = _this$props2.className,
            containerClassName = _this$props2.containerClassName,
            children = _this$props2.children,
            danger = _this$props2.danger,
            selectorPrimaryFocus = _this$props2.selectorPrimaryFocus,
            size = _this$props2.size,
            other = _objectWithoutProperties(_this$props2, ["className", "containerClassName", "children", "danger", "selectorPrimaryFocus", "size"]);

        var modalClass = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$p, "--modal"), true), _defineProperty(_classNames, 'is-visible', open), _defineProperty(_classNames, className, className), _defineProperty(_classNames, "".concat(prefix$p, "--modal--danger"), danger), _classNames));
        var containerClass = classnames((_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$p, "--modal-container"), true), _defineProperty(_classNames2, "".concat(prefix$p, "--modal-container--").concat(size), size), _defineProperty(_classNames2, containerClassName, containerClassName), _classNames2));
        var childrenWithProps = React__default.Children.toArray(children).map(function (child) {
          switch (child.type) {
            case /*#__PURE__*/React__default.createElement(ModalHeader).type:
              return /*#__PURE__*/React__default.cloneElement(child, {
                closeModal: _this2.closeModal
              });

            case /*#__PURE__*/React__default.createElement(ModalFooter).type:
              return /*#__PURE__*/React__default.cloneElement(child, {
                closeModal: _this2.closeModal,
                inputref: _this2.button
              });

            default:
              return child;
          }
        });
        return /*#__PURE__*/React__default.createElement("div", _extends({}, other, {
          role: "presentation",
          ref: this.outerModal,
          onBlur: this.handleBlur,
          onClick: this.handleClick,
          onKeyDown: this.handleKeyDown,
          onTransitionEnd: open ? this.handleTransitionEnd : undefined,
          className: modalClass
        }), /*#__PURE__*/React__default.createElement("span", {
          ref: this.startSentinel,
          tabIndex: "0",
          role: "link",
          className: "".concat(prefix$p, "--visually-hidden")
        }, "Focus sentinel"), /*#__PURE__*/React__default.createElement("div", {
          ref: this.innerModal,
          className: containerClass,
          role: "dialog"
        }, childrenWithProps), /*#__PURE__*/React__default.createElement("span", {
          ref: this.endSentinel,
          tabIndex: "0",
          role: "link",
          className: "".concat(prefix$p, "--visually-hidden")
        }, "Focus sentinel"));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, state) {
        var open = _ref2.open;
        var prevOpen = state.prevOpen;
        return prevOpen === open ? null : {
          open: open,
          prevOpen: open
        };
      }
    }]);

    return ComposedModal;
  }(React.Component);

  _defineProperty(ComposedModal, "defaultProps", {
    onKeyDown: function onKeyDown() {},
    selectorPrimaryFocus: '[data-modal-primary-focus]'
  });

  _defineProperty(ComposedModal, "propTypes", {
    /**
     * Specify an optional className to be applied to the modal root node
     */
    className: PropTypes.string,

    /**
     * Specify an optional className to be applied to the modal node
     */
    containerClassName: PropTypes.string,

    /**
     * Specify an optional handler for closing modal.
     * Returning `false` here prevents closing modal.
     */
    onClose: PropTypes.func,

    /**
     * Specify an optional handler for the `onKeyDown` event. Called for all
     * `onKeyDown` events that do not close the modal
     */
    onKeyDown: PropTypes.func,

    /**
     * Specify whether the Modal is currently open
     */
    open: PropTypes.bool,

    /**
     * Specify a CSS selector that matches the DOM element that should be
     * focused when the Modal opens
     */
    selectorPrimaryFocus: PropTypes.string,

    /**
     * Specify the CSS selectors that match the floating menus
     */
    selectorsFloatingMenus: PropTypes.string,

    /**
     * Specify the content to be placed in the ComposedModal
     */
    children: PropTypes.node,

    /**
     * Specify whether the primary button should be replaced with danger button.
     * Note that this prop is not applied if you render primary/danger button by yourself
     */
    danger: PropTypes.bool,

    /**
     * Specify the size variant.
     */
    size: PropTypes.oneOf(['xs', 'sm', 'lg'])
  });
  var ModalHeader = /*#__PURE__*/function (_Component2) {
    _inherits(ModalHeader, _Component2);

    var _super2 = _createSuper(ModalHeader);

    function ModalHeader() {
      var _this3;

      _classCallCheck(this, ModalHeader);

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this3 = _super2.call.apply(_super2, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this3), "handleCloseButtonClick", function (evt) {
        _this3.props.closeModal(evt);

        _this3.props.buttonOnClick();
      });

      return _this3;
    }

    _createClass(ModalHeader, [{
      key: "render",
      value: function render() {
        var _classNames3, _classNames4, _classNames5, _classNames6, _classNames7;

        var _this$props3 = this.props,
            className = _this$props3.className,
            labelClassName = _this$props3.labelClassName,
            titleClassName = _this$props3.titleClassName,
            closeClassName = _this$props3.closeClassName,
            closeIconClassName = _this$props3.closeIconClassName,
            label = _this$props3.label,
            title = _this$props3.title,
            children = _this$props3.children,
            iconDescription = _this$props3.iconDescription,
            closeModal = _this$props3.closeModal,
            buttonOnClick = _this$props3.buttonOnClick,
            other = _objectWithoutProperties(_this$props3, ["className", "labelClassName", "titleClassName", "closeClassName", "closeIconClassName", "label", "title", "children", "iconDescription", "closeModal", "buttonOnClick"]);

        var headerClass = classnames((_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$p, "--modal-header"), true), _defineProperty(_classNames3, className, className), _classNames3));
        var labelClass = classnames((_classNames4 = {}, _defineProperty(_classNames4, "".concat(prefix$p, "--modal-header__label ").concat(prefix$p, "--type-delta"), true), _defineProperty(_classNames4, labelClassName, labelClassName), _classNames4));
        var titleClass = classnames((_classNames5 = {}, _defineProperty(_classNames5, "".concat(prefix$p, "--modal-header__heading ").concat(prefix$p, "--type-beta"), true), _defineProperty(_classNames5, titleClassName, titleClassName), _classNames5));
        var closeClass = classnames((_classNames6 = {}, _defineProperty(_classNames6, "".concat(prefix$p, "--modal-close"), true), _defineProperty(_classNames6, closeClassName, closeClassName), _classNames6));
        var closeIconClass = classnames((_classNames7 = {}, _defineProperty(_classNames7, "".concat(prefix$p, "--modal-close__icon"), true), _defineProperty(_classNames7, closeIconClassName, closeIconClassName), _classNames7));
        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: headerClass
        }, other), label && /*#__PURE__*/React__default.createElement("p", {
          className: labelClass
        }, label), title && /*#__PURE__*/React__default.createElement("p", {
          className: titleClass
        }, title), children, /*#__PURE__*/React__default.createElement("button", {
          onClick: this.handleCloseButtonClick,
          className: closeClass,
          title: iconDescription,
          "aria-label": iconDescription,
          type: "button"
        }, /*#__PURE__*/React__default.createElement(Close20, {
          className: closeIconClass
        })));
      }
    }]);

    return ModalHeader;
  }(React.Component);

  _defineProperty(ModalHeader, "propTypes", {
    /**
     * Specify an optional className to be applied to the modal header
     */
    className: PropTypes.string,

    /**
     * Specify an optional className to be applied to the modal header label
     */
    labelClassName: PropTypes.string,

    /**
     * Specify an optional className to be applied to the modal heading
     */
    titleClassName: PropTypes.string,

    /**
     * Specify an optional className to be applied to the modal close node
     */
    closeClassName: PropTypes.string,

    /**
     * Specify an optional className to be applied to the modal close icon node
     */
    closeIconClassName: PropTypes.string,

    /**
     * Specify an optional label to be displayed
     */
    label: PropTypes.node,

    /**
     * Specify an optional title to be displayed
     */
    title: PropTypes.node,

    /**
     * Specify the content to be placed in the ModalHeader
     */
    children: PropTypes.node,

    /**
     * Specify a description for the close icon that can be read by screen
     * readers
     */
    iconDescription: PropTypes.string,

    /**
     * Provide an optional function to be called when the modal is closed
     */
    closeModal: PropTypes.func,

    /**
     * Provide an optional function to be called when the close button is
     * clicked
     */
    buttonOnClick: PropTypes.func
  });

  _defineProperty(ModalHeader, "defaultProps", {
    iconDescription: 'Close',
    buttonOnClick: function buttonOnClick() {}
  });

  function ModalBody(props) {
    var _classNames8;

    var className = props.className,
        children = props.children,
        hasForm = props.hasForm,
        hasScrollingContent = props.hasScrollingContent,
        other = _objectWithoutProperties(props, ["className", "children", "hasForm", "hasScrollingContent"]);

    var contentClass = classnames((_classNames8 = {}, _defineProperty(_classNames8, "".concat(prefix$p, "--modal-content"), true), _defineProperty(_classNames8, "".concat(prefix$p, "--modal-content--with-form"), hasForm), _defineProperty(_classNames8, className, className), _classNames8));
    var hasScrollingContentProps = hasScrollingContent ? {
      tabIndex: 0,
      role: 'region'
    } : {};
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", _extends({
      className: contentClass
    }, hasScrollingContentProps, other), children), hasScrollingContent && /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$p, "--modal-content--overflow-indicator")
    }));
  }
  ModalBody.propTypes = _defineProperty({
    /**
     * Specify an optional className to be added to the Modal Body node
     */
    className: PropTypes.string,

    /**
     * Specify the content to be placed in the ModalBody
     */
    children: PropTypes.node,

    /**
     * Provide whether the modal content has a form element.
     * If `true` is used here, non-form child content should have `bx--modal-content__regular-content` class.
     */
    hasForm: PropTypes.bool,

    /**
     * Specify whether the modal contains scrolling content
     */
    hasScrollingContent: PropTypes.bool
  }, 'aria-label', requiredIfGivenPropIsTruthy('hasScrollingContent', PropTypes.string));
  var ModalFooter = /*#__PURE__*/function (_Component3) {
    _inherits(ModalFooter, _Component3);

    var _super3 = _createSuper(ModalFooter);

    function ModalFooter() {
      var _this4;

      _classCallCheck(this, ModalFooter);

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      _this4 = _super3.call.apply(_super3, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this4), "handleRequestClose", function (evt) {
        _this4.props.closeModal(evt);

        _this4.props.onRequestClose(evt);
      });

      return _this4;
    }

    _createClass(ModalFooter, [{
      key: "render",
      value: function render() {
        var _classNames9;

        var _this$props4 = this.props,
            className = _this$props4.className,
            primaryClassName = _this$props4.primaryClassName,
            secondaryClassName = _this$props4.secondaryClassName,
            secondaryButtonText = _this$props4.secondaryButtonText,
            primaryButtonText = _this$props4.primaryButtonText,
            primaryButtonDisabled = _this$props4.primaryButtonDisabled,
            closeModal = _this$props4.closeModal,
            onRequestClose = _this$props4.onRequestClose,
            onRequestSubmit = _this$props4.onRequestSubmit,
            children = _this$props4.children,
            danger = _this$props4.danger,
            inputref = _this$props4.inputref,
            other = _objectWithoutProperties(_this$props4, ["className", "primaryClassName", "secondaryClassName", "secondaryButtonText", "primaryButtonText", "primaryButtonDisabled", "closeModal", "onRequestClose", "onRequestSubmit", "children", "danger", "inputref"]);

        var footerClass = classnames((_classNames9 = {}, _defineProperty(_classNames9, "".concat(prefix$p, "--modal-footer"), true), _defineProperty(_classNames9, className, className), _classNames9));
        var primaryClass = classnames(_defineProperty({}, primaryClassName, primaryClassName));
        var secondaryClass = classnames(_defineProperty({}, secondaryClassName, secondaryClassName));
        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: footerClass
        }, other), secondaryButtonText && /*#__PURE__*/React__default.createElement(Button, {
          className: secondaryClass,
          onClick: this.handleRequestClose,
          kind: "secondary"
        }, secondaryButtonText), primaryButtonText && /*#__PURE__*/React__default.createElement(Button, {
          onClick: onRequestSubmit,
          className: primaryClass,
          disabled: primaryButtonDisabled,
          kind: danger ? 'danger' : 'primary',
          ref: inputref
        }, primaryButtonText), children);
      }
    }]);

    return ModalFooter;
  }(React.Component);

  _defineProperty(ModalFooter, "propTypes", {
    /**
     * Specify a custom className to be applied to the Modal Footer container
     */
    className: PropTypes.string,

    /**
     * Specify a custom className to be applied to the primary button
     */
    primaryClassName: PropTypes.string,

    /**
     * Specify the text for the primary button
     */
    primaryButtonText: PropTypes.string,

    /**
     * Specify whether the primary button should be disabled
     */
    primaryButtonDisabled: PropTypes.bool,

    /**
     * Specify a custom className to be applied to the secondary button
     */
    secondaryClassName: PropTypes.string,

    /**
     * Specify the text for the secondary button
     */
    secondaryButtonText: PropTypes.string,

    /**
     * Specify whether the primary button should be replaced with danger button.
     * Note that this prop is not applied if you render primary/danger button by yourself
     */
    danger: PropTypes.bool,

    /**
     * Specify an optional function for when the modal is requesting to be
     * closed
     */
    onRequestClose: PropTypes.func,

    /**
     * Specify an optional function for when the modal is requesting to be
     * submitted
     */
    onRequestSubmit: PropTypes.func,

    /**
     * Specify an optional function that is called whenever the modal is closed
     */
    closeModal: PropTypes.func,

    /**
     * Pass in content that will be rendered in the Modal Footer
     */
    children: PropTypes.node,

    /**
     * The `ref` callback for the primary button.
     */
    inputref: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({
      current: PropTypes.any
    })])
  });

  _defineProperty(ModalFooter, "defaultProps", {
    onRequestClose: function onRequestClose() {},
    onRequestSubmit: function onRequestSubmit() {}
  });

  var prefix$q = settings_1.prefix;

  var ContentSwitcher$1 = /*#__PURE__*/function (_React$Component) {
    _inherits(ContentSwitcher, _React$Component);

    var _super = _createSuper(ContentSwitcher);

    function ContentSwitcher() {
      var _this;

      _classCallCheck(this, ContentSwitcher);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "_switchRefs", []);

      _defineProperty(_assertThisInitialized(_this), "state", {});

      _defineProperty(_assertThisInitialized(_this), "handleItemRef", function (index) {
        return function (ref) {
          _this._switchRefs[index] = ref;
        };
      });

      _defineProperty(_assertThisInitialized(_this), "handleChildChange", function (data) {
        var selectionMode = _this.props.selectionMode; // the currently selected child index

        var selectedIndex = _this.state.selectedIndex; // the newly selected child index

        var index = data.index;
        var key = data.key;

        if (matches(data, [ArrowRight, ArrowLeft])) {
          var nextIndex = getNextIndex(key, index, _this.props.children.length);

          if (selectionMode === 'manual') {
            var switchRef = _this._switchRefs[nextIndex];
            switchRef && switchRef.focus();
          } else {
            _this.setState({
              selectedIndex: nextIndex
            }, function () {
              var switchRef = _this._switchRefs[nextIndex];
              switchRef && switchRef.focus();

              _this.props.onChange(data);
            });
          }
        } else if (selectedIndex !== index) {
          _this.setState({
            selectedIndex: index
          }, function () {
            var switchRef = _this._switchRefs[index];
            switchRef && switchRef.focus();

            _this.props.onChange(data);
          });
        }
      });

      return _this;
    }

    _createClass(ContentSwitcher, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            children = _this$props.children,
            className = _this$props.className,
            light = _this$props.light,
            selectedIndex = _this$props.selectedIndex,
            selectionMode = _this$props.selectionMode,
            other = _objectWithoutProperties(_this$props, ["children", "className", "light", "selectedIndex", "selectionMode"]);

        var classes = classnames("".concat(prefix$q, "--content-switcher"), className, _defineProperty({}, "".concat(prefix$q, "--content-switcher--light"), light));
        return /*#__PURE__*/React__default.createElement("div", _extends({}, other, {
          className: classes,
          role: "tablist"
        }), React__default.Children.map(children, function (child, index) {
          return /*#__PURE__*/React__default.cloneElement(child, {
            index: index,
            onClick: composeEventHandlers([_this2.handleChildChange, child.props.onClick]),
            onKeyDown: _this2.handleChildChange,
            selected: index === _this2.state.selectedIndex,
            ref: _this2.handleItemRef(index)
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var selectedIndex = _ref.selectedIndex;
        var prevSelectedIndex = state.prevSelectedIndex;
        return prevSelectedIndex === selectedIndex ? null : {
          selectedIndex: selectedIndex,
          prevSelectedIndex: selectedIndex
        };
      }
    }]);

    return ContentSwitcher;
  }(React__default.Component);

  _defineProperty(ContentSwitcher$1, "propTypes", {
    /**
     * Pass in Switch components to be rendered in the ContentSwitcher
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be added to the container node
     */
    className: PropTypes.string,

    /**
     * `true` to use the light variant.
     */
    light: PropTypes.bool,

    /**
     * Specify an `onChange` handler that is called whenever the ContentSwitcher
     * changes which item is selected
     */
    onChange: PropTypes.func.isRequired,

    /**
     * Specify a selected index for the initially selected content
     */
    selectedIndex: PropTypes.number,

    /**
     * Choose whether or not to automatically change selection on focus
     */
    selectionMode: PropTypes.oneOf(['automatic', 'manual'])
  });

  _defineProperty(ContentSwitcher$1, "defaultProps", {
    selectedIndex: 0,
    selectionMode: 'automatic'
  });

  var DangerButton = function DangerButton(props) {
    return /*#__PURE__*/React__default.createElement(Button, _extends({
      kind: "danger"
    }, props));
  };

  var lodash_isequal = createCommonjsModule(function (module, exports) {
    /**
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright JS Foundation and other contributors <https://js.foundation/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used to compose bitmasks for value comparisons. */

    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;
    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;
    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to detect host constructors (Safari). */

    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */

    var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */

    var freeExports =  exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();
    /* Node.js helper references. */


    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */

    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }

      return result;
    }
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */


    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }

      return array;
    }
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */


    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }

      return false;
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */


    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */


    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function cacheHas(cache, key) {
      return cache.has(key);
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */


    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */


    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */


    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    /** Used for built-in method references. */


    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */

    var coreJsData = root['__core-js_shared__'];
    /** Used to resolve the decompiled source of functions. */

    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /** Used to detect methods masquerading as native. */

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */


    var nativeObjectToString = objectProto.toString;
    /** Used to detect if a method is native. */

    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */

    var Buffer = moduleExports ? root.Buffer : undefined,
        _Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeKeys = overArg(Object.keys, Object);
    /* Built-in method references that are verified to be native. */

    var DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */

    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */

    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */


    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function hashGet(key) {
      var data = this.__data__;

      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */


    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    } // Add methods to `Hash`.


    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */


    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      --this.size;
      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */


    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    } // Add methods to `ListCache`.


    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */


    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */


    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    } // Add methods to `MapCache`.


    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */

    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();

      while (++index < length) {
        this.add(values[index]);
      }
    }
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */


    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);

      return this;
    }
    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */


    function setCacheHas(value) {
      return this.__data__.has(value);
    } // Add methods to `SetCache`.


    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */


    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);
      this.size = data.size;
      return result;
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */


    function stackSet(key, value) {
      var data = this.__data__;

      if (data instanceof ListCache) {
        var pairs = data.__data__;

        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }

        data = this.__data__ = new MapCache(pairs);
      }

      data.set(key, value);
      this.size = data.size;
      return this;
    } // Add methods to `Stack`.


    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */


    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */


    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }

      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }

      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }

        objIsArr = true;
        objIsObj = false;
      }

      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }

      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }

      if (!isSameTag) {
        return false;
      }

      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */


    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }

      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */


    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */


    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(array);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var index = -1,
          result = true,
          seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
      stack.set(array, other);
      stack.set(other, array); // Ignore non-index properties.

      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }

        if (compared !== undefined) {
          if (compared) {
            continue;
          }

          result = false;
          break;
        } // Recursively compare arrays (susceptible to call stack limits).


        if (seen) {
          if (!arraySome(other, function (othValue, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }

      stack['delete'](array);
      stack['delete'](other);
      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }

          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }

          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == other + '';

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          } // Assume cyclic values are equal.


          var stacked = stack.get(object);

          if (stacked) {
            return stacked == other;
          }

          bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }

      }

      return false;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }

      var index = objLength;

      while (index--) {
        var key = objProps[index];

        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;

      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        } // Recursively compare objects (susceptible to call stack limits).


        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }

        skipCtor || (skipCtor = key == 'constructor');
      }

      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }

      stack['delete'](object);
      stack['delete'](other);
      return result;
    }
    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */


    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */


    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */


    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }

      return result;
    }
    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */


    var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
      if (object == null) {
        return [];
      }

      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function (symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function getTag(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;

            case mapCtorString:
              return mapTag;

            case promiseCtorString:
              return promiseTag;

            case setCtorString:
              return setTag;

            case weakMapCtorString:
              return weakMapTag;
          }
        }

        return result;
      };
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */


    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */


    function isKeyable(value) {
      var type = _typeof(value);

      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */


    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */


    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */


    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */


    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */


    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */


    var isBuffer = nativeIsBuffer || stubFalse;
    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */

    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */


    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */


    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = _typeof(value);

      return value != null && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */


    function isObjectLike(value) {
      return value != null && _typeof(value) == 'object';
    }
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */


    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */


    function stubArray() {
      return [];
    }
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */


    function stubFalse() {
      return false;
    }

    module.exports = isEqual;
  });

  /**
   * Generic helper used to consolidate all call sites for getting a cell id into
   * one method. The strategy currently is that a "cellId" is just the combination
   * of the row id and the header key used to access this field in a row.
   *
   * @param {string} rowId
   * @param {string} header
   * @returns {string}
   */
  var getCellId = function getCellId(rowId, header) {
    return "".concat(rowId, ":").concat(header);
  };

  /**
   * Compare two primitives to determine which comes first. Initially, this method
   * will try and figure out if both entries are the same type. If so, it will
   * apply the default sort algorithm for those types. Otherwise, it defaults to a
   * string conversion.
   *
   * @param {number|string} a
   * @param {number|string} b
   * @param {string} locale
   * @returns {number}
   */

  var compare = function compare(a, b) {
    var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';

    if (typeof a === 'number' && typeof b === 'number') {
      return a - b;
    }

    if (typeof a === 'string' && typeof b === 'string') {
      return compareStrings(a, b, locale);
    }

    return compareStrings('' + a, '' + b, locale);
  };
  /**
   * Use the built-in `localeCompare` function available on strings to compare two
   * srints.
   *
   * @param {string} a
   * @param {string} b
   * @param {string} locale
   * @returns {number}
   */

  var compareStrings = function compareStrings(a, b) {
    var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';
    return a.localeCompare(b, locale, {
      numeric: true
    });
  };
  /**
   * Default implementation of how we sort rows internally. The idea behind this
   * implementation is to use the given list of row ids to look up the cells in
   * the row by the given key. We then use the value of these cells and pipe them
   * into our local `compareStrings` method, including the locale where
   * appropriate.
   *
   * @param {object} config
   * @param {Array[string]} config.rowIds array of all the row ids in the table
   * @param {object} config.cellsById object containing a mapping of cell id to
   * cell
   * @param {string} config.direction the sort direction used to determine the
   * order the comparison is called in
   * @param {string} config.key the header key that we use to lookup the cell
   * @param {string} [config.locale] optional locale used in the comparison
   * function
   * @returns {Array[string]} array of sorted rowIds
   */

  var sortRows = function sortRows(_ref) {
    var rowIds = _ref.rowIds,
        cellsById = _ref.cellsById,
        sortDirection = _ref.sortDirection,
        key = _ref.key,
        locale = _ref.locale,
        sortRow = _ref.sortRow;
    return rowIds.slice().sort(function (a, b) {
      var cellA = cellsById[getCellId(a, key)];
      var cellB = cellsById[getCellId(b, key)];
      return sortRow(cellA.value, cellB.value, {
        key: key,
        sortDirection: sortDirection,
        locale: locale,
        sortStates: sortStates,
        compare: compare
      });
    });
  };
  var defaultSortRow = function defaultSortRow(cellA, cellB, _ref2) {
    var sortDirection = _ref2.sortDirection,
        sortStates = _ref2.sortStates,
        locale = _ref2.locale;

    if (sortDirection === sortStates.ASC) {
      return compare(cellA, cellB, locale);
    }

    return compare(cellB, cellA, locale);
  };

  /**
   * We currently support the following sorting states for DataTable headers,
   * namely: `NONE` for no sorting being applied, and then `DESC` and `ASC` for
   * the corresponding direction of the sorting order.
   */

  var sortStates = {
    NONE: 'NONE',
    DESC: 'DESC',
    ASC: 'ASC'
  }; // Our initialSortState should be `NONE`, unless a consumer has specified a
  // different initialSortState

  var initialSortState = sortStates.NONE;
  /**
   * Utility used to get the next sort state given the following pieces of
   * information:
   *
   * @param {string} prevHeader the value of the previous header
   * @param {string} header the value of the currently selected header
   * @param {string} prevState the previous sort state of the table
   * @returns {string}
   */

  var getNextSortDirection = function getNextSortDirection(prevHeader, header, prevState) {
    // If the previous header is equivalent to the current header, we know that we
    // have to derive the next sort state from the previous sort state
    if (prevHeader === header) {
      // When transitioning, we know that the sequence of states is as follows:
      // NONE -> ASC -> DESC -> NONE
      if (prevState === 'NONE') {
        return sortStates.ASC;
      }

      if (prevState === 'ASC') {
        return sortStates.DESC;
      }

      return sortStates.NONE;
    } // Otherwise, we have selected a new header and need to start off by sorting
    // in descending order by default


    return sortStates.ASC;
  };
  var getNextSortState = function getNextSortState(props, state, _ref) {
    var key = _ref.key;
    var sortDirection = state.sortDirection,
        sortHeaderKey = state.sortHeaderKey;
    var nextSortDirection = getNextSortDirection(key, sortHeaderKey, sortDirection);
    return getSortedState(props, state, key, nextSortDirection);
  };
  /**
   * Derive the set of sorted state fields from props and state for the given
   * header key and sortDirection
   *
   * @param {object} props
   * @param {string} props.locale The current locale
   * @param {Function} props.sortRows Method to handle sorting a collection of
   * rows
   * @param {object} state
   * @param {Array<string>} state.rowIds Array of row ids
   * @param {object} state.cellsById Lookup object for cells by id
   * @param {Array<string>} state.initialRowOrder Initial row order for the
   * current set of rows
   * @param {string} key The key for the given header we are derving the
   * sorted state for
   * @param {string} sortDirection The sortState that we want to order by
   * @returns {object}
   */

  var getSortedState = function getSortedState(props, state, key, sortDirection) {
    var rowIds = state.rowIds,
        cellsById = state.cellsById,
        initialRowOrder = state.initialRowOrder;
    var locale = props.locale,
        sortRow = props.sortRow;
    var nextRowIds = sortDirection !== sortStates.NONE ? sortRows({
      rowIds: rowIds,
      cellsById: cellsById,
      sortDirection: sortDirection,
      key: key,
      locale: locale,
      sortRow: sortRow
    }) : initialRowOrder;
    return {
      sortHeaderKey: key,
      sortDirection: sortDirection,
      rowIds: nextRowIds
    };
  };

  /**
   * Normalize a collection of rows with the given headers.
   *
   * @param {Array<object>} rows
   * @param {Array<object>} headers
   * @returns {object}
   */

  var normalize = function normalize(rows, headers) {
    var prevState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var prevRowsByIds = prevState.rowsById;
    var rowIds = new Array(rows.length);
    var rowsById = {};
    var cellsById = {};
    rows.forEach(function (row, i) {
      rowIds[i] = row.id; // Initialize the row info and state values, namely for selection and
      // expansion

      var id = row.id,
          _row$isSelected = row.isSelected,
          isSelected = _row$isSelected === void 0 ? false : _row$isSelected,
          _row$isExpanded = row.isExpanded,
          isExpanded = _row$isExpanded === void 0 ? false : _row$isExpanded,
          _row$disabled = row.disabled,
          disabled = _row$disabled === void 0 ? false : _row$disabled;
      rowsById[id] = {
        id: id,
        isSelected: isSelected,
        isExpanded: isExpanded,
        disabled: disabled,
        cells: new Array(headers.length)
      }; // If we have a previous state, and the row existed in that previous state,
      // then we'll set the state values of the row to the previous state values.

      if (prevRowsByIds && prevRowsByIds[row.id] !== undefined) {
        rowsById[row.id].isSelected = prevRowsByIds[row.id].isSelected;
        rowsById[row.id].isExpanded = prevRowsByIds[row.id].isExpanded;
      }

      headers.forEach(function (_ref, i) {
        var key = _ref.key;
        var id = getCellId(row.id, key); // Initialize the cell info and state values, namely for editing

        cellsById[id] = {
          id: id,
          value: row[key],
          isEditable: false,
          isEditing: false,
          isValid: true,
          errors: null,
          info: {
            header: key
          }
        }; // TODO: When working on inline edits, we'll need to derive the state
        // values similarly to rows above.

        rowsById[row.id].cells[i] = id;
      });
    });
    return {
      rowIds: rowIds,
      rowsById: rowsById,
      cellsById: cellsById
    };
  };

  /**
   * Helper to derive the next state from the given props and the
   * prevState. Potential future-facing API hook for React v17.
   *
   * Currently, it's being used as a way to normalize the incoming data that we
   * are receiving for rows
   */

  var getDerivedStateFromProps = function getDerivedStateFromProps(props, prevState) {
    var _normalize = normalize(props.rows, props.headers, prevState),
        rowIds = _normalize.rowIds,
        rowsById = _normalize.rowsById,
        cellsById = _normalize.cellsById;

    var state = {
      rowIds: rowIds,
      rowsById: rowsById,
      cellsById: cellsById,
      sortDirection: prevState.sortDirection || initialSortState,
      sortHeaderKey: prevState.sortHeaderKey || null,
      // Copy over rowIds so the reference doesn't mutate the stored
      // `initialRowOrder`
      initialRowOrder: rowIds.slice(),
      filterInputValue: prevState.filterInputValue || null,
      // Optional state field to indicate whether a consumer should show a
      // batch actions menu
      shouldShowBatchActions: prevState.shouldShowBatchActions || false
    };

    if (prevState.sortDirection && prevState.sortHeaderKey) {
      var _getSortedState = getSortedState(props, state, prevState.sortHeaderKey, prevState.sortDirection),
          _rowIds = _getSortedState.rowIds;

      state.rowIds = _rowIds;
    }

    return state;
  };

  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Counterpart to `normalize` for a collection of rows. This method unravels the
   * normalization step that we use to build the given parameters in order to
   * return a natural interface to working with rows for a consumer.
   *
   * The default heuristic here is to map through all the row ids and return the
   * value of the row for the given id, in addition to adding a `cells` key that
   * contains the results of mapping over the rows cells and getting individual
   * cell info.
   *
   * @param {Array<string>} rowIds array of row ids in the table
   * @param {object} rowsById object containing lookups for rows by id
   * @param {object} cellsById object containing lookups for cells by id
   */
  var denormalize = function denormalize(rowIds, rowsById, cellsById) {
    return rowIds.map(function (id) {
      return _objectSpread2(_objectSpread2({}, rowsById[id]), {}, {
        cells: rowsById[id].cells.map(function (cellId) {
          return cellsById[cellId];
        })
      });
    });
  };

  /**
   * Default implemention of how we filter rows internally. The idea behind this
   * implementation is to use the given list of row ids and headers to get the
   * individual cell values for a row. Then, we go through each cell value and see
   * if any of them includes the given inputValue.
   *
   * @param {object} config
   * @param {Array<string>} config.rowIds array of all the row ids in the table
   * @param {Array<object>} config.headers
   * @param {object} config.cellsById object containing a map of cell id to cell
   * @param {string} config.inputValue the current input value in the Table Search
   * @returns {Array<string>} rowIds
   */

  var defaultFilterRows = function defaultFilterRows(_ref) {
    var rowIds = _ref.rowIds,
        headers = _ref.headers,
        cellsById = _ref.cellsById,
        inputValue = _ref.inputValue;
    return rowIds.filter(function (rowId) {
      return headers.some(function (_ref2) {
        var key = _ref2.key;
        var id = getCellId(rowId, key);
        if (typeof cellsById[id].value === 'boolean') return false;
        return ('' + cellsById[id].value).toLowerCase().includes(inputValue.toLowerCase());
      });
    });
  };

  /**
   * Generic utility to initialize a method that will return a unique instance id
   * for a component.
   */
  var setupGetInstanceId$1 = function setupGetInstanceId() {
    var instanceId = 0;
    return function getInstanceId() {
      return ++instanceId;
    };
  };

  var _defaultTranslations$2;
  var getInstanceId$1 = setupGetInstanceId$1();
  var translationKeys = {
    expandRow: 'carbon.table.row.expand',
    collapseRow: 'carbon.table.row.collapse',
    expandAll: 'carbon.table.all.expand',
    collapseAll: 'carbon.table.all.collapse',
    selectAll: 'carbon.table.all.select',
    unselectAll: 'carbon.table.all.unselect',
    selectRow: 'carbon.table.row.select',
    unselectRow: 'carbon.table.row.unselect'
  };
  var defaultTranslations$2 = (_defaultTranslations$2 = {}, _defineProperty(_defaultTranslations$2, translationKeys.expandAll, 'Expand all rows'), _defineProperty(_defaultTranslations$2, translationKeys.collapseAll, 'Collapse all rows'), _defineProperty(_defaultTranslations$2, translationKeys.expandRow, 'Expand current row'), _defineProperty(_defaultTranslations$2, translationKeys.collapseRow, 'Collapse current row'), _defineProperty(_defaultTranslations$2, translationKeys.selectAll, 'Select all rows'), _defineProperty(_defaultTranslations$2, translationKeys.unselectAll, 'Unselect all rows'), _defineProperty(_defaultTranslations$2, translationKeys.selectRow, 'Select row'), _defineProperty(_defaultTranslations$2, translationKeys.unselectRow, 'Unselect row'), _defaultTranslations$2);

  var translateWithId = function translateWithId(id) {
    return defaultTranslations$2[id];
  };
  /**
   * Data Tables are used to represent a collection of resources, displaying a
   * subset of their fields in columns, or headers. We prioritize direct updates
   * to the state of what we're rendering, so internally we end up normalizing the
   * given data and then denormalizing it when rendering.
   *
   * As a result, each part of the DataTable is accessible through look-up by id,
   * and updating the state of the single entity will cascade updates to the
   * consumer.
   */


  var DataTable$1 = /*#__PURE__*/function (_React$Component) {
    _inherits(DataTable, _React$Component);

    var _super = _createSuper(DataTable);

    function DataTable(_props) {
      var _this;

      _classCallCheck(this, DataTable);

      _this = _super.call(this, _props);

      _defineProperty(_assertThisInitialized(_this), "getHeaderProps", function (_ref) {
        var header = _ref.header,
            onClick = _ref.onClick,
            _ref$isSortable = _ref.isSortable,
            isSortable = _ref$isSortable === void 0 ? _this.props.isSortable : _ref$isSortable,
            rest = _objectWithoutProperties(_ref, ["header", "onClick", "isSortable"]);

        var _this$state = _this.state,
            sortDirection = _this$state.sortDirection,
            sortHeaderKey = _this$state.sortHeaderKey;
        return _objectSpread2(_objectSpread2({}, rest), {}, {
          key: header.key,
          sortDirection: sortDirection,
          isSortable: isSortable,
          isSortHeader: sortHeaderKey === header.key,
          // Compose the event handlers so we don't overwrite a consumer's `onClick`
          // handler
          onClick: composeEventHandlers([_this.handleSortBy(header.key), onClick ? _this.handleOnHeaderClick(onClick, {
            sortHeaderKey: header.key,
            sortDirection: sortDirection
          }) : null])
        });
      });

      _defineProperty(_assertThisInitialized(_this), "getExpandHeaderProps", function () {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            onClick = _ref2.onClick,
            rest = _objectWithoutProperties(_ref2, ["onClick"]);

        var t = _this.props.translateWithId;
        var _this$state2 = _this.state,
            isExpandedAll = _this$state2.isExpandedAll,
            rowIds = _this$state2.rowIds,
            rowsById = _this$state2.rowsById;
        var isExpanded = isExpandedAll || rowIds.every(function (id) {
          return rowsById[id].isExpanded;
        });
        var translationKey = !isExpanded ? translationKeys.collapseAll : translationKeys.expandAll;
        return _objectSpread2(_objectSpread2({}, rest), {}, {
          ariaLabel: t(translationKey),
          isExpanded: isExpanded,
          // Compose the event handlers so we don't overwrite a consumer's `onClick`
          // handler
          onExpand: composeEventHandlers([_this.handleOnExpandAll, onClick ? _this.handleOnExpandHeaderClick(onClick, {
            isExpanded: isExpanded
          }) : null])
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnHeaderClick", function (onClick, sortParams) {
        return function (e) {
          return onClick(e, sortParams);
        };
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnExpandHeaderClick", function (onClick, expandParams) {
        return function (e) {
          return onClick(e, expandParams);
        };
      });

      _defineProperty(_assertThisInitialized(_this), "getRowProps", function (_ref3) {
        var row = _ref3.row,
            onClick = _ref3.onClick,
            rest = _objectWithoutProperties(_ref3, ["row", "onClick"]);

        var t = _this.props.translateWithId;
        var translationKey = row.isExpanded ? translationKeys.collapseRow : translationKeys.expandRow;
        return _objectSpread2(_objectSpread2({}, rest), {}, {
          key: row.id,
          // Compose the event handlers so we don't overwrite a consumer's `onClick`
          // handler
          onExpand: composeEventHandlers([_this.handleOnExpandRow(row.id), onClick]),
          isExpanded: row.isExpanded,
          ariaLabel: t(translationKey),
          isSelected: row.isSelected,
          disabled: row.disabled
        });
      });

      _defineProperty(_assertThisInitialized(_this), "getSelectionProps", function () {
        var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            onClick = _ref4.onClick,
            row = _ref4.row,
            rest = _objectWithoutProperties(_ref4, ["onClick", "row"]);

        var t = _this.props.translateWithId; // If we're given a row, return the selection state values for that row

        if (row) {
          var _translationKey = row.isSelected ? translationKeys.unselectRow : translationKeys.selectRow;

          return _objectSpread2(_objectSpread2({}, rest), {}, {
            checked: row.isSelected,
            onSelect: composeEventHandlers([_this.handleOnSelectRow(row.id), onClick]),
            id: "".concat(_this.getTablePrefix(), "__select-row-").concat(row.id),
            name: "select-row-".concat(row.id),
            ariaLabel: t(_translationKey),
            disabled: row.disabled,
            radio: _this.props.radio || null
          });
        } // Otherwise, we're working on `TableSelectAll` which handles toggling the
        // selection state of all rows.


        var rowCount = _this.state.rowIds.length;

        var selectedRowCount = _this.getSelectedRows().length;

        var checked = rowCount > 0 && selectedRowCount === rowCount;
        var indeterminate = rowCount > 0 && selectedRowCount > 0 && selectedRowCount !== rowCount;
        var translationKey = checked || indeterminate ? translationKeys.unselectAll : translationKeys.selectAll;
        return _objectSpread2(_objectSpread2({}, rest), {}, {
          ariaLabel: t(translationKey),
          checked: checked,
          id: "".concat(_this.getTablePrefix(), "__select-all"),
          indeterminate: indeterminate,
          name: 'select-all',
          onSelect: composeEventHandlers([_this.handleSelectAll, onClick])
        });
      });

      _defineProperty(_assertThisInitialized(_this), "getToolbarProps", function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var size = _this.props.size;
        return _objectSpread2(_objectSpread2({}, props), {}, {
          size: size === 'compact' || size === 'short' ? 'small' : 'normal'
        });
      });

      _defineProperty(_assertThisInitialized(_this), "getBatchActionProps", function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var shouldShowBatchActions = _this.state.shouldShowBatchActions;

        var totalSelected = _this.getSelectedRows().length;

        return _objectSpread2(_objectSpread2({}, props), {}, {
          shouldShowBatchActions: shouldShowBatchActions,
          totalSelected: totalSelected,
          onCancel: _this.handleOnCancel
        });
      });

      _defineProperty(_assertThisInitialized(_this), "getTableProps", function () {
        var _this$props = _this.props,
            useZebraStyles = _this$props.useZebraStyles,
            size = _this$props.size,
            isSortable = _this$props.isSortable,
            useStaticWidth = _this$props.useStaticWidth,
            shouldShowBorder = _this$props.shouldShowBorder,
            stickyHeader = _this$props.stickyHeader,
            overflowMenuOnHover = _this$props.overflowMenuOnHover;
        return {
          useZebraStyles: useZebraStyles,
          size: size,
          isSortable: isSortable,
          useStaticWidth: useStaticWidth,
          shouldShowBorder: shouldShowBorder,
          stickyHeader: stickyHeader,
          overflowMenuOnHover: overflowMenuOnHover
        };
      });

      _defineProperty(_assertThisInitialized(_this), "getTableContainerProps", function () {
        var stickyHeader = _this.props.stickyHeader;
        return {
          stickyHeader: stickyHeader
        };
      });

      _defineProperty(_assertThisInitialized(_this), "getSelectedRows", function () {
        return _this.state.rowIds.filter(function (id) {
          var row = _this.state.rowsById[id];
          return row.isSelected && !row.disabled;
        });
      });

      _defineProperty(_assertThisInitialized(_this), "getFilteredRowIds", function () {
        var filteredRowIds = typeof _this.state.filterInputValue === 'string' ? _this.props.filterRows({
          rowIds: _this.state.rowIds,
          headers: _this.props.headers,
          cellsById: _this.state.cellsById,
          inputValue: _this.state.filterInputValue
        }) : _this.state.rowIds;

        if (filteredRowIds.length == 0) {
          return _this.state.rowIds;
        }

        return filteredRowIds;
      });

      _defineProperty(_assertThisInitialized(_this), "getTablePrefix", function () {
        return "data-table-".concat(_this.instanceId);
      });

      _defineProperty(_assertThisInitialized(_this), "setAllSelectedState", function (initialState, isSelected, filteredRowIds) {
        var rowIds = initialState.rowIds;
        return {
          rowsById: rowIds.reduce(function (acc, id) {
            return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, id, _objectSpread2(_objectSpread2({}, initialState.rowsById[id]), !initialState.rowsById[id].disabled && {
              isSelected: filteredRowIds.includes(id) && isSelected
            })));
          }, {})
        };
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnCancel", function () {
        _this.setState(function (state) {
          return _objectSpread2({
            shouldShowBatchActions: false
          }, _this.setAllSelectedState(state, false, _this.getFilteredRowIds()));
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleSelectAll", function () {
        _this.setState(function (state) {
          var filteredRowIds = _this.getFilteredRowIds();

          var rowsById = state.rowsById;
          var isSelected = !(Object.values(rowsById).filter(function (row) {
            return row.isSelected && !row.disabled;
          }).length > 0);
          return _objectSpread2({
            shouldShowBatchActions: isSelected
          }, _this.setAllSelectedState(state, isSelected, filteredRowIds));
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnSelectRow", function (rowId) {
        return function () {
          _this.setState(function (state) {
            var row = state.rowsById[rowId];

            if (_this.props.radio) {
              // deselect all radio buttons
              var rowsById = Object.entries(state.rowsById).reduce(function (p, c) {
                var _c = _slicedToArray(c, 2),
                    key = _c[0],
                    val = _c[1];

                val.isSelected = false;
                p[key] = val;
                return p;
              }, {});
              return {
                shouldShowBatchActions: false,
                rowsById: _objectSpread2(_objectSpread2({}, rowsById), {}, _defineProperty({}, rowId, _objectSpread2(_objectSpread2({}, row), {}, {
                  isSelected: !row.isSelected
                })))
              };
            }

            var selectedRows = state.rowIds.filter(function (id) {
              return state.rowsById[id].isSelected;
            }).length; // Predict the length of the selected rows after this change occurs

            var selectedRowsCount = !row.isSelected ? selectedRows + 1 : selectedRows - 1;
            return {
              // Basic assumption here is that we want to show the batch action bar if
              // the row is being selected. If it's being unselected, then see if we
              // have a non-zero number of selected rows that batch actions could
              // still apply to
              shouldShowBatchActions: !row.isSelected || selectedRowsCount > 0,
              rowsById: _objectSpread2(_objectSpread2({}, state.rowsById), {}, _defineProperty({}, rowId, _objectSpread2(_objectSpread2({}, row), {}, {
                isSelected: !row.isSelected
              })))
            };
          });
        };
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnExpandRow", function (rowId) {
        return function () {
          _this.setState(function (state) {
            var row = state.rowsById[rowId];
            var isExpandedAll = state.isExpandedAll;
            return {
              isExpandedAll: row.isExpanded ? false : isExpandedAll,
              rowsById: _objectSpread2(_objectSpread2({}, state.rowsById), {}, _defineProperty({}, rowId, _objectSpread2(_objectSpread2({}, row), {}, {
                isExpanded: !row.isExpanded
              })))
            };
          });
        };
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnExpandAll", function () {
        _this.setState(function (state) {
          var rowIds = state.rowIds,
              isExpandedAll = state.isExpandedAll;
          return {
            isExpandedAll: !isExpandedAll,
            rowsById: rowIds.reduce(function (acc, id) {
              return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, id, _objectSpread2(_objectSpread2({}, state.rowsById[id]), {}, {
                isExpanded: !isExpandedAll
              })));
            }, {})
          };
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleSortBy", function (headerKey) {
        return function () {
          _this.setState(function (state) {
            return getNextSortState(_this.props, state, {
              key: headerKey
            });
          });
        };
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnInputValueChange", function (event, defaultValue) {
        if (event.target) {
          _this.setState({
            filterInputValue: event.target.value
          });
        }

        if (defaultValue) {
          _this.setState({
            filterInputValue: defaultValue
          });
        }
      });

      _this.state = _objectSpread2(_objectSpread2({}, getDerivedStateFromProps(_props, {})), {}, {
        isExpandedAll: false // Start with collapsed state, treat `undefined` as neutral state

      });
      _this.instanceId = getInstanceId$1();
      return _this;
    }

    _createClass(DataTable, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this2 = this;

        if (prevProps === this.props) {
          return;
        }

        var prevRowIds = prevProps.rows.map(function (row) {
          return row.id;
        });
        var rowIds = this.props.rows.map(function (row) {
          return row.id;
        });

        if (!lodash_isequal(prevRowIds, rowIds)) {
          this.setState(function (state) {
            return getDerivedStateFromProps(_this2.props, state);
          });
          return;
        }

        var prevHeaders = prevProps.headers.map(function (header) {
          return header.key;
        });
        var headers = this.props.headers.map(function (header) {
          return header.key;
        });

        if (!lodash_isequal(prevHeaders, headers)) {
          this.setState(function (state) {
            return getDerivedStateFromProps(_this2.props, state);
          });
          return;
        }

        if (!lodash_isequal(prevProps.rows, this.props.rows)) {
          this.setState(function (state) {
            return getDerivedStateFromProps(_this2.props, state);
          });
          return;
        }
      }
      /**
       * Get the props associated with the given header. Mostly used for adding in
       * sorting behavior.
       *
       * @param {object} config
       * @param {string} config.header the header we want the props for
       * @param {Function} config.onClick a custom click handler for the header
       * @returns {object}
       */

    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        // eslint-disable-next-line react/prop-types
        var _this$props2 = this.props,
            children = _this$props2.children,
            filterRows = _this$props2.filterRows,
            headers = _this$props2.headers,
            render = _this$props2.render;
        var _this$state3 = this.state,
            filterInputValue = _this$state3.filterInputValue,
            rowIds = _this$state3.rowIds,
            rowsById = _this$state3.rowsById,
            cellsById = _this$state3.cellsById;
        var filteredRowIds = typeof filterInputValue === 'string' ? filterRows({
          rowIds: rowIds,
          headers: headers,
          cellsById: cellsById,
          inputValue: filterInputValue
        }) : rowIds;
        var renderProps = {
          // Data derived from state
          rows: denormalize(filteredRowIds, rowsById, cellsById),
          headers: this.props.headers,
          selectedRows: denormalize(this.getSelectedRows(), rowsById, cellsById),
          // Prop accessors/getters
          getHeaderProps: this.getHeaderProps,
          getExpandHeaderProps: this.getExpandHeaderProps,
          getRowProps: this.getRowProps,
          getSelectionProps: this.getSelectionProps,
          getToolbarProps: this.getToolbarProps,
          getBatchActionProps: this.getBatchActionProps,
          getTableProps: this.getTableProps,
          getTableContainerProps: this.getTableContainerProps,
          // Custom event handlers
          onInputChange: this.handleOnInputValueChange,
          // Expose internal state change actions
          sortBy: function sortBy(headerKey) {
            return _this3.handleSortBy(headerKey)();
          },
          selectAll: this.handleSelectAll,
          selectRow: function selectRow(rowId) {
            return _this3.handleOnSelectRow(rowId)();
          },
          expandRow: function expandRow(rowId) {
            return _this3.handleOnExpandRow(rowId)();
          },
          expandAll: this.handleOnExpandAll,
          radio: this.props.radio
        };

        if (render !== undefined) {
          return render(renderProps);
        }

        if (children !== undefined) {
          return children(renderProps);
        }

        return null;
      }
    }]);

    return DataTable;
  }(React__default.Component);

  _defineProperty(DataTable$1, "propTypes", {
    /**
     * The `rows` prop is where you provide us with a list of all the rows that
     * you want to render in the table. The only hard requirement is that this
     * is an array of objects, and that each object has a unique `id` field
     * available on it.
     */
    rows: PropTypes.arrayOf(PropTypes.shape({
      id: PropTypes.string.isRequired,
      disabled: PropTypes.bool,
      isSelected: PropTypes.bool,
      isExpanded: PropTypes.bool
    })).isRequired,

    /**
     * The `headers` prop represents the order in which the headers should
     * appear in the table. We expect an array of objects to be passed in, where
     * `key` is the name of the key in a row object, and `header` is the name of
     * the header.
     */
    headers: PropTypes.arrayOf(PropTypes.shape({
      key: PropTypes.string.isRequired,
      header: PropTypes.node.isRequired
    })).isRequired,

    /**
     * Optional hook to manually control sorting of the rows.
     */
    sortRow: PropTypes.func,

    /**
     * Optional hook to manually control filtering of the rows from the
     * TableToolbarSearch component
     */
    filterRows: PropTypes.func,

    /**
     * Provide a string for the current locale
     */
    locale: PropTypes.string,

    /**
     * Optional method that takes in a message id and returns an
     * internationalized string. See `DataTable.translationKeys` for all
     * available message ids.
     */
    translateWithId: PropTypes.func,

    /**
     * `normal` Change the row height of table
     */
    size: PropTypes.oneOf(['compact', 'short', 'normal', 'tall']),

    /**
     * Specify whether the control should be a radio button or inline checkbox
     */
    radio: PropTypes.bool,

    /**
     * Specify whether the header should be sticky.
     * Still experimental: may not work with every combination of table props
     */
    stickyHeader: PropTypes.bool,

    /**
     * Specify whether the table should be able to be sorted by its headers
     */
    isSortable: PropTypes.bool,

    /**
     * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
     */
    overflowMenuOnHover: PropTypes.bool,

    /**
     * `true` to add useZebraStyles striping.
     */
    useZebraStyles: PropTypes.bool,

    /**
     * `false` If true, will use a width of 'auto' instead of 100%
     */
    useStaticWidth: PropTypes.bool,

    /**
     * `false` If true, will remove the table border
     */
    shouldShowBorder: PropTypes.bool
  });

  _defineProperty(DataTable$1, "defaultProps", {
    sortRow: defaultSortRow,
    filterRows: defaultFilterRows,
    locale: 'en',
    size: 'normal',
    overflowMenuOnHover: true,
    translateWithId: translateWithId
  });

  _defineProperty(DataTable$1, "translationKeys", Object.values(translationKeys));

  var prefix$r = settings_1.prefix;
  var Table = function Table(_ref) {
    var _cx;

    var className = _ref.className,
        children = _ref.children,
        useZebraStyles = _ref.useZebraStyles,
        size = _ref.size,
        isSortable = _ref.isSortable,
        useStaticWidth = _ref.useStaticWidth,
        shouldShowBorder = _ref.shouldShowBorder,
        stickyHeader = _ref.stickyHeader,
        overflowMenuOnHover = _ref.overflowMenuOnHover,
        other = _objectWithoutProperties(_ref, ["className", "children", "useZebraStyles", "size", "isSortable", "useStaticWidth", "shouldShowBorder", "stickyHeader", "overflowMenuOnHover"]);

    var componentClass = classnames("".concat(prefix$r, "--data-table"), className, (_cx = {}, _defineProperty(_cx, "".concat(prefix$r, "--data-table--compact"), size === 'compact'), _defineProperty(_cx, "".concat(prefix$r, "--data-table--short"), size === 'short'), _defineProperty(_cx, "".concat(prefix$r, "--data-table--tall"), size === 'tall'), _defineProperty(_cx, "".concat(prefix$r, "--data-table--sort"), isSortable), _defineProperty(_cx, "".concat(prefix$r, "--data-table--zebra"), useZebraStyles), _defineProperty(_cx, "".concat(prefix$r, "--data-table--static"), useStaticWidth), _defineProperty(_cx, "".concat(prefix$r, "--data-table--no-border"), !shouldShowBorder), _defineProperty(_cx, "".concat(prefix$r, "--data-table--sticky-header"), stickyHeader), _defineProperty(_cx, "".concat(prefix$r, "--data-table--visible-overflow-menu"), !overflowMenuOnHover), _cx));
    var table = /*#__PURE__*/React__default.createElement("table", _extends({}, other, {
      className: componentClass
    }), children);
    return stickyHeader ? /*#__PURE__*/React__default.createElement("section", {
      className: "".concat(prefix$r, "--data-table_inner-container")
    }, table) : table;
  };
  Table.propTypes = {
    className: PropTypes.string,

    /**
     * `true` to add useZebraStyles striping.
     */
    useZebraStyles: PropTypes.bool,

    /**
     * `normal` Change the row height of table
     */
    size: PropTypes.oneOf(['compact', 'short', 'normal', 'tall']),

    /**
     * `false` If true, will use a width of 'auto' instead of 100%
     */
    useStaticWidth: PropTypes.bool,

    /**
     * `false` If true, will remove the table border
     */
    shouldShowBorder: PropTypes.bool,

    /**
     * `false` If true, will apply sorting styles
     */
    isSortable: PropTypes.bool,

    /**
     * `false` If true, will keep the header sticky (only data rows will scroll)
     */
    stickyHeader: PropTypes.bool,

    /**
     * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
     */
    overflowMenuOnHover: PropTypes.bool,

    /**
     * Pass in the children that will be rendered within the Table
     */
    children: PropTypes.node
  };
  Table.defaultProps = {
    isSortable: false,
    overflowMenuOnHover: true
  };

  var wrapComponent = function wrapComponent(_ref) {
    var name = _ref.name,
        className = _ref.className,
        type = _ref.type;

    var Component = function Component(_ref2) {
      var baseClassName = _ref2.className,
          other = _objectWithoutProperties(_ref2, ["className"]);

      var componentClass = classnames(className, baseClassName);
      return /*#__PURE__*/React__default.createElement(type, _objectSpread2(_objectSpread2({}, other), {}, {
        // Prevent Weird quirk where `cx` will evaluate to an empty string, '',
        // and so we have empty `class` attributes in the resulting markup
        // eslint-disable-next-line no-extra-boolean-cast
        className: !!componentClass ? componentClass : undefined
      }));
    };

    Component.displayName = name;
    Component.propTypes = {
      className: PropTypes.string
    };
    return Component;
  };

  var prefix$s = settings_1.prefix;
  var TableActionList = wrapComponent({
    name: 'TableActionList',
    type: 'div',
    className: "".concat(prefix$s, "--action-list")
  });

  var TableBatchAction = function TableBatchAction(props) {
    return /*#__PURE__*/React__default.createElement(Button, props);
  };

  TableBatchAction.propTypes = {
    /**
     * Specify if the button is an icon-only button
     */
    hasIconOnly: PropTypes.bool,

    /**
     * If specifying the `renderIcon` prop, provide a description for that icon that can
     * be read by screen readers
     */
    iconDescription: function iconDescription(props) {
      if (props.renderIcon && !props.children && !props.iconDescription) {
        return new Error('renderIcon property specified without also providing an iconDescription property.');
      }

      return undefined;
    },

    /**
     * Optional function to render your own icon in the underlying button
     */
    renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  };
  TableBatchAction.defaultProps = {
    renderIcon: AddFilled16
  };

  var prefix$t = settings_1.prefix;
  var translationKeys$1 = {
    'carbon.table.batch.cancel': 'Cancel',
    'carbon.table.batch.items.selected': 'items selected',
    'carbon.table.batch.item.selected': 'item selected'
  };

  var translateWithId$1 = function translateWithId(id, state) {
    if (id === 'carbon.table.batch.cancel') {
      return translationKeys$1[id];
    }

    return "".concat(state.totalSelected, " ").concat(translationKeys$1[id]);
  };

  var TableBatchActions = function TableBatchActions(_ref) {
    var _cx;

    var className = _ref.className,
        children = _ref.children,
        shouldShowBatchActions = _ref.shouldShowBatchActions,
        totalSelected = _ref.totalSelected,
        onCancel = _ref.onCancel,
        t = _ref.translateWithId,
        rest = _objectWithoutProperties(_ref, ["className", "children", "shouldShowBatchActions", "totalSelected", "onCancel", "translateWithId"]);

    var batchActionsClasses = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$t, "--batch-actions"), true), _defineProperty(_cx, "".concat(prefix$t, "--batch-actions--active"), shouldShowBatchActions), _cx), className);
    return /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
      className: batchActionsClasses
    }), /*#__PURE__*/React__default.createElement(TableActionList, null, children, /*#__PURE__*/React__default.createElement(Button, {
      className: "".concat(prefix$t, "--batch-summary__cancel"),
      tabIndex: shouldShowBatchActions ? 0 : -1,
      onClick: onCancel
    }, t('carbon.table.batch.cancel'))), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$t, "--batch-summary")
    }, /*#__PURE__*/React__default.createElement("p", {
      className: "".concat(prefix$t, "--batch-summary__para")
    }, /*#__PURE__*/React__default.createElement("span", null, totalSelected > 1 ? t('carbon.table.batch.items.selected', {
      totalSelected: totalSelected
    }) : t('carbon.table.batch.item.selected', {
      totalSelected: totalSelected
    })))));
  };

  TableBatchActions.translationKeys = Object.keys(translationKeys$1);
  TableBatchActions.propTypes = {
    children: PropTypes.node,
    className: PropTypes.string,

    /**
     * Boolean specifier for whether or not the batch action bar should be
     * displayed
     */
    shouldShowBatchActions: PropTypes.bool,

    /**
     * Numeric representation of the total number of items selected in a table.
     * This number is used to derive the selection message
     */
    totalSelected: PropTypes.number.isRequired,

    /**
     * Hook required to listen for when the user initiates a cancel request
     * through this comopnent
     */
    onCancel: PropTypes.func.isRequired,

    /**
     * Supply a method to translate internal strings with your i18n tool of
     * choice. Translation keys are avabile on the `translationKeys` field for
     * this component.
     */
    translateWithId: PropTypes.func
  };
  TableBatchActions.defaultProps = {
    translateWithId: translateWithId$1
  };

  var TableBody = function TableBody(_ref) {
    var children = _ref.children,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["children", "className"]);

    return /*#__PURE__*/React__default.createElement("tbody", _extends({
      className: className
    }, rest), children);
  };

  TableBody.propTypes = {
    className: PropTypes.string,
    children: PropTypes.node,

    /**
     * `polite` Adjust the notification behavior of screen readers
     */
    'aria-live': PropTypes.oneOf(['polite', 'assertive', 'off'])
  };
  TableBody.defaultProps = {
    'aria-live': 'polite'
  };

  var TableCell = wrapComponent({
    name: 'TableCell',
    type: 'td'
  });

  var prefix$u = settings_1.prefix;

  var TableContainer = function TableContainer(_ref) {
    var className = _ref.className,
        children = _ref.children,
        title = _ref.title,
        description = _ref.description,
        stickyHeader = _ref.stickyHeader,
        rest = _objectWithoutProperties(_ref, ["className", "children", "title", "description", "stickyHeader"]);

    var tableContainerClasses = classnames(className, "".concat(prefix$u, "--data-table-container"), _defineProperty({}, "".concat(prefix$u, "--data-table--max-width"), stickyHeader));
    return /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
      className: tableContainerClasses
    }), title && /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$u, "--data-table-header")
    }, /*#__PURE__*/React__default.createElement("h4", {
      className: "".concat(prefix$u, "--data-table-header__title")
    }, title), /*#__PURE__*/React__default.createElement("p", {
      className: "".concat(prefix$u, "--data-table-header__description")
    }, description)), children);
  };

  TableContainer.propTypes = {
    className: PropTypes.string,
    children: PropTypes.node,

    /**
     * Provide a title for the Table
     */
    title: PropTypes.node,

    /**
     * Optional description text for the Table
     */
    description: PropTypes.node,

    /**
     * Specify whether the table should have a sticky header
     */
    stickyHeader: PropTypes.bool
  };

  var prefix$v = settings_1.prefix;

  var TableExpandHeader = function TableExpandHeader(_ref) {
    var ariaLabel = _ref.ariaLabel,
        headerClassName = _ref.className,
        enableExpando = _ref.enableExpando,
        isExpanded = _ref.isExpanded,
        onExpand = _ref.onExpand,
        expandIconDescription = _ref.expandIconDescription,
        children = _ref.children,
        rest = _objectWithoutProperties(_ref, ["ariaLabel", "className", "enableExpando", "isExpanded", "onExpand", "expandIconDescription", "children"]);

    var className = classnames("".concat(prefix$v, "--table-expand"), headerClassName);
    var previousValue = isExpanded ? 'collapsed' : undefined;
    return /*#__PURE__*/React__default.createElement("th", _extends({
      scope: "col",
      className: className,
      "data-previous-value": previousValue
    }, rest), !enableExpando ? null : /*#__PURE__*/React__default.createElement("button", {
      className: "".concat(prefix$v, "--table-expand__button"),
      onClick: onExpand,
      title: expandIconDescription,
      "aria-label": ariaLabel
    }, /*#__PURE__*/React__default.createElement(ChevronRight16, {
      className: "".concat(prefix$v, "--table-expand__svg"),
      "aria-label": expandIconDescription
    })), children);
  };

  TableExpandHeader.propTypes = {
    className: PropTypes.string,
    children: PropTypes.node,

    /**
     * Specify whether an expand all button should be displayed
     */
    enableExpando: PropTypes.bool,

    /**
     * Specify the string read by a voice reader when the expand trigger is
     * focused
     */
    ariaLabel: requiredIfGivenPropIsTruthy('enableExpando', PropTypes.string),

    /**
     * Specify whether this row is expanded or not. This helps coordinate data
     * attributes so that `TableExpandRow` and `TableExapndedRow` work together
     */
    isExpanded: requiredIfGivenPropIsTruthy('enableExpando', PropTypes.bool),

    /**
     * Hook for when a listener initiates a request to expand the given row
     */
    onExpand: requiredIfGivenPropIsTruthy('enableExpando', PropTypes.func),

    /**
     * The description of the chevron right icon, to be put in its SVG `<title>` element.
     */
    expandIconDescription: PropTypes.string
  };

  var prefix$w = settings_1.prefix;

  var TableExpandRow = function TableExpandRow(_ref) {
    var _cx;

    var ariaLabel = _ref.ariaLabel,
        rowClassName = _ref.className,
        children = _ref.children,
        isExpanded = _ref.isExpanded,
        onExpand = _ref.onExpand,
        expandIconDescription = _ref.expandIconDescription,
        isSelected = _ref.isSelected,
        expandHeader = _ref.expandHeader,
        rest = _objectWithoutProperties(_ref, ["ariaLabel", "className", "children", "isExpanded", "onExpand", "expandIconDescription", "isSelected", "expandHeader"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$w, "--parent-row"), true), _defineProperty(_cx, "".concat(prefix$w, "--expandable-row"), isExpanded), _defineProperty(_cx, "".concat(prefix$w, "--data-table--selected"), isSelected), _cx), rowClassName);
    var previousValue = isExpanded ? 'collapsed' : undefined;
    return /*#__PURE__*/React__default.createElement("tr", _extends({}, rest, {
      className: className,
      "data-parent-row": true
    }), /*#__PURE__*/React__default.createElement(TableCell, {
      className: "".concat(prefix$w, "--table-expand"),
      "data-previous-value": previousValue,
      headers: expandHeader
    }, /*#__PURE__*/React__default.createElement("button", {
      className: "".concat(prefix$w, "--table-expand__button"),
      onClick: onExpand,
      title: expandIconDescription,
      "aria-label": ariaLabel
    }, /*#__PURE__*/React__default.createElement(ChevronRight16, {
      className: "".concat(prefix$w, "--table-expand__svg"),
      "aria-label": expandIconDescription
    }))), children);
  };

  TableExpandRow.propTypes = {
    /**
     * Specify the string read by a voice reader when the expand trigger is
     * focused
     */
    ariaLabel: PropTypes.string.isRequired,
    className: PropTypes.string,
    children: PropTypes.node,

    /**
     * Specify whether this row is expanded or not. This helps coordinate data
     * attributes so that `TableExpandRow` and `TableExapndedRow` work together
     */
    isExpanded: PropTypes.bool.isRequired,

    /**
     * Specify if the row is selected
     */
    isSelected: PropTypes.bool,

    /**
     * Hook for when a listener initiates a request to expand the given row
     */
    onExpand: PropTypes.func.isRequired,

    /**
     * The description of the chevron right icon, to be put in its SVG `<title>` element.
     */
    expandIconDescription: PropTypes.string,

    /**
     * The id of the matching th node in the table head. Addresses a11y concerns outlined here: https://www.ibm.com/able/guidelines/ci162/info_and_relationships.html and https://www.w3.org/TR/WCAG20-TECHS/H43
     */
    expandHeader: PropTypes.string
  };
  TableExpandRow.defaultProps = {
    expandHeader: 'expand'
  };

  var prefix$x = settings_1.prefix;

  var TableExpandedRow = function TableExpandedRow(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        colSpan = _ref.colSpan,
        rest = _objectWithoutProperties(_ref, ["className", "children", "colSpan"]);

    var rowRef = React.useRef(null);
    var className = classnames("".concat(prefix$x, "--expandable-row"), customClassName);

    var toggleParentHoverClass = function toggleParentHoverClass(eventType) {
      if (rowRef && rowRef.current && rowRef.current.previousElementSibling) {
        var parentNode = rowRef.current.previousElementSibling;

        if (eventType === 'enter') {
          parentNode.classList.add("".concat(prefix$x, "--expandable-row--hover"));
        } else {
          parentNode.classList.remove("".concat(prefix$x, "--expandable-row--hover"));
        }
      }
    };

    return /*#__PURE__*/React__default.createElement("tr", _extends({
      ref: rowRef,
      onMouseEnter: function onMouseEnter() {
        return toggleParentHoverClass('enter');
      },
      onMouseLeave: function onMouseLeave() {
        return toggleParentHoverClass('leave');
      }
    }, rest, {
      className: className,
      "data-child-row": true
    }), /*#__PURE__*/React__default.createElement(TableCell, {
      colSpan: colSpan
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$x, "--child-row-inner-container")
    }, children)));
  };

  TableExpandedRow.propTypes = {
    /**
     * Pass in the contents for your TableExpandedRow
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * The width of the expanded row's internal cell
     */
    colSpan: PropTypes.number.isRequired
  };

  var TableHead = wrapComponent({
    name: 'TableHead',
    type: 'thead'
  });

  var _sortDirections;
  var prefix$y = settings_1.prefix;
  var translationKeys$2 = {
    iconDescription: 'carbon.table.header.icon.description'
  };

  var translateWithId$2 = function translateWithId(key, _ref) {
    var sortDirection = _ref.sortDirection,
        isSortHeader = _ref.isSortHeader,
        sortStates = _ref.sortStates;

    if (key === translationKeys$2.iconDescription) {
      if (isSortHeader) {
        // When transitioning, we know that the sequence of states is as follows:
        // NONE -> ASC -> DESC -> NONE
        if (sortDirection === sortStates.NONE) {
          return 'Sort rows by this header in ascending order';
        }

        if (sortDirection === sortStates.ASC) {
          return 'Sort rows by this header in descending order';
        }

        return 'Unsort rows by this header';
      }

      return 'Sort rows by this header in ascending order';
    }

    return '';
  };

  var sortDirections = (_sortDirections = {}, _defineProperty(_sortDirections, sortStates.NONE, 'none'), _defineProperty(_sortDirections, sortStates.ASC, 'ascending'), _defineProperty(_sortDirections, sortStates.DESC, 'descending'), _sortDirections);
  var TableHeader = /*#__PURE__*/React__default.forwardRef(function TableHeader(_ref2, ref) {
    var _cx;

    var headerClassName = _ref2.className,
        children = _ref2.children,
        colSpan = _ref2.colSpan,
        isSortable = _ref2.isSortable,
        isSortHeader = _ref2.isSortHeader,
        onClick = _ref2.onClick,
        scope = _ref2.scope,
        sortDirection = _ref2.sortDirection,
        t = _ref2.translateWithId,
        rest = _objectWithoutProperties(_ref2, ["className", "children", "colSpan", "isSortable", "isSortHeader", "onClick", "scope", "sortDirection", "translateWithId"]);

    if (!isSortable) {
      return /*#__PURE__*/React__default.createElement("th", _extends({}, rest, {
        className: headerClassName,
        scope: scope,
        colSpan: colSpan,
        ref: ref
      }), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$y, "--table-header-label")
      }, children));
    }

    var className = classnames(headerClassName, (_cx = {}, _defineProperty(_cx, "".concat(prefix$y, "--table-sort"), true), _defineProperty(_cx, "".concat(prefix$y, "--table-sort--active"), isSortHeader && sortDirection !== sortStates.NONE), _defineProperty(_cx, "".concat(prefix$y, "--table-sort--ascending"), isSortHeader && sortDirection === sortStates.DESC), _cx));
    var ariaSort = !isSortHeader ? 'none' : sortDirections[sortDirection];
    return /*#__PURE__*/React__default.createElement("th", {
      "aria-sort": ariaSort,
      className: headerClassName,
      colSpan: colSpan,
      ref: ref,
      scope: scope
    }, /*#__PURE__*/React__default.createElement("button", _extends({
      className: className,
      onClick: onClick
    }, rest), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$y, "--table-sort__flex")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$y, "--table-header-label")
    }, children), /*#__PURE__*/React__default.createElement(ArrowUp20, {
      className: "".concat(prefix$y, "--table-sort__icon"),
      "aria-label": t('carbon.table.header.icon.description', {
        header: children,
        sortDirection: sortDirection,
        isSortHeader: isSortHeader,
        sortStates: sortStates
      })
    }), /*#__PURE__*/React__default.createElement(ArrowsVertical20, {
      className: "".concat(prefix$y, "--table-sort__icon-unsorted"),
      "aria-label": t('carbon.table.header.icon.description', {
        header: children,
        sortDirection: sortDirection,
        isSortHeader: isSortHeader,
        sortStates: sortStates
      })
    }))));
  });
  TableHeader.propTypes = {
    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Pass in children that will be embedded in the table header label
     */
    children: PropTypes.node,

    /**
     * Specify `colSpan` as a non-negative integer value to indicate how
     * many columns the TableHeader cell extends in a table
     */
    colSpan: PropTypes.number,

    /**
     * Specify whether this header is one through which a user can sort the table
     */
    isSortable: PropTypes.bool,

    /**
     * Specify whether this header is the header by which a table is being sorted
     * by
     */
    isSortHeader: PropTypes.bool,

    /**
     * Hook that is invoked when the header is clicked
     */
    onClick: PropTypes.func,

    /**
     * Specify the scope of this table header. You can find more info about this
     * attribute at the following URL:
     * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attr-scope
     */
    scope: PropTypes.string.isRequired,

    /**
     * Specify which direction we are currently sorting by, should be one of DESC,
     * NONE, or ASC.
     */
    sortDirection: PropTypes.oneOf(Object.values(sortStates)),

    /**
     * Supply a method to translate internal strings with your i18n tool of
     * choice. Translation keys are avabile on the `translationKeys` field for
     * this component.
     */
    translateWithId: PropTypes.func
  };
  TableHeader.defaultProps = {
    isSortable: false,
    scope: 'col',
    translateWithId: translateWithId$2
  };
  TableHeader.translationKeys = Object.values(translationKeys$2);
  TableHeader.displayName = 'TableHeader';

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      symbolTag$1 = '[object Symbol]';
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal$1 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf$1 = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();
  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }
  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */


  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */


  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }

    return false;
  }
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */


  function arrayMap(array, iteratee) {
    var index = -1,
        length = array ? array.length : 0,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */


  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }
  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }

    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */


  function baseIsNaN(value) {
    return value !== value;
  }
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */


  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */


  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  /**
   * Checks if a cache value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function cacheHas(cache, key) {
    return cache.has(key);
  }
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */


  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */


  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */


  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  /** Used for built-in method references. */


  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto$1 = Object.prototype;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = root$1['__core-js_shared__'];
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /** Used to resolve the decompiled source of functions. */


  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto$1.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString$1 = objectProto$1.toString;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /** Built-in value references. */

  var _Symbol = root$1.Symbol,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      propertyIsEnumerable = objectProto$1.propertyIsEnumerable,
      splice = arrayProto.splice,
      spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeMax$1 = Math.max;
  /* Built-in method references that are verified to be native. */

  var Map$1 = getNative(root$1, 'Map'),
      nativeCreate = getNative(Object, 'create');
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */


  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */


  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  } // Add methods to `Hash`.


  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */


  function listCacheClear() {
    this.__data__ = [];
  }
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    return true;
  }
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */


  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */


  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$1 || ListCache)(),
      'string': new Hash()
    };
  }
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */


  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values ? values.length : 0;
    this.__data__ = new MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  }
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */


  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }
  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */


  function setCacheHas(value) {
    return this.__data__.has(value);
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }
  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */


  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }

    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }

    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }

    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;

      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;

        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }

        result.push(value);
      } else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */


  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */


  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function baseKeysIn(object) {
    if (!isObject$1(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} props The property identifiers to pick.
   * @returns {Object} Returns the new object.
   */


  function basePick(object, props) {
    object = Object(object);
    return basePickBy(object, props, function (value, key) {
      return key in object;
    });
  }
  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} props The property identifiers to pick from.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */


  function basePickBy(object, props, predicate) {
    var index = -1,
        length = props.length,
        result = {};

    while (++index < length) {
      var key = props[index],
          value = object[key];

      if (predicate(value, key)) {
        result[key] = value;
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */


  function baseRest(func, start) {
    start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax$1(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */


  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */


  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  /**
   * Creates an array of the own enumerable symbol properties of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */


  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  /**
   * Creates an array of the own and inherited enumerable symbol properties
   * of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];

    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }

    return result;
  };
  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */

  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */


  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */


  function isKeyable(value) {
    var type = _typeof(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */


  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
    return value === proto;
  }
  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */


  function toKey(value) {
    if (typeof value == 'string' || isSymbol$1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to process.
   * @returns {string} Returns the source code.
   */


  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */


  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */


  function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString$1.call(value) == argsTag);
  }
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */


  var isArray = Array.isArray;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */


  function isArrayLikeObject(value) {
    return isObjectLike$1(value) && isArrayLike(value);
  }
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */


  function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject$1(value) ? objectToString$1.call(value) : '';
    return tag == funcTag || tag == genTag;
  }
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */


  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject$1(value) {
    var type = _typeof(value);

    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike$1(value) {
    return !!value && _typeof(value) == 'object';
  }
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */


  function isSymbol$1(value) {
    return _typeof(value) == 'symbol' || isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1;
  }
  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */


  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  /**
   * The opposite of `_.pick`; this method creates an object composed of the
   * own and inherited enumerable string keyed properties of `object` that are
   * not omitted.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [props] The property identifiers to omit.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.omit(object, ['a', 'c']);
   * // => { 'b': '2' }
   */


  var omit = baseRest(function (object, props) {
    if (object == null) {
      return {};
    }

    props = arrayMap(baseFlatten(props, 1), toKey);
    return basePick(object, baseDifference(getAllKeysIn(object), props));
  });
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */

  function stubArray() {
    return [];
  }

  var lodash_omit = omit;

  var prefix$z = settings_1.prefix;

  var TableRow = function TableRow(props) {
    // Remove unnecessary props if provided to this component, these are
    // only useful in `TableExpandRow`
    var className = classnames(props.className, _defineProperty({}, "".concat(prefix$z, "--data-table--selected"), props.isSelected));

    var cleanProps = _objectSpread2(_objectSpread2({}, lodash_omit(props, ['ariaLabel', 'onExpand', 'isExpanded', 'isSelected'])), {}, {
      className: className || undefined
    });

    return /*#__PURE__*/React__default.createElement("tr", cleanProps);
  };

  TableRow.propTypes = {
    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify if the row is selected
     */
    isSelected: PropTypes.bool
  };

  /**
   * @param {...Ref<Element>} refs List of React refs to merge.
   * @returns {Ref<Element>} Merged React ref.
   */
  var mergeRefs = function mergeRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }

    return function (el) {
      refs.forEach(function (ref) {
        // https://github.com/facebook/react/issues/13029#issuecomment-410002316
        if (typeof ref === 'function') {
          ref(el);
        } else if (Object(ref) === ref) {
          ref.current = el;
        }
      });
    };
  };

  var prefix$A = settings_1.prefix;

  var InlineCheckbox = /*#__PURE__*/function (_React$Component) {
    _inherits(InlineCheckbox, _React$Component);

    var _super = _createSuper(InlineCheckbox);

    function InlineCheckbox() {
      var _this;

      _classCallCheck(this, InlineCheckbox);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "handleRef", function (el) {
        _this.inputNode = el;
      });

      return _this;
    }

    _createClass(InlineCheckbox, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this.inputNode) {
          this.inputNode.indeterminate = this.props.indeterminate;
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (this.inputNode && prevProps.indeterminate !== this.props.indeterminate) {
          this.inputNode.indeterminate = this.props.indeterminate;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            id = _this$props.id,
            indeterminate = _this$props.indeterminate,
            checked = _this$props.checked,
            disabled = _this$props.disabled,
            ariaLabel = _this$props.ariaLabel,
            name = _this$props.name,
            _onChange = _this$props.onChange,
            onClick = _this$props.onClick,
            onKeyDown = _this$props.onKeyDown,
            _this$props$title = _this$props.title,
            title = _this$props$title === void 0 ? undefined : _this$props$title,
            ref = _this$props.innerRef;
        var inputProps = {
          id: id,
          name: name,
          onClick: onClick,
          onChange: function onChange(evt) {
            _onChange(evt.target.checked, id, evt);
          },
          onKeyDown: onKeyDown,
          className: "".concat(prefix$A, "--checkbox"),
          type: 'checkbox',
          ref: mergeRefs(ref, this.handleRef),
          checked: false,
          disabled: disabled
        };

        if (checked) {
          inputProps.checked = true;
        }

        if (indeterminate) {
          inputProps.checked = false;
          inputProps['aria-checked'] = 'mixed';
        }

        return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("input", inputProps),
        /*#__PURE__*/

        /* eslint-disable jsx-a11y/label-has-for,jsx-a11y/label-has-associated-control */
        React__default.createElement("label", {
          htmlFor: id,
          className: "".concat(prefix$A, "--checkbox-label"),
          "aria-label": ariaLabel,
          title: title
        }));
      }
    }]);

    return InlineCheckbox;
  }(React__default.Component);

  _defineProperty(InlineCheckbox, "propTypes", {
    /**
     * Specify the label for the control
     */
    ariaLabel: PropTypes.string.isRequired,

    /**
     * Specify whether the underlying control is checked, or not
     */
    checked: PropTypes.bool.isRequired,

    /**
     * Specify whether the underlying input control should be disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide an `id` for the underlying input control
     */
    id: PropTypes.string.isRequired,

    /**
     * Specify whether the control is in an indterminate state
     */
    indeterminate: PropTypes.bool,

    /**
     * Provide a `name` for the underlying input control
     */
    name: PropTypes.string.isRequired,

    /**
     * Provide a handler that is invoked when a user clicks on the control
     */
    onClick: PropTypes.func,

    /**
     * Provide a handler that is invoked on the key down event for the control
     */
    onKeyDown: PropTypes.func,

    /**
     * Provide an optional tooltip for the InlineCheckbox
     */
    title: PropTypes.string,

    /**
     * Provide an optional hook that is called each time the input is updated
     */
    onChange: PropTypes.func
  });

  _defineProperty(InlineCheckbox, "defaultProps", {
    ariaLabel: '',
    checked: false,
    id: 'inline-checkbox',
    name: '',
    onChange: function onChange() {}
  });

  var InlineCheckbox$1 = (function () {
    var forwardRef = function forwardRef(props, ref) {
      return /*#__PURE__*/React__default.createElement(InlineCheckbox, _extends({}, props, {
        innerRef: ref
      }));
    };

    forwardRef.displayName = 'InlineCheckbox';
    return /*#__PURE__*/React__default.forwardRef(forwardRef);
  })();

  var prefix$B = settings_1.prefix;

  var TableSelectAll = function TableSelectAll(_ref) {
    var ariaLabel = _ref.ariaLabel,
        checked = _ref.checked,
        id = _ref.id,
        indeterminate = _ref.indeterminate,
        name = _ref.name,
        onSelect = _ref.onSelect,
        disabled = _ref.disabled,
        className = _ref.className;
    return /*#__PURE__*/React__default.createElement("th", {
      scope: "col",
      className: classnames("".concat(prefix$B, "--table-column-checkbox"), className)
    }, /*#__PURE__*/React__default.createElement(InlineCheckbox$1, {
      ariaLabel: ariaLabel,
      checked: checked,
      id: id,
      indeterminate: indeterminate,
      name: name,
      onClick: onSelect,
      disabled: disabled
    }));
  };

  TableSelectAll.propTypes = {
    /**
     * Specify the aria label for the underlying input control
     */
    ariaLabel: PropTypes.string.isRequired,

    /**
     * Specify whether all items are selected, or not
     */
    checked: PropTypes.bool.isRequired,

    /**
     * Provide an `id` for the underlying input control
     */
    id: PropTypes.string.isRequired,

    /**
     * Specify whether the selection only has a subset of all items
     */
    indeterminate: PropTypes.bool,

    /**
     * Provide a `name` for the underlying input control
     */
    name: PropTypes.string.isRequired,

    /**
     * Provide a handler to listen to when a user initiates a selection request
     */
    onSelect: PropTypes.func.isRequired,

    /**
     * The CSS class names of the cell that wraps the underlying input control
     */
    className: PropTypes.string,

    /**
     * Specify whether the checkbox input should be disabled
     */
    disabled: PropTypes.bool
  };
  TableSelectAll.defaultProps = {
    ariaLabel: 'Select all rows in the table'
  };

  var prefix$C = settings_1.prefix;

  function RadioButtonSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$C, "--radio-button-wrapper"), className)
    }, rest), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$C, "--radio-button ").concat(prefix$C, "--skeleton")
    }), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$C, "--radio-button__label ").concat(prefix$C, "--skeleton")
    }));
  }

  RadioButtonSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$D = settings_1.prefix;

  var RadioButton = /*#__PURE__*/function (_React$Component) {
    _inherits(RadioButton, _React$Component);

    var _super = _createSuper(RadioButton);

    function RadioButton() {
      var _this;

      _classCallCheck(this, RadioButton);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "uid", _this.props.id || uid());

      _defineProperty(_assertThisInitialized(_this), "handleChange", function (evt) {
        _this.props.onChange(_this.props.value, _this.props.name, evt);
      });

      return _this;
    }

    _createClass(RadioButton, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            className = _this$props.className,
            labelText = _this$props.labelText,
            labelPosition = _this$props.labelPosition,
            ref = _this$props.innerRef,
            hideLabel = _this$props.hideLabel,
            other = _objectWithoutProperties(_this$props, ["className", "labelText", "labelPosition", "innerRef", "hideLabel"]);

        {
           warning_1(labelPosition !== 'top' && labelPosition !== 'bottom', '`top`/`bottom` values for `labelPosition` property in the `RadioButton` component is deprecated ' + 'and being removed in the next release of `carbon-components-react`.') ;
        }

        var innerLabelClasses = classnames(_defineProperty({}, "".concat(prefix$D, "--visually-hidden"), hideLabel));
        var wrapperClasses = classnames(className, "".concat(prefix$D, "--radio-button-wrapper"), _defineProperty({}, "".concat(prefix$D, "--radio-button-wrapper--label-").concat(labelPosition), labelPosition !== 'right'));
        return /*#__PURE__*/React__default.createElement("div", {
          className: wrapperClasses
        }, /*#__PURE__*/React__default.createElement("input", _extends({}, other, {
          type: "radio",
          className: "".concat(prefix$D, "--radio-button"),
          onChange: this.handleChange,
          id: this.uid,
          ref: ref
        })), /*#__PURE__*/React__default.createElement("label", {
          htmlFor: this.uid,
          className: "".concat(prefix$D, "--radio-button__label")
        }, /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$D, "--radio-button__appearance")
        }), /*#__PURE__*/React__default.createElement("span", {
          className: innerLabelClasses
        }, labelText)));
      }
    }]);

    return RadioButton;
  }(React__default.Component);

  _defineProperty(RadioButton, "propTypes", {
    /**
     * Specify whether the <RadioButton> is currently checked
     */
    checked: PropTypes.bool,

    /**
     * Provide an optional className to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Specify whether the <RadioButton> should be checked by default
     */
    defaultChecked: PropTypes.bool,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide a unique id for the underlying <input> node
     */
    id: PropTypes.string,

    /**
     * Provide label text to be read by screen readers when interacting with the
     * control
     */
    labelText: PropTypes.node.isRequired,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes.bool,

    /**
     * Provide where label text should be placed
     * NOTE: `top`/`bottom` are deprecated
     */
    labelPosition: PropTypes.oneOf(['top', 'right', 'bottom', 'left']),

    /**
     * Provide a name for the underlying <input> node
     */
    name: PropTypes.string,

    /**
     * Provide a handler that is invoked when a user clicks on the control
     */
    onClick: PropTypes.func,

    /**
     * Provide an optional `onChange` hook that is called each time the value of
     * the underlying <input> changes
     */
    onChange: PropTypes.func,

    /**
     * Specify the value of the <RadioButton>
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired
  });

  _defineProperty(RadioButton, "defaultProps", {
    labelText: '',
    labelPosition: 'right',
    onChange: function onChange() {},
    value: ''
  });

  var RadioButton$1 = (function () {
    var forwardRef = function forwardRef(props, ref) {
      return /*#__PURE__*/React__default.createElement(RadioButton, _extends({}, props, {
        innerRef: ref
      }));
    };

    forwardRef.displayName = 'RadioButton';
    return /*#__PURE__*/React__default.forwardRef(forwardRef);
  })();

  var prefix$E = settings_1.prefix;

  var TableSelectRow = function TableSelectRow(_ref) {
    var _classNames;

    var ariaLabel = _ref.ariaLabel,
        checked = _ref.checked,
        id = _ref.id,
        name = _ref.name,
        onSelect = _ref.onSelect,
        disabled = _ref.disabled,
        radio = _ref.radio,
        className = _ref.className;
    var selectionInputProps = {
      id: id,
      name: name,
      onClick: onSelect,
      checked: checked,
      disabled: disabled
    };
    var InlineInputComponent = radio ? RadioButton$1 : InlineCheckbox$1;
    var tableSelectRowClasses = classnames("".concat(prefix$E, "--table-column-checkbox"), (_classNames = {}, _defineProperty(_classNames, className, className), _defineProperty(_classNames, "".concat(prefix$E, "--table-column-radio"), radio), _classNames));
    return /*#__PURE__*/React__default.createElement("td", {
      className: tableSelectRowClasses
    }, /*#__PURE__*/React__default.createElement(InlineInputComponent, _extends({}, selectionInputProps, radio && {
      labelText: ariaLabel,
      hideLabel: true
    }, !radio && {
      ariaLabel: ariaLabel
    })));
  };

  TableSelectRow.propTypes = {
    /**
     * Specify the aria label for the underlying input control
     */
    ariaLabel: PropTypes.string.isRequired,

    /**
     * Specify whether all items are selected, or not
     */
    checked: PropTypes.bool.isRequired,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide an `id` for the underlying input control
     */
    id: PropTypes.string.isRequired,

    /**
     * Provide a `name` for the underlying input control
     */
    name: PropTypes.string.isRequired,

    /**
     * Provide a handler to listen to when a user initiates a selection request
     */
    onSelect: PropTypes.func.isRequired,

    /**
     * Specify whether the control should be a radio button or inline checkbox
     */
    radio: PropTypes.bool,

    /**
     * The CSS class names of the cell that wraps the underlying input control
     */
    className: PropTypes.string
  };

  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * @param {object<string, Function>} propTypes The list of type checkers, keyed by prop names.
   * @returns {object<string, Function>}
   *   The new prop type checkers that checks if one of the given props exist,
   *   in addition to the original type checkings.
   */
  function isRequiredOneOf(propTypes) {
    var names = Object.keys(propTypes);

    var checker = function checker(propType) {
      return function (props, propName, componentName) {
        if ( names.every(function (name) {
          return typeof props[name] === 'undefined';
        })) {
          return new Error("".concat(componentName, " requires one of the following props: ").concat(names.join(', ')));
        }

        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
          rest[_key - 3] = arguments[_key];
        }

        return propType.apply(void 0, [props, propName, componentName].concat(rest));
      };
    };

    return names.reduce(function (o, name) {
      return _objectSpread2(_objectSpread2({}, o), {}, _defineProperty({}, name, checker(propTypes[name])));
    }, {});
  }

  var AriaLabelPropType = isRequiredOneOf({
    'aria-label': PropTypes.string,
    'aria-labelledby': PropTypes.string
  });

  var prefix$F = settings_1.prefix;

  var TableToolbar = function TableToolbar(_ref) {
    var _cx;

    var children = _ref.children,
        size = _ref.size,
        rest = _objectWithoutProperties(_ref, ["children", "size"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$F, "--table-toolbar"), true), _defineProperty(_cx, "".concat(prefix$F, "--table-toolbar--").concat(size), size), _cx));
    return /*#__PURE__*/React__default.createElement("section", _extends({}, rest, {
      className: className
    }), children);
  };

  TableToolbar.propTypes = _objectSpread2({
    /**
     * Pass in the children that will be rendered inside the TableToolbar
     */
    children: PropTypes.node,

    /**
     * `normal` Change the row height of table
     */
    size: PropTypes.oneOf(['small', 'normal'])
  }, AriaLabelPropType);
  TableToolbar.defaultProps = {
    'aria-label': 'data table toolbar'
  };

  var prefix$G = settings_1.prefix;

  var OverflowMenuItem = /*#__PURE__*/function (_React$Component) {
    _inherits(OverflowMenuItem, _React$Component);

    var _super = _createSuper(OverflowMenuItem);

    function OverflowMenuItem() {
      var _this;

      _classCallCheck(this, OverflowMenuItem);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "overflowMenuItem", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "setTabFocus", function (evt) {
        if (match(evt, ArrowDown)) {
          _this.props.handleOverflowMenuItemFocus({
            currentIndex: _this.props.index,
            direction: 1
          });
        }

        if (match(evt, ArrowUp)) {
          _this.props.handleOverflowMenuItemFocus({
            currentIndex: _this.props.index,
            direction: -1
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleClick", function (evt) {
        var _this$props = _this.props,
            onClick = _this$props.onClick,
            closeMenu = _this$props.closeMenu;
        onClick(evt);

        if (closeMenu) {
          closeMenu();
        }
      });

      return _this;
    }

    _createClass(OverflowMenuItem, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this2 = this;

        var _this$props2 = this.props,
            href = _this$props2.href,
            className = _this$props2.className,
            itemText = _this$props2.itemText,
            hasDivider = _this$props2.hasDivider,
            isDelete = _this$props2.isDelete,
            disabled = _this$props2.disabled,
            closeMenu = _this$props2.closeMenu,
            onClick = _this$props2.onClick,
            handleOverflowMenuItemFocus = _this$props2.handleOverflowMenuItemFocus,
            _onKeyDown = _this$props2.onKeyDown,
            primaryFocus = _this$props2.primaryFocus,
            wrapperClassName = _this$props2.wrapperClassName,
            requireTitle = _this$props2.requireTitle,
            index = _this$props2.index,
            other = _objectWithoutProperties(_this$props2, ["href", "className", "itemText", "hasDivider", "isDelete", "disabled", "closeMenu", "onClick", "handleOverflowMenuItemFocus", "onKeyDown", "primaryFocus", "wrapperClassName", "requireTitle", "index"]);

        {
           warning_1(closeMenu, '`<OverflowMenuItem>` detected missing `closeMenu` prop. ' + '`closeMenu` is required to let `<OverflowMenu>` close the menu upon actions on `<OverflowMenuItem>`. ' + 'Please make sure `<OverflowMenuItem>` is a direct child of `<OverflowMenu>.') ;
        }

        var overflowMenuBtnClasses = classnames("".concat(prefix$G, "--overflow-menu-options__btn"), className);
        var overflowMenuItemClasses = classnames("".concat(prefix$G, "--overflow-menu-options__option"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$G, "--overflow-menu--divider"), hasDivider), _defineProperty(_classNames, "".concat(prefix$G, "--overflow-menu-options__option--danger"), isDelete), _defineProperty(_classNames, "".concat(prefix$G, "--overflow-menu-options__option--disabled"), disabled), _classNames), wrapperClassName);
        var TagToUse = href ? 'a' : 'button';

        var OverflowMenuItemContent = function () {
          if (typeof itemText !== 'string') {
            return itemText;
          }

          return /*#__PURE__*/React__default.createElement("div", {
            className: "".concat(prefix$G, "--overflow-menu-options__option-content")
          }, itemText);
        }();

        return /*#__PURE__*/React__default.createElement("li", {
          className: overflowMenuItemClasses,
          role: "menuitem"
        }, /*#__PURE__*/React__default.createElement(TagToUse, _extends({}, other, {
          'data-floating-menu-primary-focus': primaryFocus || null
        }, {
          href: href,
          className: overflowMenuBtnClasses,
          disabled: disabled,
          onClick: this.handleClick,
          onKeyDown: function onKeyDown(evt) {
            _this2.setTabFocus(evt);

            _onKeyDown(evt);
          },
          ref: this.overflowMenuItem,
          title: requireTitle ? itemText : null,
          tabIndex: "-1",
          index: index
        }), OverflowMenuItemContent));
      }
    }]);

    return OverflowMenuItem;
  }(React__default.Component);

  _defineProperty(OverflowMenuItem, "propTypes", {
    /**
     * The CSS class name to be placed on the button element
     */
    className: PropTypes.string,

    /**
     * The CSS class name to be placed on the wrapper list item element
     */
    wrapperClassName: PropTypes.string,

    /**
     * The text in the menu item.
     */
    itemText: PropTypes.node.isRequired,

    /**
     * If given, overflow item will render as a link with the given href
     */
    href: PropTypes.string,

    /**
     * `true` to make this menu item a divider.
     */
    hasDivider: PropTypes.bool,

    /**
     * `true` to make this menu item a "danger button".
     */
    isDelete: PropTypes.bool,

    /**
     * `true` to make this menu item disabled.
     */
    disabled: PropTypes.bool,

    /**
     * event handlers
     */
    onBlur: PropTypes.func,
    onClick: PropTypes.func,
    onFocus: PropTypes.func,
    onKeyDown: PropTypes.func,
    onKeyUp: PropTypes.func,
    onMouseDown: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onMouseUp: PropTypes.func,

    /**
     * A callback to tell the parent menu component that the menu should be closed.
     */
    closeMenu: PropTypes.func,

    /**
     * `true` if this menu item should get focus when the menu gets open.
     */
    primaryFocus: deprecate(PropTypes.bool, 'The `primaryFocus` prop has been deprecated as it is no longer used. ' + 'Feel free to remove this prop from <OverflowMenuItem>. This prop will ' + 'be removed in the next major release of `carbon-components-react`. ' + 'Opt for `selectorPrimaryFocus` in `<OverflowMenu>` instead'),

    /**
     * `true` if this menu item has long text and requires a browser tooltip
     */
    requireTitle: PropTypes.bool,
    index: PropTypes.number,
    handleOverflowMenuItemFocus: PropTypes.func
  });

  _defineProperty(OverflowMenuItem, "defaultProps", {
    hasDivider: false,
    isDelete: false,
    disabled: false,
    itemText: 'Provide itemText',
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {}
  });

  var TableToolbarAction = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties(_ref, ["children"]);

    return /*#__PURE__*/React__default.createElement(OverflowMenuItem, _extends({
      ref: ref,
      itemText: children
    }, rest));
  });
  TableToolbarAction.displayName = 'TableToolbarAction';
  TableToolbarAction.propTypes = {
    children: PropTypes.node,
    className: PropTypes.string,
    onClick: PropTypes.func.isRequired
  };

  var prefix$H = settings_1.prefix;
  var TableToolbarContent = wrapComponent({
    name: 'TableToolbarContent',
    type: 'div',
    className: "".concat(prefix$H, "--toolbar-content")
  });

  var prefix$I = settings_1.prefix;

  var SearchSkeleton = function SearchSkeleton(_ref) {
    var _cx;

    var small = _ref.small,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["small", "className"]);

    var searchClasses = classnames(className, (_cx = {}, _defineProperty(_cx, "".concat(prefix$I, "--skeleton"), true), _defineProperty(_cx, "".concat(prefix$I, "--search--xl"), !small), _defineProperty(_cx, "".concat(prefix$I, "--search--sm"), small), _cx));
    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: searchClasses
    }, rest), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$I, "--label")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$I, "--search-input")
    }));
  };

  SearchSkeleton.propTypes = {
    /**
     * Specify whether the Search should be a small variant
     */
    small: PropTypes.bool,

    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };
  SearchSkeleton.defaultProps = {
    small: false
  };

  var prefix$J = settings_1.prefix;

  var Search$1 = /*#__PURE__*/function (_Component) {
    _inherits(Search, _Component);

    var _super = _createSuper(Search);

    function Search() {
      var _this;

      _classCallCheck(this, Search);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {
        hasContent: _this.props.value || _this.props.defaultValue || false,
        prevValue: _this.props.value
      });

      _defineProperty(_assertThisInitialized(_this), "clearInput", function (evt) {
        if (!_this.props.value) {
          _this.input.value = '';

          _this.props.onChange(evt);
        } else {
          var clearedEvt = Object.assign({}, evt.target, {
            target: {
              value: ''
            }
          });

          _this.props.onChange(clearedEvt);
        }

        _this.setState({
          hasContent: false
        }, function () {
          return _this.input.focus();
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleChange", function (evt) {
        _this.setState({
          hasContent: evt.target.value !== ''
        });

        _this.props.onChange(evt);
      });

      return _this;
    }

    _createClass(Search, [{
      key: "render",
      value: function render() {
        var _classNames,
            _classNames2,
            _this2 = this;

        var _this$props = this.props,
            className = _this$props.className,
            type = _this$props.type,
            _this$props$id = _this$props.id,
            id = _this$props$id === void 0 ? this._inputId = this._inputId || "search__input__id_".concat(Math.random().toString(36).substr(2)) : _this$props$id,
            placeHolderText = _this$props.placeHolderText,
            labelText = _this$props.labelText,
            closeButtonLabelText = _this$props.closeButtonLabelText,
            small = _this$props.small,
            _this$props$size = _this$props.size,
            size = _this$props$size === void 0 ? !small ? 'xl' : 'sm' : _this$props$size,
            light = _this$props.light,
            other = _objectWithoutProperties(_this$props, ["className", "type", "id", "placeHolderText", "labelText", "closeButtonLabelText", "small", "size", "light"]);

        var hasContent = this.state.hasContent;
        var searchClasses = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$J, "--search"), true), _defineProperty(_classNames, "".concat(prefix$J, "--search--").concat(size), size), _defineProperty(_classNames, "".concat(prefix$J, "--search--light"), light), _defineProperty(_classNames, className, className), _classNames));
        var clearClasses = classnames((_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$J, "--search-close"), true), _defineProperty(_classNames2, "".concat(prefix$J, "--search-close--hidden"), !hasContent), _classNames2));
        var CloseIconX = size === 'xl' ? Close20 : Close16;
        var searchId = "".concat(id, "-search");
        return /*#__PURE__*/React__default.createElement("div", {
          role: "search",
          "aria-labelledby": searchId,
          className: searchClasses
        }, /*#__PURE__*/React__default.createElement(Search16, {
          className: "".concat(prefix$J, "--search-magnifier")
        }), /*#__PURE__*/React__default.createElement("label", {
          id: searchId,
          htmlFor: id,
          className: "".concat(prefix$J, "--label")
        }, labelText), /*#__PURE__*/React__default.createElement("input", _extends({
          role: "searchbox",
          autoComplete: "off"
        }, other, {
          type: type,
          className: "".concat(prefix$J, "--search-input"),
          id: id,
          placeholder: placeHolderText,
          onChange: this.handleChange,
          ref: function ref(input) {
            _this2.input = input;
          }
        })), /*#__PURE__*/React__default.createElement("button", {
          className: clearClasses,
          onClick: this.clearInput,
          type: "button",
          "aria-label": closeButtonLabelText
        }, /*#__PURE__*/React__default.createElement(CloseIconX, null)));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var value = _ref.value;
        var prevValue = state.prevValue;
        return prevValue === value ? null : {
          hasContent: !!value,
          prevValue: value
        };
      }
    }]);

    return Search;
  }(React.Component);

  _defineProperty(Search$1, "propTypes", {
    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Optional prop to specify the type of the `<input>`
     */
    type: PropTypes.string,

    /**
     * Specify whether the Search should be a small variant
     */

    /**
     * Specify whether the load was successful
     */
    small: deprecate(PropTypes.bool, "\nThe prop `small` for Search has been deprecated in favor of `size`. Please use `size=\"sm\"` instead."),

    /**
     * Specify the search size
     */
    size: PropTypes.oneOf(['sm', 'lg', 'xl']),

    /**
     * Provide an optional placeholder text for the Search.
     * Note: if the label and placeholder differ,
     * VoiceOver on Mac will read both
     */
    placeHolderText: PropTypes.string,

    /**
     * Provide the label text for the Search icon
     */
    labelText: PropTypes.node.isRequired,

    /**
     * Specify light version or default version of this control
     */
    light: PropTypes.bool,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes.string,

    /**
     * Specify a label to be read by screen readers on the "close" button
     */
    closeButtonLabelText: PropTypes.string,

    /**
     * Specify the value of the <input>
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Optionally provide the default value of the <input>
     */
    defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Optional callback called when the search value changes.
     */
    onChange: PropTypes.func
  });

  _defineProperty(Search$1, "defaultProps", {
    type: 'text',
    placeHolderText: '',
    closeButtonLabelText: 'Clear search input',
    onChange: function onChange() {}
  });

  var prefix$K = settings_1.prefix;
  var getInstanceId$2 = setupGetInstanceId$1();
  var translationKeys$3 = {
    'carbon.table.toolbar.search.label': 'Filter table',
    'carbon.table.toolbar.search.placeholder': 'Filter table'
  };

  var translateWithId$3 = function translateWithId(id) {
    return translationKeys$3[id];
  };

  var TableToolbarSearch = function TableToolbarSearch(_ref) {
    var _cx;

    var className = _ref.className,
        searchContainerClass = _ref.searchContainerClass,
        onChangeProp = _ref.onChange,
        t = _ref.translateWithId,
        placeHolderText = _ref.placeHolderText,
        labelText = _ref.labelText,
        expandedProp = _ref.expanded,
        defaultExpanded = _ref.defaultExpanded,
        defaultValue = _ref.defaultValue,
        onExpand = _ref.onExpand,
        persistent = _ref.persistent,
        persistant = _ref.persistant,
        id = _ref.id,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties(_ref, ["className", "searchContainerClass", "onChange", "translateWithId", "placeHolderText", "labelText", "expanded", "defaultExpanded", "defaultValue", "onExpand", "persistent", "persistant", "id", "tabIndex"]);

    var _useRef = React.useRef(expandedProp !== undefined),
        controlled = _useRef.current;

    var _useState = React.useState(defaultExpanded || defaultValue),
        _useState2 = _slicedToArray(_useState, 2),
        expandedState = _useState2[0],
        setExpandedState = _useState2[1];

    var expanded = controlled ? expandedProp : expandedState;
    var searchRef = React.useRef(null);

    var _useState3 = React.useState(defaultValue || ''),
        _useState4 = _slicedToArray(_useState3, 2),
        value = _useState4[0],
        setValue = _useState4[1];

    var uniqueId = React.useMemo(getInstanceId$2, []);

    var _useState5 = React.useState(null),
        _useState6 = _slicedToArray(_useState5, 2),
        focusTarget = _useState6[0],
        setFocusTarget = _useState6[1];

    React.useEffect(function () {
      if (focusTarget) {
        focusTarget.current.querySelector('input').focus();
        setFocusTarget(null);
      }
    }, [focusTarget]);
    React.useEffect(function () {
      if (defaultValue) {
        onChangeProp('', defaultValue);
      }
    }, //eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    var searchContainerClasses = classnames((_cx = {}, _defineProperty(_cx, searchContainerClass, searchContainerClass), _defineProperty(_cx, "".concat(prefix$K, "--toolbar-action"), true), _defineProperty(_cx, "".concat(prefix$K, "--toolbar-search-container-active"), expanded), _defineProperty(_cx, "".concat(prefix$K, "--toolbar-search-container-expandable"), !persistent || !persistent && !persistant), _defineProperty(_cx, "".concat(prefix$K, "--toolbar-search-container-persistent"), persistent || persistant), _cx));

    var handleExpand = function handleExpand(event) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !expanded;

      if (!controlled && (!persistent || !persistent && !persistant)) {
        setExpandedState(value);

        if (value && !expanded) {
          setFocusTarget(searchRef);
        }
      }

      if (onExpand) {
        onExpand(event, value);
      }
    };

    var _onClick = function onClick(e) {
      handleExpand(e, true);
    };

    var onChange = function onChange(e) {
      setValue(e.target.value);

      if (onChangeProp) {
        onChangeProp(e);
      }
    };

    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/no-static-element-interactions
      React__default.createElement("div", {
        tabIndex: expandedState ? '-1' : tabIndex,
        ref: searchRef,
        onKeyDown: function onKeyDown(event) {
          return _onClick(event);
        },
        onClick: function onClick(event) {
          return _onClick(event);
        },
        onFocus: function onFocus(event) {
          return handleExpand(event, true);
        },
        onBlur: function onBlur(event) {
          return !value && handleExpand(event, false);
        },
        className: searchContainerClasses
      }, /*#__PURE__*/React__default.createElement(Search$1, _extends({
        size: "sm",
        tabIndex: expandedState ? tabIndex : '-1',
        className: className,
        value: value,
        id: typeof id !== 'undefined' ? id : uniqueId.toString(),
        "aria-hidden": !expanded,
        labelText: labelText || t('carbon.table.toolbar.search.label'),
        placeHolderText: placeHolderText || t('carbon.table.toolbar.search.placeholder'),
        onChange: onChange
      }, rest)))
    );
  };

  TableToolbarSearch.propTypes = {
    children: PropTypes.node,

    /**
     * Provide an optional class name for the search container
     */
    className: PropTypes.string,

    /**
     * Provide an optional id for the search container
     */
    id: PropTypes.string,

    /**
     * Provide an optional className for the overal container of the Search
     */
    searchContainerClass: PropTypes.string,

    /**
     * Specifies if the search should expand
     */
    expanded: PropTypes.bool,

    /**
     * Specifies if the search should initially render in an expanded state
     */
    defaultExpanded: PropTypes.bool,

    /**
     * Provide an optional hook that is called each time the input is expanded
     */
    onExpand: PropTypes.func,

    /**
     * Provide an optional hook that is called each time the input is updated
     */
    onChange: PropTypes.func,

    /**
     * Provide an optional placeholder text for the Search component
     */
    placeHolderText: PropTypes.string,

    /**
     * Provide an optional label text for the Search component icon
     */
    labelText: PropTypes.string,

    /**
     * Provide an optional default value for the Search component
     */
    defaultValue: PropTypes.string,

    /**
     * Provide custom text for the component for each translation id
     */
    translateWithId: PropTypes.func.isRequired,

    /**
     * Optional prop to specify the tabIndex of the <Search> (in expanded state) or the container (in collapsed state)
     */
    tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Whether the search should be allowed to expand
     */
    persistent: PropTypes.bool,
    persistant: deprecate(PropTypes.bool, "\nThe prop `persistant` for TableToolbarSearch has been deprecated in favor of `persistent`. Please use `persistent` instead.")
  };
  TableToolbarSearch.defaultProps = {
    tabIndex: '0',
    translateWithId: translateWithId$3,
    persistent: false
  };

  var invariant = function invariant(condition, format, a, b, c, d, e, f) {
    {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame

      throw error;
    }
  };

  var invariant_1 = invariant;

  /**
   * Generic component used for reacting to a click event happening outside of a
   * given `children` element.
   */

  var ClickListener = /*#__PURE__*/function (_React$Component) {
    _inherits(ClickListener, _React$Component);

    var _super = _createSuper(ClickListener);

    function ClickListener(props) {
      var _this;

      _classCallCheck(this, ClickListener);

      _this = _super.call(this, props); // We manually bind handlers in this Component, versus using class
      // properties, so that we can properly test the `handleRef` handler with
      // enzyme.

      _this.handleRef = _this.handleRef.bind(_assertThisInitialized(_this));
      _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(ClickListener, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        document.addEventListener('click', this.handleDocumentClick);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        document.removeEventListener('click', this.handleDocumentClick);
      }
    }, {
      key: "handleDocumentClick",
      value: function handleDocumentClick(evt) {
        if (this.element) {
          if (this.element.contains && !this.element.contains(evt.target)) {
            this.props.onClickOutside(evt);
          }
        }
      }
    }, {
      key: "handleRef",
      value: function handleRef(el) {
        var children = this.props.children;
        this.element = el;
        /**
         * One important note, `children.ref` corresponds to a `ref` prop passed in
         * directly to the child, not necessarily a `ref` defined in the component.
         * This means that here we target the following `ref` location:
         *
         * <ClickListener onClickOutside={() => {}}>
         *   <Child ref={targetedRefHere} />
         * </ClickListener>
         */

        if (children.ref && typeof children.ref === 'function') {
          children.ref(el);
        }
      }
    }, {
      key: "render",
      value: function render() {
        return /*#__PURE__*/React__default.cloneElement(this.props.children, {
          ref: this.handleRef
        });
      }
    }]);

    return ClickListener;
  }(React__default.Component);

  _defineProperty(ClickListener, "propTypes", {
    children: PropTypes.element.isRequired,
    onClickOutside: PropTypes.func.isRequired
  });

  var lib = (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' && self.self === self && self || _typeof(commonjsGlobal) === 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal || commonjsGlobal;

  // mdn resize function

  var OptimizedResize = function optimizedResize() {
    var callbacks = [];
    var running = false; // run the actual callbacks

    function runCallbacks() {
      callbacks.forEach(function (callback) {
        callback();
      });
      running = false;
    } // fired on resize event


    function resize() {
      if (!running) {
        running = true;
        lib.requestAnimationFrame(runCallbacks);
      }
    } // adds callback to loop


    function addCallback(callback) {
      if (callback) {
        var index = callbacks.indexOf(callback);

        if (index < 0) {
          callbacks.push(callback);
        }
      }
    }

    return {
      // public method to add additional callback
      add: function add(callback) {
        if (!callbacks.length) {
          lib.addEventListener('resize', resize);
        }

        addCallback(callback);
        return {
          release: function release() {
            var index = callbacks.indexOf(callback);

            if (index >= 0) {
              callbacks.splice(index, 1);
            }
          }
        };
      }
    };
  }();

  var prefix$L = settings_1.prefix;
  /**
   * The structure for the position of floating menu.
   * @typedef {object} FloatingMenu~position
   * @property {number} left The left position.
   * @property {number} top The top position.
   * @property {number} right The right position.
   * @property {number} bottom The bottom position.
   */

  /**
   * The structure for the size of floating menu.
   * @typedef {object} FloatingMenu~size
   * @property {number} width The width.
   * @property {number} height The height.
   */

  /**
   * The structure for the position offset of floating menu.
   * @typedef {object} FloatingMenu~offset
   * @property {number} top The top position.
   * @property {number} left The left position.
   */

  /**
   * The structure for the target container.
   * @typedef {object} FloatingMenu~container
   * @property {DOMRect} rect Return of element.getBoundingClientRect()
   * @property {string} position Position style (static, absolute, relative...)
   */

  var DIRECTION_LEFT$1 = 'left';
  var DIRECTION_TOP$1 = 'top';
  var DIRECTION_RIGHT$1 = 'right';
  var DIRECTION_BOTTOM$1 = 'bottom';
  /**
   * @param {FloatingMenu~offset} [oldMenuOffset={}] The old value.
   * @param {FloatingMenu~offset} [menuOffset={}] The new value.
   * @returns `true` if the parent component wants to change in the adjustment of the floating menu position.
   * @private
   */

  var hasChangeInOffset = function hasChangeInOffset() {
    var oldMenuOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var menuOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (_typeof(oldMenuOffset) !== _typeof(menuOffset)) {
      return true;
    } else if (Object(menuOffset) === menuOffset && typeof menuOffset !== 'function') {
      return oldMenuOffset.top !== menuOffset.top || oldMenuOffset.left !== menuOffset.left;
    }

    return oldMenuOffset !== menuOffset;
  };
  /**
   * @param {object} params The parameters.
   * @param {FloatingMenu~size} params.menuSize The size of the menu.
   * @param {FloatingMenu~position} params.refPosition The position of the triggering element.
   * @param {FloatingMenu~offset} [params.offset={ left: 0, top: 0 }] The position offset of the menu.
   * @param {string} [params.direction=bottom] The menu direction.
   * @param {number} [params.scrollX=0] The scroll position of the viewport.
   * @param {number} [params.scrollY=0] The scroll position of the viewport.
   * @param {FloatingMenu~container} [params.container] The size and position type of target element.
   * @returns {FloatingMenu~offset} The position of the menu, relative to the top-left corner of the viewport.
   * @private
   */


  var getFloatingPosition$1 = function getFloatingPosition(_ref) {
    var _DIRECTION_LEFT$DIREC;

    var menuSize = _ref.menuSize,
        _ref$refPosition = _ref.refPosition,
        refPosition = _ref$refPosition === void 0 ? {} : _ref$refPosition,
        _ref$offset = _ref.offset,
        offset = _ref$offset === void 0 ? {} : _ref$offset,
        _ref$direction = _ref.direction,
        direction = _ref$direction === void 0 ? DIRECTION_BOTTOM$1 : _ref$direction,
        _ref$scrollX = _ref.scrollX,
        scrollX = _ref$scrollX === void 0 ? 0 : _ref$scrollX,
        _ref$scrollY = _ref.scrollY,
        scrollY = _ref$scrollY === void 0 ? 0 : _ref$scrollY,
        container = _ref.container;
    var _refPosition$left = refPosition.left,
        refLeft = _refPosition$left === void 0 ? 0 : _refPosition$left,
        _refPosition$top = refPosition.top,
        refTop = _refPosition$top === void 0 ? 0 : _refPosition$top,
        _refPosition$right = refPosition.right,
        refRight = _refPosition$right === void 0 ? 0 : _refPosition$right,
        _refPosition$bottom = refPosition.bottom,
        refBottom = _refPosition$bottom === void 0 ? 0 : _refPosition$bottom;
    var relativeDiff = container.position !== 'static' ? {
      top: container.rect.top,
      left: container.rect.left
    } : {
      top: 0,
      left: 0
    };
    var width = menuSize.width,
        height = menuSize.height;
    var _offset$top = offset.top,
        top = _offset$top === void 0 ? 0 : _offset$top,
        _offset$left = offset.left,
        left = _offset$left === void 0 ? 0 : _offset$left;
    var refCenterHorizontal = (refLeft + refRight) / 2;
    var refCenterVertical = (refTop + refBottom) / 2;
    return (_DIRECTION_LEFT$DIREC = {}, _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_LEFT$1, function () {
      return {
        left: refLeft - width + scrollX - left - relativeDiff.left,
        top: refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top
      };
    }), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_TOP$1, function () {
      return {
        left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,
        top: refTop - height + scrollY - top - relativeDiff.top
      };
    }), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_RIGHT$1, function () {
      return {
        left: refRight + scrollX + left - relativeDiff.left,
        top: refCenterVertical - height / 2 + scrollY + top + 3 - relativeDiff.top
      };
    }), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_BOTTOM$1, function () {
      return {
        left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,
        top: refBottom + scrollY + top - relativeDiff.top
      };
    }), _DIRECTION_LEFT$DIREC)[direction]();
  };
  /**
   * A menu that is detached from the triggering element.
   * Useful when the container of the triggering element cannot have `overflow:visible` style, etc.
   */


  var FloatingMenu$1 = /*#__PURE__*/function (_React$Component) {
    _inherits(FloatingMenu, _React$Component);

    var _super = _createSuper(FloatingMenu);

    function FloatingMenu() {
      var _this;

      _classCallCheck(this, FloatingMenu);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "_placeInProgress", false);

      _defineProperty(_assertThisInitialized(_this), "state", {
        /**
         * The position of the menu, relative to the top-left corner of the viewport.
         * @type {FloatingMenu~offset}
         */
        floatingPosition: undefined
      });

      _defineProperty(_assertThisInitialized(_this), "_menuContainer", null);

      _defineProperty(_assertThisInitialized(_this), "_menuBody", null);

      _defineProperty(_assertThisInitialized(_this), "_updateMenuSize", function () {
        var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var menuBody = _this._menuBody;
         warning_1(menuBody, 'The DOM node for menu body for calculating its position is not available. Skipping...') ;

        if (!menuBody) {
          return;
        }

        var _prevProps$menuOffset = prevProps.menuOffset,
            oldMenuOffset = _prevProps$menuOffset === void 0 ? {} : _prevProps$menuOffset,
            oldMenuDirection = prevProps.menuDirection;
        var _this$props = _this.props,
            _this$props$menuOffse = _this$props.menuOffset,
            menuOffset = _this$props$menuOffse === void 0 ? {} : _this$props$menuOffse,
            menuDirection = _this$props.menuDirection;

        if (hasChangeInOffset(oldMenuOffset, menuOffset) || oldMenuDirection !== menuDirection) {
          var _this$props2 = _this.props,
              flipped = _this$props2.flipped,
              triggerRef = _this$props2.triggerRef;
          var triggerEl = triggerRef.current;
          var menuSize = menuBody.getBoundingClientRect();
          var refPosition = triggerEl && triggerEl.getBoundingClientRect();
          var offset = typeof menuOffset !== 'function' ? menuOffset : menuOffset(menuBody, menuDirection, triggerEl, flipped); // Skips if either in the following condition:
          // a) Menu body has `display:none`
          // b) `menuOffset` as a callback returns `undefined` (The callback saw that it couldn't calculate the value)

          if (menuSize.width > 0 && menuSize.height > 0 || !offset) {
            _this.setState({
              floatingPosition: getFloatingPosition$1({
                menuSize: menuSize,
                refPosition: refPosition,
                direction: menuDirection,
                offset: offset,
                scrollX: lib.pageXOffset,
                scrollY: lib.pageYOffset,
                container: {
                  rect: _this.props.target().getBoundingClientRect(),
                  position: getComputedStyle(_this.props.target()).position
                }
              })
            });
          }
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_focusMenuContent", function (menuBody) {
        var primaryFocusNode = menuBody.querySelector(_this.props.selectorPrimaryFocus || null);
        var tabbableNode = menuBody.querySelector(selectorTabbable);
        var focusableNode = menuBody.querySelector(selectorFocusable);
        var focusTarget = primaryFocusNode || // User defined focusable node
        tabbableNode || // First sequentially focusable node
        focusableNode || // First programmatic focusable node
        menuBody;
        focusTarget.focus();

        if (focusTarget === menuBody && "development" !== "production") {
           warning_1(focusableNode === null, 'Floating Menus must have at least a programmatically focusable child. ' + 'This can be accomplished by adding tabIndex="-1" to the content element.') ;
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_menuRef", function (menuBody) {
        var menuRef = _this.props.menuRef;
        _this._placeInProgress = !!menuBody;
        menuRef && menuRef(_this._menuBody = menuBody);

        if (menuBody) {
          _this._updateMenuSize();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_getChildrenWithProps", function () {
        var _this$props3 = _this.props,
            styles = _this$props3.styles,
            children = _this$props3.children;
        var pos = _this.state.floatingPosition; // If no pos available, we need to hide the element (offscreen to the left)
        // This is done so we can measure the content before positioning it correctly.

        var positioningStyle = pos ? {
          left: "".concat(pos.left, "px"),
          top: "".concat(pos.top, "px"),
          right: 'auto'
        } : {
          visibility: 'hidden',
          top: '0px'
        };
        return /*#__PURE__*/React__default.cloneElement(children, {
          ref: _this._menuRef,
          style: _objectSpread2(_objectSpread2(_objectSpread2({}, styles), positioningStyle), {}, {
            position: 'absolute',
            margin: 0,
            opacity: 1
          })
        });
      });

      return _this;
    }

    _createClass(FloatingMenu, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.hResize.release();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        this.hResize = OptimizedResize.add(function () {
          _this2._updateMenuSize();
        });
      }
      /**
       * Set focus on floating menu content after menu placement.
       * @param {Element} menuBody The DOM element of the menu body.
       * @private
       */

    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        this._updateMenuSize(prevProps);

        var onPlace = this.props.onPlace;

        if (this._placeInProgress && this.state.floatingPosition) {
          if (this._menuBody && !this._menuBody.contains(document.activeElement)) {
            this._focusMenuContent(this._menuBody);
          }

          if (typeof onPlace === 'function') {
            onPlace(this._menuBody);
            this._placeInProgress = false;
          }
        }
      }
      /**
       * A callback for called when menu body is mounted or unmounted.
       * @param {Element} menuBody The menu body being mounted. `null` if the menu body is being unmounted.
       */

    }, {
      key: "render",
      value: function render() {
        if (typeof document !== 'undefined') {
          var target = this.props.target;
          return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("span", {
            ref: this.startSentinel,
            tabIndex: "0",
            role: "link",
            className: "".concat(prefix$L, "--visually-hidden")
          }, "Focus sentinel"), this._getChildrenWithProps(), /*#__PURE__*/React__default.createElement("span", {
            ref: this.endSentinel,
            tabIndex: "0",
            role: "link",
            className: "".concat(prefix$L, "--visually-hidden")
          }, "Focus sentinel")), !target ? document.body : target());
        }

        return null;
      }
    }]);

    return FloatingMenu;
  }(React__default.Component);

  _defineProperty(FloatingMenu$1, "propTypes", {
    /**
     * Contents to put into the floating menu.
     */
    children: PropTypes.object,

    /**
     * The query selector indicating where the floating menu body should be placed.
     */
    target: PropTypes.func,

    /**
     * Where to put the tooltip, relative to the trigger button.
     */
    menuDirection: PropTypes.oneOf([DIRECTION_LEFT$1, DIRECTION_TOP$1, DIRECTION_RIGHT$1, DIRECTION_BOTTOM$1]),

    /**
     * The adjustment of the floating menu position, considering the position of dropdown arrow, etc.
     */
    menuOffset: PropTypes.oneOfType([PropTypes.shape({
      top: PropTypes.number,
      left: PropTypes.number
    }), PropTypes.func]),

    /**
     * Specify a CSS selector that matches the DOM element that should
     * be focused when the Modal opens
     */
    selectorPrimaryFocus: PropTypes.string,

    /**
     * The additional styles to put to the floating menu.
     */
    styles: PropTypes.object,

    /**
     * The callback called when the menu body has been mounted to/will be unmounted from the DOM.
     */
    menuRef: PropTypes.func,

    /**
     * The callback called when the menu body has been mounted and positioned.
     */
    onPlace: PropTypes.func,

    /**
     * `true` if the menu alignment should be flipped.
     */
    flipped: PropTypes.bool,

    /**
     * The element ref of the tooltip's trigger button.
     */
    triggerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({
      current: PropTypes.any
    })])
  });

  _defineProperty(FloatingMenu$1, "defaultProps", {
    menuOffset: {},
    menuDirection: DIRECTION_BOTTOM$1
  });

  var _triggerButtonPositio, _triggerButtonPositio2;
  var prefix$M = settings_1.prefix;

  var on$1 = function on(element) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    element.addEventListener.apply(element, args);
    return {
      release: function release() {
        element.removeEventListener.apply(element, args);
        return null;
      }
    };
  };
  /**
   * The CSS property names of the arrow keyed by the floating menu direction.
   * @type {object<string, string>}
   */


  var triggerButtonPositionProps$1 = (_triggerButtonPositio = {}, _defineProperty(_triggerButtonPositio, DIRECTION_TOP$1, 'bottom'), _defineProperty(_triggerButtonPositio, DIRECTION_BOTTOM$1, 'top'), _triggerButtonPositio);
  /**
   * Determines how the position of arrow should affect the floating menu position.
   * @type {object<string, number>}
   */

  var triggerButtonPositionFactors$1 = (_triggerButtonPositio2 = {}, _defineProperty(_triggerButtonPositio2, DIRECTION_TOP$1, -2), _defineProperty(_triggerButtonPositio2, DIRECTION_BOTTOM$1, -1), _triggerButtonPositio2);
  /**
   * @param {Element} menuBody The menu body with the menu arrow.
   * @param {string} direction The floating menu direction.
   * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
   * @private
   */

  var getMenuOffset$2 = function getMenuOffset(menuBody, direction, trigger, flip) {
    var triggerButtonPositionProp = triggerButtonPositionProps$1[direction];
    var triggerButtonPositionFactor = triggerButtonPositionFactors$1[direction];

    {
      !(triggerButtonPositionProp && triggerButtonPositionFactor) ?  invariant_1(false, '[OverflowMenu] wrong floating menu direction: `%s`', direction)  : void 0;
    }

    var menuWidth = menuBody.offsetWidth,
        menuHeight = menuBody.offsetHeight;

    switch (triggerButtonPositionProp) {
      case 'top':
      case 'bottom':
        {
          // TODO: Ensure `trigger` is there for `<OverflowMenu open>`
          var triggerWidth = !trigger ? 0 : trigger.offsetWidth;
          return {
            left: (!flip ? 1 : -1) * (menuWidth / 2 - triggerWidth / 2),
            top: 0
          };
        }

      case 'left':
      case 'right':
        {
          // TODO: Ensure `trigger` is there for `<OverflowMenu open>`
          var triggerHeight = !trigger ? 0 : trigger.offsetHeight;
          return {
            left: 0,
            top: (!flip ? 1 : -1) * (menuHeight / 2 - triggerHeight / 2)
          };
        }
    }
  };

  var OverflowMenu$1 = /*#__PURE__*/function (_Component) {
    _inherits(OverflowMenu, _Component);

    var _super = _createSuper(OverflowMenu);

    function OverflowMenu() {
      var _this;

      _classCallCheck(this, OverflowMenu);

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {});

      _defineProperty(_assertThisInitialized(_this), "_hFocusIn", null);

      _defineProperty(_assertThisInitialized(_this), "_hBlurTimeout", void 0);

      _defineProperty(_assertThisInitialized(_this), "_triggerRef", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "handleClick", function (evt) {
        if (!_this._menuBody || !_this._menuBody.contains(evt.target)) {
          _this.setState({
            open: !_this.state.open
          });

          _this.props.onClick(evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleKeyDown", function (evt) {
        if (matches(evt, [ArrowDown])) {
          _this.setState({
            open: !_this.state.open
          });

          _this.props.onClick(evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleKeyPress", function (evt) {
        if (_this.state.open && matches(evt, [ArrowUp, ArrowRight, ArrowDown, ArrowLeft])) {
          evt.preventDefault();
        } // Close the overflow menu on escape


        if (matches(evt, [Escape])) {
          _this.closeMenu(); // Stop the esc keypress from bubbling out and closing something it shouldn't


          evt.stopPropagation();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleClickOutside", function (evt) {
        if (_this.state.open && (!_this._menuBody || !_this._menuBody.contains(evt.target))) {
          _this.closeMenu();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "closeMenu", function () {
        var wasOpen = _this.state.open;

        _this.setState({
          open: false
        }, function () {
          if (wasOpen) {
            _this.focusMenuEl();
          }

          _this.props.onClose();
        });
      });

      _defineProperty(_assertThisInitialized(_this), "focusMenuEl", function () {
        var triggerEl = _this._triggerRef.current;

        if (triggerEl) {
          triggerEl.focus();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleOverflowMenuItemFocus", function (_ref) {
        var _overflowMenuItem$cur;

        var currentIndex = _ref.currentIndex,
            direction = _ref.direction;
        var enabledIndices = React__default.Children.toArray(_this.props.children).reduce(function (acc, curr, i) {
          if (!curr.props.disabled) {
            acc.push(i);
          }

          return acc;
        }, []);

        var nextValidIndex = function () {
          var nextIndex = enabledIndices.indexOf(currentIndex) + direction;

          switch (enabledIndices.indexOf(currentIndex) + direction) {
            case -1:
              return enabledIndices.length - 1;

            case enabledIndices.length:
              return 0;

            default:
              return nextIndex;
          }
        }();

        var overflowMenuItem = _this["overflowMenuItem".concat(enabledIndices[nextValidIndex])].overflowMenuItem;

        overflowMenuItem === null || overflowMenuItem === void 0 ? void 0 : (_overflowMenuItem$cur = overflowMenuItem.current) === null || _overflowMenuItem$cur === void 0 ? void 0 : _overflowMenuItem$cur.focus();
      });

      _defineProperty(_assertThisInitialized(_this), "_bindMenuBody", function (menuBody) {
        if (!menuBody) {
          _this._menuBody = menuBody;
        }

        if (!menuBody && _this._hFocusIn) {
          _this._hFocusIn = _this._hFocusIn.release();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_handlePlace", function (menuBody) {
        if (menuBody) {
          _this._menuBody = menuBody;
          var hasFocusin = ('onfocusin' in window);
          var focusinEventName = hasFocusin ? 'focusin' : 'focus';
          _this._hFocusIn = on$1(menuBody.ownerDocument, focusinEventName, function (event) {
            var target = event.target;
            var triggerEl = _this._triggerRef.current;

            if (!menuBody.contains(target) && triggerEl && !target.matches(".".concat(prefix$M, "--overflow-menu,.").concat(prefix$M, "--overflow-menu-options"))) {
              _this.closeMenu();
            }
          }, !hasFocusin);

          _this.props.onOpen();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_getTarget", function () {
        var triggerEl = _this._triggerRef.current;
        return triggerEl && triggerEl.closest('[data-floating-menu-container]') || document.body;
      });

      return _this;
    }

    _createClass(OverflowMenu, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(_, prevState) {
        var onClose = this.props.onClose;

        if (!this.state.open && prevState.isOpen) {
          onClose();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (typeof this._hBlurTimeout === 'number') {
          clearTimeout(this._hBlurTimeout);
          this._hBlurTimeout = undefined;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames,
            _classNames2,
            _this2 = this;

        var _this$props = this.props,
            id = _this$props.id,
            tabIndex = _this$props.tabIndex,
            ariaLabel = _this$props.ariaLabel,
            children = _this$props.children,
            iconDescription = _this$props.iconDescription,
            direction = _this$props.direction,
            flipped = _this$props.flipped,
            menuOffset = _this$props.menuOffset,
            menuOffsetFlip = _this$props.menuOffsetFlip,
            iconClass = _this$props.iconClass,
            onClick = _this$props.onClick,
            onOpen = _this$props.onOpen,
            _this$props$selectorP = _this$props.selectorPrimaryFocus,
            IconElement = _this$props.renderIcon,
            ref = _this$props.innerRef,
            menuOptionsClass = _this$props.menuOptionsClass,
            light = _this$props.light,
            other = _objectWithoutProperties(_this$props, ["id", "tabIndex", "ariaLabel", "children", "iconDescription", "direction", "flipped", "menuOffset", "menuOffsetFlip", "iconClass", "onClick", "onOpen", "selectorPrimaryFocus", "renderIcon", "innerRef", "menuOptionsClass", "light"]);

        var open = this.state.open;
        var overflowMenuClasses = classnames(this.props.className, "".concat(prefix$M, "--overflow-menu"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$M, "--overflow-menu--open"), open), _defineProperty(_classNames, "".concat(prefix$M, "--overflow-menu--light"), light), _classNames));
        var overflowMenuOptionsClasses = classnames(menuOptionsClass, "".concat(prefix$M, "--overflow-menu-options"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$M, "--overflow-menu--flip"), this.props.flipped), _defineProperty(_classNames2, "".concat(prefix$M, "--overflow-menu-options--open"), open), _defineProperty(_classNames2, "".concat(prefix$M, "--overflow-menu-options--light"), light), _classNames2));
        var overflowMenuIconClasses = classnames("".concat(prefix$M, "--overflow-menu__icon"), iconClass);
        var childrenWithProps = React__default.Children.toArray(children).map(function (child, index) {
          return /*#__PURE__*/React__default.cloneElement(child, {
            closeMenu: _this2.closeMenu,
            handleOverflowMenuItemFocus: _this2.handleOverflowMenuItemFocus,
            ref: function ref(e) {
              _this2["overflowMenuItem".concat(index)] = e;
            },
            index: index
          });
        });
        var menuBody = /*#__PURE__*/React__default.createElement("ul", {
          className: overflowMenuOptionsClasses,
          tabIndex: "-1",
          role: "menu",
          "aria-label": ariaLabel
        }, childrenWithProps);
        var wrappedMenuBody = /*#__PURE__*/React__default.createElement(FloatingMenu$1, {
          triggerRef: this._triggerRef,
          menuDirection: direction,
          menuOffset: flipped ? menuOffsetFlip : menuOffset,
          menuRef: this._bindMenuBody,
          flipped: this.props.flipped,
          target: this._getTarget,
          onPlace: this._handlePlace,
          selectorPrimaryFocus: this.props.selectorPrimaryFocus
        }, /*#__PURE__*/React__default.cloneElement(menuBody, {
          'data-floating-menu-direction': direction
        }));
        var iconProps = {
          onClick: this.handleClick,
          onKeyDown: this.handleKeyDown,
          className: overflowMenuIconClasses,
          'aria-label': iconDescription,
          focusable: 'false' // Prevent `<svg>` in trigger icon from getting focus for IE11

        };
        return /*#__PURE__*/React__default.createElement(ClickListener, {
          onClickOutside: this.handleClickOutside
        }, /*#__PURE__*/React__default.createElement("button", _extends({}, other, {
          "aria-haspopup": true,
          "aria-expanded": this.state.open,
          className: overflowMenuClasses,
          onKeyDown: this.handleKeyPress,
          onClick: this.handleClick,
          "aria-label": ariaLabel,
          id: id,
          tabIndex: tabIndex,
          ref: mergeRefs(this._triggerRef, ref)
        }), /*#__PURE__*/React__default.createElement(IconElement, iconProps, iconDescription && /*#__PURE__*/React__default.createElement("title", null, iconDescription)), open && wrappedMenuBody));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, state) {
        var open = _ref2.open;
        var prevOpen = state.prevOpen;
        return prevOpen === open ? null : {
          open: open,
          prevOpen: open
        };
      }
    }]);

    return OverflowMenu;
  }(React.Component);

  _defineProperty(OverflowMenu$1, "propTypes", {
    /**
     * `true` if the menu should be open.
     */
    open: PropTypes.bool,

    /**
     * The menu direction.
     */
    direction: PropTypes.oneOf([DIRECTION_TOP$1, DIRECTION_BOTTOM$1]),

    /**
     * `true` if the menu alignment should be flipped.
     */
    flipped: PropTypes.bool,

    /**
     * The child nodes.
     */
    children: PropTypes.node,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * The `tabindex` attribute.
     */
    tabIndex: PropTypes.number,

    /**
     * The element ID.
     */
    id: PropTypes.string,

    /**
     * The ARIA label.
     */
    ariaLabel: PropTypes.string,

    /**
     * The event handler for the `click` event.
     */
    onClick: PropTypes.func,

    /**
     * The event handler for the `focus` event.
     */
    onFocus: PropTypes.func,

    /**
     * The event handler for the `keydown` event.
     */
    onKeyDown: PropTypes.func,

    /**
     * The icon description.
     */
    iconDescription: PropTypes.string.isRequired,

    /**
     * The adjustment in position applied to the floating menu.
     */
    menuOffset: PropTypes.oneOfType([PropTypes.shape({
      top: PropTypes.number,
      left: PropTypes.number
    }), PropTypes.func]),

    /**
     * The adjustment in position applied to the floating menu.
     */
    menuOffsetFlip: PropTypes.oneOfType([PropTypes.shape({
      top: PropTypes.number,
      left: PropTypes.number
    }), PropTypes.func]),

    /**
     * The CSS class for the icon.
     */
    iconClass: PropTypes.string,

    /**
     * Function called to override icon rendering.
     */
    renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),

    /**
     * Function called when menu is closed
     */
    onClose: PropTypes.func,

    /**
     * The class to apply to the menu options
     */
    menuOptionsClass: PropTypes.string,

    /**
     * Function called when menu is closed
     */
    onOpen: PropTypes.func,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make OverflowMenu background color same as container background color.
     */
    light: PropTypes.bool,

    /**
     * Specify a CSS selector that matches the DOM element that should
     * be focused when the OverflowMenu opens
     */
    selectorPrimaryFocus: PropTypes.string
  });

  _defineProperty(OverflowMenu$1, "defaultProps", {
    ariaLabel: 'Menu',
    iconDescription: 'open and close list of options',
    open: false,
    direction: DIRECTION_BOTTOM$1,
    flipped: false,
    renderIcon: OverflowMenuVertical16,
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {},
    onClose: function onClose() {},
    onOpen: function onOpen() {},
    tabIndex: 0,
    menuOffset: getMenuOffset$2,
    menuOffsetFlip: getMenuOffset$2,
    light: false,
    selectorPrimaryFocus: '[data-overflow-menu-primary-focus]'
  });

  var OverflowMenu$2 = (function () {
    var forwardRef = function forwardRef(props, ref) {
      return /*#__PURE__*/React__default.createElement(OverflowMenu$1, _extends({}, props, {
        innerRef: ref
      }));
    };

    forwardRef.displayName = 'OverflowMenu';
    return /*#__PURE__*/React__default.forwardRef(forwardRef);
  })();

  var prefix$N = settings_1.prefix;

  var TableToolbarMenu = function TableToolbarMenu(_ref) {
    var className = _ref.className,
        renderIcon = _ref.renderIcon,
        iconDescription = _ref.iconDescription,
        children = _ref.children,
        rest = _objectWithoutProperties(_ref, ["className", "renderIcon", "iconDescription", "children"]);

    var toolbarActionClasses = classnames(className, "".concat(prefix$N, "--toolbar-action ").concat(prefix$N, "--overflow-menu"));
    return /*#__PURE__*/React__default.createElement(OverflowMenu$2, _extends({
      ariaLabel: iconDescription,
      renderIcon: renderIcon,
      className: toolbarActionClasses,
      title: iconDescription,
      iconDescription: iconDescription,
      flipped: true
    }, rest), children);
  };

  TableToolbarMenu.defaultProps = {
    renderIcon: Settings16,
    iconDescription: 'Settings'
  };
  TableToolbarMenu.propTypes = {
    children: PropTypes.node.isRequired,

    /**
     * Provide an optional class name for the toolbar menu
     */
    className: PropTypes.string,

    /**
     * Optional prop to allow overriding the default menu icon
     */
    renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),

    /**
     * The description of the menu icon.
     */
    iconDescription: PropTypes.string.isRequired
  };

  DataTable$1.Table = Table;
  DataTable$1.TableActionList = TableActionList;
  DataTable$1.TableBatchAction = TableBatchAction;
  DataTable$1.TableBatchActions = TableBatchActions;
  DataTable$1.TableBody = TableBody;
  DataTable$1.TableCell = TableCell;
  DataTable$1.TableContainer = TableContainer;
  DataTable$1.TableExpandHeader = TableExpandHeader;
  DataTable$1.TableExpandRow = TableExpandRow;
  DataTable$1.TableExpandedRow = TableExpandedRow;
  DataTable$1.TableHead = TableHead;
  DataTable$1.TableHeader = TableHeader;
  DataTable$1.TableRow = TableRow;
  DataTable$1.TableSelectAll = TableSelectAll;
  DataTable$1.TableSelectRow = TableSelectRow;
  DataTable$1.TableToolbar = TableToolbar;
  DataTable$1.TableToolbarAction = TableToolbarAction;
  DataTable$1.TableToolbarContent = TableToolbarContent;
  DataTable$1.TableToolbarSearch = TableToolbarSearch;
  DataTable$1.TableToolbarMenu = TableToolbarMenu;

  var prefix$O = settings_1.prefix;

  var DatePickerSkeleton = function DatePickerSkeleton(_ref) {
    var range = _ref.range,
        id = _ref.id,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["range", "id", "className"]);

    var dateInput = /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$O, "--date-picker-container")
    },
    /*#__PURE__*/

    /* eslint-disable jsx-a11y/label-has-for,jsx-a11y/label-has-associated-control */
    React__default.createElement("label", {
      className: "".concat(prefix$O, "--label"),
      htmlFor: id
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$O, "--date-picker__input ").concat(prefix$O, "--skeleton")
    }));

    if (range) {
      return /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$O, "--form-item")
      }, /*#__PURE__*/React__default.createElement("div", _extends({
        className: classnames("".concat(prefix$O, "--date-picker"), "".concat(prefix$O, "--date-picker--range"), "".concat(prefix$O, "--skeleton"), className)
      }, rest), dateInput, dateInput));
    }

    return /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$O, "--form-item")
    }, /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$O, "--date-picker"), "".concat(prefix$O, "--date-picker--short"), "".concat(prefix$O, "--date-picker--simple"), "".concat(prefix$O, "--skeleton"), className)
    }, rest), dateInput));
  };

  DatePickerSkeleton.propTypes = {
    /**
     * Specify whether the skeleton should be of range date picker.
     */
    range: PropTypes.bool,

    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string,

    /**
     * Specify the id to add.
     */
    id: PropTypes.string
  };

  var l10n = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       factory(exports) ;
    })(commonjsGlobal, function (exports) {
      /*! *****************************************************************************
      Copyright (c) Microsoft Corporation. All rights reserved.
      Licensed under the Apache License, Version 2.0 (the "License"); you may not use
      this file except in compliance with the License. You may obtain a copy of the
      License at http://www.apache.org/licenses/LICENSE-2.0
        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
      WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
      MERCHANTABLITY OR NON-INFRINGEMENT.
        See the Apache Version 2.0 License for specific language governing permissions
      and limitations under the License.
      ***************************************************************************** */

      var _assign = function __assign() {
        _assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];

            for (var p in s) {
              if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
          }

          return t;
        };

        return _assign.apply(this, arguments);
      };

      var fp = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Arabic = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        rangeSeparator: ' - '
      };
      fp.l10ns.ar = Arabic;
      fp.l10ns;
      var fp$1 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Austria = {
        weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
        },
        months: {
          shorthand: ["Jn", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
          longhand: ["Jnner", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "KW",
        rangeSeparator: " bis ",
        scrollTitle: "Zum ndern scrollen",
        toggleTitle: "Zum Umschalten klicken"
      };
      fp$1.l10ns.at = Austria;
      fp$1.l10ns;
      var fp$2 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Azerbaijan = {
        weekdays: {
          shorthand: ["Baz", "BzE", "Ax", "r", "CAx", "Cm", "n"],
          longhand: ["Bazar", "Bazar ertsi", "rnb axam", "rnb", "Cm axam", "Cm", "nb"]
        },
        months: {
          shorthand: ["Yan", "Fev", "Mar", "Apr", "May", "yn", "yl", "Avq", "Sen", "Okt", "Noy", "Dek"],
          longhand: ["Yanvar", "Fevral", "Mart", "Aprel", "May", "yun", "yul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return ".";
        },
        rangeSeparator: " - ",
        weekAbbreviation: "Hf",
        scrollTitle: "Artrmaq n srdrn",
        toggleTitle: "A / Bala",
        amPM: ["G", "GS"],
        time_24hr: true
      };
      fp$2.l10ns.az = Azerbaijan;
      fp$2.l10ns;
      var fp$3 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Belarusian = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "";
        },
        rangeSeparator: "  ",
        weekAbbreviation: ".",
        scrollTitle: "  ",
        toggleTitle: "  ",
        amPM: ["", ""],
        yearAriaLabel: "",
        time_24hr: true
      };
      fp$3.l10ns.be = Belarusian;
      fp$3.l10ns;
      var fp$4 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Bosnian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sri", "et", "Pet", "Sub"],
          longhand: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "etvrtak", "Petak", "Subota"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Januar", "Februar", "Mart", "April", "Maj", "Juni", "Juli", "August", "Septembar", "Oktobar", "Novembar", "Decembar"]
        },
        time_24hr: true
      };
      fp$4.l10ns.bs = Bosnian;
      fp$4.l10ns;
      var fp$5 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Bulgarian = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        time_24hr: true,
        firstDayOfWeek: 1
      };
      fp$5.l10ns.bg = Bulgarian;
      fp$5.l10ns;
      var fp$6 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Bangla = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        }
      };
      fp$6.l10ns.bn = Bangla;
      fp$6.l10ns;
      var fp$7 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Catalan = {
        weekdays: {
          shorthand: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
          longhand: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
        },
        months: {
          shorthand: ["Gen", "Febr", "Mar", "Abr", "Maig", "Juny", "Jul", "Ag", "Set", "Oct", "Nov", "Des"],
          longhand: ["Gener", "Febrer", "Mar", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"]
        },
        ordinal: function ordinal(nth) {
          var s = nth % 100;
          if (s > 3 && s < 21) return "";

          switch (s % 10) {
            case 1:
              return "r";

            case 2:
              return "n";

            case 3:
              return "r";

            case 4:
              return "t";

            default:
              return "";
          }
        },
        firstDayOfWeek: 1,
        time_24hr: true
      };
      fp$7.l10ns.cat = Catalan;
      fp$7.l10ns;
      var fp$8 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Czech = {
        weekdays: {
          shorthand: ["Ne", "Po", "t", "St", "t", "P", "So"],
          longhand: ["Nedle", "Pondl", "ter", "Steda", "tvrtek", "Ptek", "Sobota"]
        },
        months: {
          shorthand: ["Led", "n", "Be", "Dub", "Kv", "er", "vc", "Srp", "Z", "j", "Lis", "Pro"],
          longhand: ["Leden", "nor", "Bezen", "Duben", "Kvten", "erven", "ervenec", "Srpen", "Z", "jen", "Listopad", "Prosinec"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return ".";
        },
        rangeSeparator: " do ",
        weekAbbreviation: "Td.",
        scrollTitle: "Rolujte pro zmnu",
        toggleTitle: "Pepnout dopoledne/odpoledne",
        amPM: ["dop.", "odp."],
        yearAriaLabel: "Rok",
        time_24hr: true
      };
      fp$8.l10ns.cs = Czech;
      fp$8.l10ns;
      var fp$9 = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Welsh = {
        weekdays: {
          shorthand: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
          longhand: ["Dydd Sul", "Dydd Llun", "Dydd Mawrth", "Dydd Mercher", "Dydd Iau", "Dydd Gwener", "Dydd Sadwrn"]
        },
        months: {
          shorthand: ["Ion", "Chwef", "Maw", "Ebr", "Mai", "Meh", "Gorff", "Awst", "Medi", "Hyd", "Tach", "Rhag"],
          longhand: ["Ionawr", "Chwefror", "Mawrth", "Ebrill", "Mai", "Mehefin", "Gorffennaf", "Awst", "Medi", "Hydref", "Tachwedd", "Rhagfyr"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal(nth) {
          if (nth === 1) return "af";
          if (nth === 2) return "ail";
          if (nth === 3 || nth === 4) return "ydd";
          if (nth === 5 || nth === 6) return "ed";
          if (nth >= 7 && nth <= 10 || nth == 12 || nth == 15 || nth == 18 || nth == 20) return "fed";
          if (nth == 11 || nth == 13 || nth == 14 || nth == 16 || nth == 17 || nth == 19) return "eg";
          if (nth >= 21 && nth <= 39) return "ain"; // Inconclusive.

          return "";
        },
        time_24hr: true
      };
      fp$9.l10ns.cy = Welsh;
      fp$9.l10ns;
      var fp$a = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Danish = {
        weekdays: {
          shorthand: ["sn", "man", "tir", "ons", "tors", "fre", "lr"],
          longhand: ["sndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lrdag"]
        },
        months: {
          shorthand: ["jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec"],
          longhand: ["januar", "februar", "marts", "april", "maj", "juni", "juli", "august", "september", "oktober", "november", "december"]
        },
        ordinal: function ordinal() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "uge",
        time_24hr: true
      };
      fp$a.l10ns.da = Danish;
      fp$a.l10ns;
      var fp$b = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var German = {
        weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
          longhand: ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "KW",
        rangeSeparator: " bis ",
        scrollTitle: "Zum ndern scrollen",
        toggleTitle: "Zum Umschalten klicken",
        time_24hr: true
      };
      fp$b.l10ns.de = German;
      fp$b.l10ns;
      var english = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function ordinal(nth) {
          var s = nth % 100;
          if (s > 3 && s < 21) return "th";

          switch (s % 10) {
            case 1:
              return "st";

            case 2:
              return "nd";

            case 3:
              return "rd";

            default:
              return "th";
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        time_24hr: false
      };
      var fp$c = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Esperanto = {
        firstDayOfWeek: 1,
        rangeSeparator: " is ",
        weekAbbreviation: "Sem",
        scrollTitle: "Rulumu por pligrandigi la valoron",
        toggleTitle: "Klaku por alti",
        weekdays: {
          shorthand: ["Dim", "Lun", "Mar", "Mer", "a", "Ven", "Sab"],
          longhand: ["dimano", "lundo", "mardo", "merkredo", "ado", "vendredo", "sabato"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Ag", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["januaro", "februaro", "marto", "aprilo", "majo", "junio", "julio", "agusto", "septembro", "oktobro", "novembro", "decembro"]
        },
        ordinal: function ordinal() {
          return "-a";
        },
        time_24hr: true
      };
      fp$c.l10ns.eo = Esperanto;
      fp$c.l10ns;
      var fp$d = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Spanish = {
        weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mi", "Jue", "Vie", "Sb"],
          longhand: ["Domingo", "Lunes", "Martes", "Mircoles", "Jueves", "Viernes", "Sbado"]
        },
        months: {
          shorthand: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
          longhand: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"]
        },
        ordinal: function ordinal() {
          return "";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " a ",
        time_24hr: true
      };
      fp$d.l10ns.es = Spanish;
      fp$d.l10ns;
      var fp$e = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Estonian = {
        weekdays: {
          shorthand: ["P", "E", "T", "K", "N", "R", "L"],
          longhand: ["Phapev", "Esmaspev", "Teisipev", "Kolmapev", "Neljapev", "Reede", "Laupev"]
        },
        months: {
          shorthand: ["Jaan", "Veebr", "Mrts", "Apr", "Mai", "Juuni", "Juuli", "Aug", "Sept", "Okt", "Nov", "Dets"],
          longhand: ["Jaanuar", "Veebruar", "Mrts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return ".";
        },
        weekAbbreviation: "Nd",
        rangeSeparator: " kuni ",
        scrollTitle: "Keri, et suurendada",
        toggleTitle: "Klpsa, et vahetada",
        time_24hr: true
      };
      fp$e.l10ns.et = Estonian;
      fp$e.l10ns;
      var fp$f = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Persian = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        firstDayOfWeek: 6,
        ordinal: function ordinal() {
          return "";
        }
      };
      fp$f.l10ns.fa = Persian;
      fp$f.l10ns;
      var fp$g = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Finnish = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
          longhand: ["Sunnuntai", "Maanantai", "Tiistai", "Keskiviikko", "Torstai", "Perjantai", "Lauantai"]
        },
        months: {
          shorthand: ["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kes", "Hein", "Elo", "Syys", "Loka", "Marras", "Joulu"],
          longhand: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Keskuu", "Heinkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"]
        },
        ordinal: function ordinal() {
          return ".";
        },
        time_24hr: true
      };
      fp$g.l10ns.fi = Finnish;
      fp$g.l10ns;
      var fp$h = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Faroese = {
        weekdays: {
          shorthand: ["Sun", "Mn", "Ts", "Mik", "Hs", "Fr", "Ley"],
          longhand: ["Sunnudagur", "Mnadagur", "Tsdagur", "Mikudagur", "Hsdagur", "Frggjadagur", "Leygardagur"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
          longhand: ["Januar", "Februar", "Mars", "Aprl", "Mai", "Juni", "Juli", "August", "Septembur", "Oktobur", "Novembur", "Desembur"]
        },
        ordinal: function ordinal() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "vika",
        scrollTitle: "Rulla fyri at broyta",
        toggleTitle: "Trst fyri at skifta",
        yearAriaLabel: "r",
        time_24hr: true
      };
      fp$h.l10ns.fo = Faroese;
      fp$h.l10ns;
      var fp$i = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var French = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
        },
        months: {
          shorthand: ["janv", "fvr", "mars", "avr", "mai", "juin", "juil", "aot", "sept", "oct", "nov", "dc"],
          longhand: ["janvier", "fvrier", "mars", "avril", "mai", "juin", "juillet", "aot", "septembre", "octobre", "novembre", "dcembre"]
        },
        ordinal: function ordinal(nth) {
          if (nth > 1) return "";
          return "er";
        },
        rangeSeparator: " au ",
        weekAbbreviation: "Sem",
        scrollTitle: "Dfiler pour augmenter la valeur",
        toggleTitle: "Cliquer pour basculer",
        time_24hr: true
      };
      fp$i.l10ns.fr = French;
      fp$i.l10ns;
      var fp$j = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Greek = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "";
        },
        weekAbbreviation: "",
        rangeSeparator: "  ",
        scrollTitle: "  ",
        toggleTitle: "   ",
        amPM: ["", ""]
      };
      fp$j.l10ns.gr = Greek;
      fp$j.l10ns;
      var fp$k = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Hebrew = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        rangeSeparator: "  ",
        time_24hr: true
      };
      fp$k.l10ns.he = Hebrew;
      fp$k.l10ns;
      var fp$l = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Hindi = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: [" ", "", "", "", "", "", "", " ", "", "", "", ""]
        }
      };
      fp$l.l10ns.hi = Hindi;
      fp$l.l10ns;
      var fp$m = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Croatian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sri", "et", "Pet", "Sub"],
          longhand: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "etvrtak", "Petak", "Subota"]
        },
        months: {
          shorthand: ["Sij", "Velj", "Ou", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"],
          longhand: ["Sijeanj", "Veljaa", "Oujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"]
        },
        time_24hr: true
      };
      fp$m.l10ns.hr = Croatian;
      fp$m.l10ns;
      var fp$n = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Hungarian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["V", "H", "K", "Sz", "Cs", "P", "Szo"],
          longhand: ["Vasrnap", "Htf", "Kedd", "Szerda", "Cstrtk", "Pntek", "Szombat"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mr", "pr", "Mj", "Jn", "Jl", "Aug", "Szep", "Okt", "Nov", "Dec"],
          longhand: ["Janur", "Februr", "Mrcius", "prilis", "Mjus", "Jnius", "Jlius", "Augusztus", "Szeptember", "Oktber", "November", "December"]
        },
        ordinal: function ordinal() {
          return ".";
        },
        weekAbbreviation: "Ht",
        scrollTitle: "Grgessen",
        toggleTitle: "Kattintson a vltshoz",
        rangeSeparator: " - ",
        time_24hr: true
      };
      fp$n.l10ns.hu = Hungarian;
      fp$n.l10ns;
      var fp$o = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Indonesian = {
        weekdays: {
          shorthand: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
          longhand: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agu", "Sep", "Okt", "Nov", "Des"],
          longhand: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "";
        },
        time_24hr: true,
        rangeSeparator: ' - '
      };
      fp$o.l10ns.id = Indonesian;
      fp$o.l10ns;
      var fp$p = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Icelandic = {
        weekdays: {
          shorthand: ["Sun", "Mn", "ri", "Mi", "Fim", "Fs", "Lau"],
          longhand: ["Sunnudagur", "Mnudagur", "rijudagur", "Mivikudagur", "Fimmtudagur", "Fstudagur", "Laugardagur"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Ma", "Jn", "Jl", "g", "Sep", "Okt", "Nv", "Des"],
          longhand: ["Janar", "Febrar", "Mars", "Aprl", "Ma", "Jn", "Jl", "gst", "September", "Oktber", "Nvember", "Desember"]
        },
        ordinal: function ordinal() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "vika",
        yearAriaLabel: "r",
        time_24hr: true
      };
      fp$p.l10ns.is = Icelandic;
      fp$p.l10ns;
      var fp$q = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Italian = {
        weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: ["Domenica", "Luned", "Marted", "Mercoled", "Gioved", "Venerd", "Sabato"]
        },
        months: {
          shorthand: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"],
          longhand: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "";
        },
        rangeSeparator: " al ",
        weekAbbreviation: "Se",
        scrollTitle: "Scrolla per aumentare",
        toggleTitle: "Clicca per cambiare",
        time_24hr: true
      };
      fp$q.l10ns.it = Italian;
      fp$q.l10ns;
      var fp$r = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Japanese = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
          longhand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]
        },
        time_24hr: true,
        rangeSeparator: '  '
      };
      fp$r.l10ns.ja = Japanese;
      fp$r.l10ns;
      var fp$s = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Korean = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
          longhand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]
        },
        ordinal: function ordinal() {
          return "";
        },
        rangeSeparator: ' ~ '
      };
      fp$s.l10ns.ko = Korean;
      fp$s.l10ns;
      var fp$t = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Khmer = {
        weekdays: {
          shorthand: ["", "", "", "", ".", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        ordinal: function ordinal() {
          return "";
        },
        firstDayOfWeek: 1,
        rangeSeparator: "  ",
        weekAbbreviation: "",
        scrollTitle: "",
        toggleTitle: "",
        yearAriaLabel: "",
        time_24hr: true
      };
      fp$t.l10ns.km = Khmer;
      fp$t.l10ns;
      var fp$u = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Kazakh = {
        weekdays: {
          shorthand: ["", "", "c", "", "", "", ""],
          longhand: ["i", "i", "i", "i", "i", "", "i"]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "i", "", "", "", "", ""],
          longhand: ["", "", "", "i", "", "", "i", "", "", "", "", ""]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "";
        },
        rangeSeparator: "  ",
        weekAbbreviation: "",
        scrollTitle: "  ",
        toggleTitle: "  ",
        amPM: ["", ""],
        yearAriaLabel: ""
      };
      fp$u.l10ns.kz = Kazakh;
      fp$u.l10ns;
      var fp$v = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Lithuanian = {
        weekdays: {
          shorthand: ["S", "Pr", "A", "T", "K", "Pn", ""],
          longhand: ["Sekmadienis", "Pirmadienis", "Antradienis", "Treiadienis", "Ketvirtadienis", "Penktadienis", "etadienis"]
        },
        months: {
          shorthand: ["Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rgp", "Rgs", "Spl", "Lap", "Grd"],
          longhand: ["Sausis", "Vasaris", "Kovas", "Balandis", "Gegu", "Birelis", "Liepa", "Rugpjutis", "Rugsejis", "Spalis", "Lapkritis", "Gruodis"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "-a";
        },
        weekAbbreviation: "Sav",
        scrollTitle: "Keisti laik pels rateliu",
        toggleTitle: "Perjungti laiko format",
        time_24hr: true
      };
      fp$v.l10ns.lt = Lithuanian;
      fp$v.l10ns;
      var fp$w = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Latvian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Sv", "Pr", "Ot", "Tr", "Ce", "Pk", "Se"],
          longhand: ["Svtdiena", "Pirmdiena", "Otrdiena", "Trediena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jn", "Jl", "Aug", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Janvris", "Februris", "Marts", "Aprlis", "Maijs", "Jnijs", "Jlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"]
        },
        rangeSeparator: " ldz ",
        time_24hr: true
      };
      fp$w.l10ns.lv = Latvian;
      fp$w.l10ns;
      var fp$x = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Macedonian = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: ".",
        rangeSeparator: "  ",
        time_24hr: true
      };
      fp$x.l10ns.mk = Macedonian;
      fp$x.l10ns;
      var fp$y = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Mongolian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["1- ", "2- ", "3- ", "4- ", "5- ", "6- ", "7- ", "8- ", "9- ", "10- ", "11- ", "12- "],
          longhand: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
        },
        rangeSeparator: "- ",
        time_24hr: true
      };
      fp$y.l10ns.mn = Mongolian;
      fp$y.l10ns;
      var fp$z = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Malaysian = {
        weekdays: {
          shorthand: ["Min", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
          longhand: ["Minggu", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ogo", "Sep", "Okt", "Nov", "Dis"],
          longhand: ["Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "";
        }
      };
      fp$z.l10ns;
      var fp$A = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Burmese = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "";
        },
        time_24hr: true
      };
      fp$A.l10ns.my = Burmese;
      fp$A.l10ns;
      var fp$B = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Dutch = {
        weekdays: {
          shorthand: ["zo", "ma", "di", "wo", "do", "vr", "za"],
          longhand: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
        },
        months: {
          shorthand: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sept", "okt", "nov", "dec"],
          longhand: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "wk",
        rangeSeparator: " tot ",
        scrollTitle: "Scroll voor volgende / vorige",
        toggleTitle: "Klik om te wisselen",
        time_24hr: true,
        ordinal: function ordinal(nth) {
          if (nth === 1 || nth === 8 || nth >= 20) return "ste";
          return "de";
        }
      };
      fp$B.l10ns.nl = Dutch;
      fp$B.l10ns;
      var fp$C = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Norwegian = {
        weekdays: {
          shorthand: ["Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr"],
          longhand: ["Sndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
          longhand: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "Uke",
        scrollTitle: "Scroll for  endre",
        toggleTitle: "Klikk for  veksle",
        time_24hr: true,
        ordinal: function ordinal() {
          return ".";
        }
      };
      fp$C.l10ns.no = Norwegian;
      fp$C.l10ns;
      var fp$D = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Punjabi = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        time_24hr: true
      };
      fp$D.l10ns.pa = Punjabi;
      fp$D.l10ns;
      var fp$E = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Polish = {
        weekdays: {
          shorthand: ["Nd", "Pn", "Wt", "r", "Cz", "Pt", "So"],
          longhand: ["Niedziela", "Poniedziaek", "Wtorek", "roda", "Czwartek", "Pitek", "Sobota"]
        },
        months: {
          shorthand: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Pa", "Lis", "Gru"],
          longhand: ["Stycze", "Luty", "Marzec", "Kwiecie", "Maj", "Czerwiec", "Lipiec", "Sierpie", "Wrzesie", "Padziernik", "Listopad", "Grudzie"]
        },
        rangeSeparator: " do ",
        weekAbbreviation: "tydz.",
        scrollTitle: "Przewi, aby zwikszy",
        toggleTitle: "Kliknij, aby przeczy",
        firstDayOfWeek: 1,
        time_24hr: true,
        ordinal: function ordinal() {
          return ".";
        }
      };
      fp$E.l10ns.pl = Polish;
      fp$E.l10ns;
      var fp$F = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Portuguese = {
        weekdays: {
          shorthand: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb"],
          longhand: ["Domingo", "Segunda-feira", "Tera-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sbado"]
        },
        months: {
          shorthand: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
          longhand: ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
        },
        rangeSeparator: " at ",
        time_24hr: true
      };
      fp$F.l10ns.pt = Portuguese;
      fp$F.l10ns;
      var fp$G = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Romanian = {
        weekdays: {
          shorthand: ["Dum", "Lun", "Mar", "Mie", "Joi", "Vin", "Sm"],
          longhand: ["Duminic", "Luni", "Mari", "Miercuri", "Joi", "Vineri", "Smbt"]
        },
        months: {
          shorthand: ["Ian", "Feb", "Mar", "Apr", "Mai", "Iun", "Iul", "Aug", "Sep", "Oct", "Noi", "Dec"],
          longhand: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"]
        },
        firstDayOfWeek: 1,
        time_24hr: true,
        ordinal: function ordinal() {
          return "";
        }
      };
      fp$G.l10ns.ro = Romanian;
      fp$G.l10ns;
      var fp$H = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Russian = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return "";
        },
        rangeSeparator: "  ",
        weekAbbreviation: ".",
        scrollTitle: "  ",
        toggleTitle: "  ",
        amPM: ["", ""],
        yearAriaLabel: "",
        time_24hr: true
      };
      fp$H.l10ns.ru = Russian;
      fp$H.l10ns;
      var fp$I = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Sinhala = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        time_24hr: true
      };
      fp$I.l10ns.si = Sinhala;
      fp$I.l10ns;
      var fp$J = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Slovak = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Ut", "Str", "tv", "Pia", "Sob"],
          longhand: ["Nedea", "Pondelok", "Utorok", "Streda", "tvrtok", "Piatok", "Sobota"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mj", "Jn", "Jl", "Aug", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Janur", "Februr", "Marec", "Aprl", "Mj", "Jn", "Jl", "August", "September", "Oktber", "November", "December"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " do ",
        time_24hr: true,
        ordinal: function ordinal() {
          return ".";
        }
      };
      fp$J.l10ns.sk = Slovak;
      fp$J.l10ns;
      var fp$K = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Slovenian = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Tor", "Sre", "et", "Pet", "Sob"],
          longhand: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "etrtek", "Petek", "Sobota"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " do ",
        time_24hr: true,
        ordinal: function ordinal() {
          return ".";
        }
      };
      fp$K.l10ns.sl = Slovenian;
      fp$K.l10ns;
      var fp$L = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Albanian = {
        weekdays: {
          shorthand: ["Di", "H", "Ma", "M", "En", "Pr", "Sh"],
          longhand: ["E Diel", "E Hn", "E Mart", "E Mrkur", "E Enjte", "E Premte", "E Shtun"]
        },
        months: {
          shorthand: ["Jan", "Shk", "Mar", "Pri", "Maj", "Qer", "Kor", "Gus", "Sht", "Tet", "Nn", "Dhj"],
          longhand: ["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nntor", "Dhjetor"]
        },
        time_24hr: true
      };
      fp$L.l10ns.sq = Albanian;
      fp$L.l10ns;
      var fp$M = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Serbian = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sre", "et", "Pet", "Sub"],
          longhand: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "etvrtak", "Petak", "Subota"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "Ned.",
        rangeSeparator: " do ",
        time_24hr: true
      };
      fp$M.l10ns.sr = Serbian;
      fp$M.l10ns;
      var fp$N = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Swedish = {
        firstDayOfWeek: 1,
        weekAbbreviation: "v",
        weekdays: {
          shorthand: ["Sn", "Mn", "Tis", "Ons", "Tor", "Fre", "Lr"],
          longhand: ["Sndag", "Mndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"]
        },
        time_24hr: true,
        ordinal: function ordinal() {
          return ".";
        }
      };
      fp$N.l10ns.sv = Swedish;
      fp$N.l10ns;
      var fp$O = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Thai = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["..", "..", "..", "..", "..", "..", "..", "..", "..", "..", "..", ".."],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        firstDayOfWeek: 1,
        rangeSeparator: "  ",
        scrollTitle: "",
        toggleTitle: "",
        time_24hr: true,
        ordinal: function ordinal() {
          return "";
        }
      };
      fp$O.l10ns.th = Thai;
      fp$O.l10ns;
      var fp$P = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Turkish = {
        weekdays: {
          shorthand: ["Paz", "Pzt", "Sal", "ar", "Per", "Cum", "Cmt"],
          longhand: ["Pazar", "Pazartesi", "Sal", "aramba", "Perembe", "Cuma", "Cumartesi"]
        },
        months: {
          shorthand: ["Oca", "ub", "Mar", "Nis", "May", "Haz", "Tem", "Au", "Eyl", "Eki", "Kas", "Ara"],
          longhand: ["Ocak", "ubat", "Mart", "Nisan", "Mays", "Haziran", "Temmuz", "Austos", "Eyll", "Ekim", "Kasm", "Aralk"]
        },
        firstDayOfWeek: 1,
        ordinal: function ordinal() {
          return ".";
        },
        rangeSeparator: " - ",
        weekAbbreviation: "Hf",
        scrollTitle: "Artrmak iin kaydrn",
        toggleTitle: "A/Kapa",
        amPM: ["", "S"],
        time_24hr: true
      };
      fp$P.l10ns.tr = Turkish;
      fp$P.l10ns;
      var fp$Q = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Ukrainian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "'", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        time_24hr: true
      };
      fp$Q.l10ns.uk = Ukrainian;
      fp$Q.l10ns;
      var fp$R = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Vietnamese = {
        weekdays: {
          shorthand: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
          longhand: ["Ch nht", "Th hai", "Th ba", "Th t", "Th nm", "Th su", "Th by"]
        },
        months: {
          shorthand: ["Th1", "Th2", "Th3", "Th4", "Th5", "Th6", "Th7", "Th8", "Th9", "Th10", "Th11", "Th12"],
          longhand: ["Thng mt", "Thng hai", "Thng ba", "Thng t", "Thng nm", "Thng su", "Thng by", "Thng tm", "Thng chn", "Thng mi", "Thng 11", "Thng 12"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: ' n '
      };
      fp$R.l10ns.vn = Vietnamese;
      fp$R.l10ns;
      var fp$S = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var Mandarin = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        rangeSeparator: "  ",
        weekAbbreviation: "",
        scrollTitle: "",
        toggleTitle: " 12/24 "
      };
      fp$S.l10ns.zh = Mandarin;
      fp$S.l10ns;
      var fp$T = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
        l10ns: {}
      };
      var MandarinTraditional = {
        weekdays: {
          shorthand: ["", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", ""]
        },
        months: {
          shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
          longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
        },
        rangeSeparator: "  ",
        weekAbbreviation: "",
        scrollTitle: "",
        toggleTitle: " 12/24 "
      };
      fp$T.l10ns.zh_tw = MandarinTraditional;
      fp$T.l10ns;
      var l10n = {
        ar: Arabic,
        at: Austria,
        az: Azerbaijan,
        be: Belarusian,
        bg: Bulgarian,
        bn: Bangla,
        bs: Bosnian,
        cat: Catalan,
        cs: Czech,
        cy: Welsh,
        da: Danish,
        de: German,
        "default": _assign({}, english),
        en: english,
        eo: Esperanto,
        es: Spanish,
        et: Estonian,
        fa: Persian,
        fi: Finnish,
        fo: Faroese,
        fr: French,
        gr: Greek,
        he: Hebrew,
        hi: Hindi,
        hr: Croatian,
        hu: Hungarian,
        id: Indonesian,
        is: Icelandic,
        it: Italian,
        ja: Japanese,
        ko: Korean,
        km: Khmer,
        kz: Kazakh,
        lt: Lithuanian,
        lv: Latvian,
        mk: Macedonian,
        mn: Mongolian,
        ms: Malaysian,
        my: Burmese,
        nl: Dutch,
        no: Norwegian,
        pa: Punjabi,
        pl: Polish,
        pt: Portuguese,
        ro: Romanian,
        ru: Russian,
        si: Sinhala,
        sk: Slovak,
        sl: Slovenian,
        sq: Albanian,
        sr: Serbian,
        sv: Swedish,
        th: Thai,
        tr: Turkish,
        uk: Ukrainian,
        vn: Vietnamese,
        zh: Mandarin,
        zh_tw: MandarinTraditional
      };
      exports.default = l10n;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
  });
  var l10n$1 = unwrapExports(l10n);

  var prefix$P = settings_1.prefix;

  var DatePickerInput = /*#__PURE__*/function (_Component) {
    _inherits(DatePickerInput, _Component);

    var _super = _createSuper(DatePickerInput);

    function DatePickerInput() {
      _classCallCheck(this, DatePickerInput);

      return _super.apply(this, arguments);
    }

    _createClass(DatePickerInput, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this = this;

        var _this$props = this.props,
            id = _this$props.id,
            labelText = _this$props.labelText,
            disabled = _this$props.disabled,
            invalid = _this$props.invalid,
            invalidText = _this$props.invalidText,
            hideLabel = _this$props.hideLabel,
            _onChange = _this$props.onChange,
            _onClick = _this$props.onClick,
            placeholder = _this$props.placeholder,
            type = _this$props.type,
            datePickerType = _this$props.datePickerType,
            pattern = _this$props.pattern,
            iconDescription = _this$props.iconDescription,
            openCalendar = _this$props.openCalendar,
            size = _this$props.size,
            other = _objectWithoutProperties(_this$props, ["id", "labelText", "disabled", "invalid", "invalidText", "hideLabel", "onChange", "onClick", "placeholder", "type", "datePickerType", "pattern", "iconDescription", "openCalendar", "size"]);

        var datePickerInputProps = {
          id: id,
          onChange: function onChange(evt) {
            if (!disabled) {
              _onChange(evt);
            }
          },
          onClick: function onClick(evt) {
            if (!disabled) {
              _onClick(evt);
            }
          },
          placeholder: placeholder,
          type: type,
          pattern: pattern
        };
        var labelClasses = classnames("".concat(prefix$P, "--label"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$P, "--visually-hidden"), hideLabel), _defineProperty(_classNames, "".concat(prefix$P, "--label--disabled"), disabled), _classNames));
        var inputClasses = classnames("".concat(prefix$P, "--date-picker__input"), _defineProperty({}, "".concat(prefix$P, "--date-picker__input--").concat(size), size));

        var datePickerIcon = function () {
          if (datePickerType === 'simple') {
            return;
          }

          return /*#__PURE__*/React__default.createElement(Calendar16, {
            className: "".concat(prefix$P, "--date-picker__icon"),
            "aria-label": iconDescription,
            onClick: openCalendar,
            role: "img"
          }, iconDescription && /*#__PURE__*/React__default.createElement("title", null, iconDescription));
        }();

        var label = labelText ? /*#__PURE__*/React__default.createElement("label", {
          htmlFor: id,
          className: labelClasses
        }, labelText) : null;
        var error = invalid ? /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$P, "--form-requirement")
        }, invalidText) : null;
        var containerClasses = classnames("".concat(prefix$P, "--date-picker-container"), _defineProperty({}, "".concat(prefix$P, "--date-picker--nolabel"), !label));
        var input = invalid ? /*#__PURE__*/React__default.createElement("input", _extends({}, other, datePickerInputProps, {
          disabled: disabled,
          ref: function ref(input) {
            _this.input = input;
          },
          "data-invalid": true,
          className: inputClasses
        })) : /*#__PURE__*/React__default.createElement("input", _extends({
          ref: function ref(input) {
            _this.input = input;
          }
        }, other, datePickerInputProps, {
          disabled: disabled,
          className: inputClasses
        }));
        return /*#__PURE__*/React__default.createElement("div", {
          className: containerClasses
        }, label, /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$P, "--date-picker-input__wrapper")
        }, input, datePickerIcon), error);
      }
    }]);

    return DatePickerInput;
  }(React.Component);

  _defineProperty(DatePickerInput, "propTypes", {
    /**
     * Specify an id that unique identifies the <input>
     */
    id: PropTypes.string.isRequired,

    /**
     * The description of the calendar icon.
     */
    iconDescription: PropTypes.string,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes.node.isRequired,

    /**
     * Specify the size of the Date Picker Input. Currently supports either `sm` or `xl` as an option.
     */
    size: PropTypes.oneOf(['sm', 'xl']),

    /**
     * Provide a regular expression that the input value must match
     */
    pattern: function pattern(props, propName, componentName) {
      if (props[propName] === undefined) {
        return;
      }

      try {
        new RegExp(props[propName]);
      } catch (e) {
        return new Error("Invalid value of prop '".concat(propName, "' supplied to '").concat(componentName, "', it should be a valid regular expression"));
      }
    },

    /**
     * Specify the type of the <input>
     */
    type: PropTypes.string,

    /**
     * Specify whether or not the input should be disabled
     */
    disabled: PropTypes.bool,

    /**
     * Specify whether or not the input should be invalid
     */
    invalid: PropTypes.bool,

    /**
     * Specify the text to be rendered when the input is invalid
     */
    invalidText: PropTypes.string,

    /**
     * Specify if the label should be hidden
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify the placeholder text
     */
    placeholder: PropTypes.string,

    /**
     * The type of the date picker:
     *
     * * `simple` - Without calendar dropdown.
     * * `single` - With calendar dropdown and single date.
     * * `range` - With calendar dropdown and a date range.
     */
    datePickerType: PropTypes.oneOf(['simple', 'single', 'range']),

    /**
     * Provide a function to be called when the input field is clicked
     */
    onClick: PropTypes.func,

    /**
     * Provide a function to be called when the input field is clicked
     */
    openCalendar: PropTypes.func,

    /**
     * Specify an `onChange` handler that is called whenever a change in the
     * input field has occurred
     */
    onChange: PropTypes.func
  });

  _defineProperty(DatePickerInput, "defaultProps", {
    pattern: '\\d{1,2}\\/\\d{1,2}\\/\\d{4}',
    type: 'text',
    disabled: false,
    invalid: false,
    onClick: function onClick() {},
    onChange: function onChange() {}
  });

  /**
   * @param {object} config Plugin configuration.
   * @returns {Plugin} A Flatpickr plugin to put adjust the position of calendar dropdown.
   */
  var carbonFlatpickrAppendToPlugin = (function (config) {
    return function (fp) {
      /**
       * Adjusts the floating meun position after Flatpicker sets it.
       */
      var handlePreCalendarPosition = function handlePreCalendarPosition() {
        Promise.resolve().then(function () {
          var calendarContainer = fp.calendarContainer,
              fpConfig = fp.config,
              positionElement = fp._positionElement;
          var appendTo = fpConfig.appendTo;

          var _appendTo$getBounding = appendTo.getBoundingClientRect(),
              containerLeft = _appendTo$getBounding.left,
              containerTop = _appendTo$getBounding.top;

          var _positionElement$getB = positionElement.getBoundingClientRect(),
              refLeft = _positionElement$getB.left,
              refBottom = _positionElement$getB.bottom;

          if ((appendTo !== appendTo.ownerDocument.body || containerLeft !== 0 || containerTop !== 0) && appendTo.ownerDocument.defaultView.getComputedStyle(appendTo).getPropertyValue('position') === 'static') {
            throw new Error('Floating menu container must not have `position:static`.');
          } // `2` for negative mergin on calendar dropdown


          calendarContainer.style.top = "".concat(refBottom - containerTop + 2, "px");
          calendarContainer.style.left = "".concat(refLeft - containerLeft, "px");
        });
      };
      /**
       * Registers this Flatpickr plugin.
       */


      var register = function register() {
        fp.loadedPlugins.push('carbonFlatpickrAppendToPlugin');
      };

      return {
        appendTo: config.appendTo,
        onReady: register,
        onPreCalendarPosition: handlePreCalendarPosition
      };
    };
  });

  /**
   * @param {object} config Plugin configuration.
   * @returns {Plugin} A Flatpickr plugin to fix Flatpickr's behavior of certain events.
   */

  var carbonFlatpickrFixEventsPlugin = (function (config) {
    return function (fp) {
      /**
       * Handles `keydown` event.
       */
      var handleKeydown = function handleKeydown(event) {
        var inputFrom = config.inputFrom,
            inputTo = config.inputTo;
        var target = event.target;

        if (inputFrom === target || inputTo === target) {
          if (match(event, Enter)) {
            // Makes sure the hitting enter key picks up pending values of both `<input>`
            // Workaround for: https://github.com/flatpickr/flatpickr/issues/1942
            fp.setDate([inputFrom.value, inputTo && inputTo.value], true, fp.config.dateFormat);
            event.stopPropagation();
          } else if (match(event, ArrowLeft) || match(event, ArrowRight)) {
            // Prevents Flatpickr code from canceling the event if left/right arrow keys are hit on `<input>`,
            // so user can move the keyboard cursor for editing dates
            // Workaround for: https://github.com/flatpickr/flatpickr/issues/1943
            event.stopPropagation();
          } else if (match(event, ArrowDown)) {
            event.preventDefault();
            fp.open();
          }
        }
      };
      /**
       * Releases event listeners used in this Flatpickr plugin.
       */


      var release = function release() {
        var inputFrom = config.inputFrom,
            inputTo = config.inputTo;

        if (inputTo) {
          inputTo.removeEventListener('keydown', handleKeydown, true);
        }

        inputFrom.removeEventListener('keydown', handleKeydown, true);
      };
      /**
       * Sets up event listeners used for this Flatpickr plugin.
       */


      var init = function init() {
        release();
        var inputFrom = config.inputFrom,
            inputTo = config.inputTo;
        inputFrom.addEventListener('keydown', handleKeydown, true);

        if (inputTo) {
          inputTo.addEventListener('keydown', handleKeydown, true);
        }
      };
      /**
       * Registers this Flatpickr plugin.
       */


      var register = function register() {
        fp.loadedPlugins.push('carbonFlatpickrFixEventsPlugin');
      };

      return {
        onReady: [register, init],
        onDestroy: [release]
      };
    };
  });

  var rangePlugin = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory() ;
    })(commonjsGlobal, function () {

      function rangePlugin(config) {
        if (config === void 0) {
          config = {};
        }

        return function (fp) {
          var dateFormat = "",
              secondInput,
              _secondInputFocused,
              _prevDates;

          var createSecondInput = function createSecondInput() {
            if (config.input) {
              secondInput = config.input instanceof Element ? config.input : window.document.querySelector(config.input);

              if (!secondInput) {
                fp.config.errorHandler(new Error("Invalid input element specified"));
                return;
              }

              if (fp.config.wrap) {
                secondInput = secondInput.querySelector("[data-input]");
              }
            } else {
              secondInput = fp._input.cloneNode();
              secondInput.removeAttribute("id");
              secondInput._flatpickr = undefined;
            }

            if (secondInput.value) {
              var parsedDate = fp.parseDate(secondInput.value);
              if (parsedDate) fp.selectedDates.push(parsedDate);
            }

            secondInput.setAttribute("data-fp-omit", "");

            fp._bind(secondInput, ["focus", "click"], function () {
              if (fp.selectedDates[1]) {
                fp.latestSelectedDateObj = fp.selectedDates[1];

                fp._setHoursFromDate(fp.selectedDates[1]);

                fp.jumpToDate(fp.selectedDates[1]);
              }

              _secondInputFocused = true;
              fp.isOpen = false;
              fp.open(undefined, config.position === "left" ? fp._input : secondInput);
            });

            fp._bind(fp._input, ["focus", "click"], function (e) {
              e.preventDefault();
              fp.isOpen = false;
              fp.open();
            });

            if (fp.config.allowInput) fp._bind(secondInput, "keydown", function (e) {
              if (e.key === "Enter") {
                fp.setDate([fp.selectedDates[0], secondInput.value], true, dateFormat);
                secondInput.click();
              }
            });
            if (!config.input) fp._input.parentNode && fp._input.parentNode.insertBefore(secondInput, fp._input.nextSibling);
          };

          var plugin = {
            onParseConfig: function onParseConfig() {
              fp.config.mode = "range";
              dateFormat = fp.config.altInput ? fp.config.altFormat : fp.config.dateFormat;
            },
            onReady: function onReady() {
              createSecondInput();
              fp.config.ignoredFocusElements.push(secondInput);

              if (fp.config.allowInput) {
                fp._input.removeAttribute("readonly");

                secondInput.removeAttribute("readonly");
              } else {
                secondInput.setAttribute("readonly", "readonly");
              }

              fp._bind(fp._input, "focus", function () {
                fp.latestSelectedDateObj = fp.selectedDates[0];

                fp._setHoursFromDate(fp.selectedDates[0]);

                _secondInputFocused = false;
                fp.jumpToDate(fp.selectedDates[0]);
              });

              if (fp.config.allowInput) fp._bind(fp._input, "keydown", function (e) {
                if (e.key === "Enter") fp.setDate([fp._input.value, fp.selectedDates[1]], true, dateFormat);
              });
              fp.setDate(fp.selectedDates, false);
              plugin.onValueUpdate(fp.selectedDates);
              fp.loadedPlugins.push("range");
            },
            onPreCalendarPosition: function onPreCalendarPosition() {
              if (_secondInputFocused) {
                fp._positionElement = secondInput;
                setTimeout(function () {
                  fp._positionElement = fp._input;
                }, 0);
              }
            },
            onChange: function onChange() {
              if (!fp.selectedDates.length) {
                setTimeout(function () {
                  if (fp.selectedDates.length) return;
                  secondInput.value = "";
                  _prevDates = [];
                }, 10);
              }

              if (_secondInputFocused) {
                setTimeout(function () {
                  secondInput.focus();
                }, 0);
              }
            },
            onDestroy: function onDestroy() {
              if (!config.input) secondInput.parentNode && secondInput.parentNode.removeChild(secondInput);
            },
            onValueUpdate: function onValueUpdate(selDates) {
              var _a, _b, _c;

              if (!secondInput) return;
              _prevDates = !_prevDates || selDates.length >= _prevDates.length ? selDates.slice() : _prevDates;

              if (_prevDates.length > selDates.length) {
                var newSelectedDate = selDates[0];
                var newDates = _secondInputFocused ? [_prevDates[0], newSelectedDate] : [newSelectedDate, _prevDates[1]];
                fp.setDate(newDates, false);
                _prevDates = newDates.slice();
              }

              _a = fp.selectedDates.map(function (d) {
                return fp.formatDate(d, dateFormat);
              }), _b = _a[0], fp._input.value = _b === void 0 ? "" : _b, _c = _a[1], secondInput.value = _c === void 0 ? "" : _c;
            }
          };
          return plugin;
        };
      }

      return rangePlugin;
    });
  });

  /**
   * @param {object} config Plugin configuration.
   * @returns {Plugin} An extension of Flatpickr `rangePlugin` that does the following:
   *   * Better ensures the calendar dropdown is always aligned to the `<input>` for the starting date.
   *     Workaround for: https://github.com/flatpickr/flatpickr/issues/1944
   *   * A logic to ensure `fp.setDate()` call won't end up with "startDate to endDate" set to the first `<input>`
   */

  var carbonFlatpickrRangePlugin = (function (config) {
    var factory = rangePlugin(Object.assign({
      position: 'left'
    }, config));
    return function (fp) {
      var origSetDate = fp.setDate;

      var init = function init() {
        fp.setDate = function setDate(dates, triggerChange, format) {
          origSetDate.call(this, dates, triggerChange, format); // If `triggerChange` is `true`, `onValueUpdate` Flatpickr event is fired
          // where Flatpickr's range plugin takes care of fixing the first `<input>`

          if (!triggerChange) {
            var inputFrom = fp._input;
            var inputTo = config.input;
            [inputFrom, inputTo].forEach(function (input, i) {
              if (input) {
                input.value = !dates[i] ? '' : fp.formatDate(new Date(dates[i]), fp.config.dateFormat);
              }
            });
          }
        };
      };

      var origRangePlugin = factory(fp);
      var origOnReady = origRangePlugin.onReady;
      return Object.assign(origRangePlugin, {
        onReady: [init, origOnReady],
        onPreCalendarPosition: function onPreCalendarPosition() {}
      });
    };
  });

  var prefix$Q = settings_1.prefix; // Weekdays shorthand for english locale

  l10n$1.en.weekdays.shorthand.forEach(function (day, index) {
    var currentDay = l10n$1.en.weekdays.shorthand;

    if (currentDay[index] === 'Thu' || currentDay[index] === 'Th') {
      currentDay[index] = 'Th';
    } else {
      currentDay[index] = currentDay[index].charAt(0);
    }
  });
  var forEach$1 = Array.prototype.forEach;
  /**
   * @param {number} monthNumber The month number.
   * @param {boolean} shorthand `true` to use shorthand month.
   * @param {Locale} locale The Flatpickr locale data.
   * @returns {string} The month string.
   */

  var monthToStr$1 = function monthToStr(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? 'shorthand' : 'longhand'][monthNumber];
  };
  /**
   * @param {object} config Plugin configuration.
   * @param {boolean} [config.shorthand] `true` to use shorthand month.
   * @param {string} config.selectorFlatpickrMonthYearContainer The CSS selector for the container of month/year selection UI.
   * @param {string} config.selectorFlatpickrYearContainer The CSS selector for the container of year selection UI.
   * @param {string} config.selectorFlatpickrCurrentMonth The CSS selector for the text-based month selection UI.
   * @param {string} config.classFlatpickrCurrentMonth The CSS class for the text-based month selection UI.
   * @returns {Plugin} A Flatpickr plugin to use text instead of `<select>` for month picker.
   */


  var carbonFlatpickrMonthSelectPlugin$1 = function carbonFlatpickrMonthSelectPlugin(config) {
    return function (fp) {
      var setupElements = function setupElements() {
        var _fp$monthElements;

        if (!fp.monthElements) {
          return;
        }

        fp.monthElements.forEach(function (elem) {
          if (!elem.parentNode) return;
          elem.parentNode.removeChild(elem);
        });

        (_fp$monthElements = fp.monthElements).splice.apply(_fp$monthElements, [0, fp.monthElements.length].concat(_toConsumableArray(fp.monthElements.map(function () {
          // eslint-disable-next-line no-underscore-dangle
          var monthElement = fp._createElement('span', config.classFlatpickrCurrentMonth);

          monthElement.textContent = monthToStr$1(fp.currentMonth, config.shorthand === true, fp.l10n);
          fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));
          return monthElement;
        }))));
      };

      var updateCurrentMonth = function updateCurrentMonth() {
        var monthStr = monthToStr$1(fp.currentMonth, config.shorthand === true, fp.l10n);
        fp.yearElements.forEach(function (elem) {
          var currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);
          Array.prototype.forEach.call(currentMonthContainer.querySelectorAll('.cur-month'), function (monthElement) {
            monthElement.textContent = monthStr;
          });
        });
      };

      var register = function register() {
        fp.loadedPlugins.push('carbonFlatpickrMonthSelectPlugin');
      };

      return {
        onMonthChange: updateCurrentMonth,
        onValueUpdate: updateCurrentMonth,
        onOpen: updateCurrentMonth,
        onReady: [setupElements, updateCurrentMonth, register]
      };
    };
  };

  var DatePicker$1 = /*#__PURE__*/function (_Component) {
    _inherits(DatePicker, _Component);

    var _super = _createSuper(DatePicker);

    function DatePicker() {
      var _this;

      _classCallCheck(this, DatePicker);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "onChange", function (e) {
        if (e.target.value === '' && _this.cal && _this.cal.selectedDates.length > 0) {
          _this.cal.clear();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "addKeyboardEvents", function (cal) {
        if (_this.inputField) {
          _this.inputField.addEventListener('keydown', function (e) {
            if (match(e, ArrowDown)) {
              (cal.selectedDateElem || cal.todayDateElem || cal.calendarContainer.querySelector('.flatpickr-day[tabindex]') || cal.calendarContainer).focus();
            }
          });

          _this.inputField.addEventListener('change', _this.onChange);
        }

        if (_this.toInputField) {
          _this.toInputField.addEventListener('blur', function (evt) {
            if (!_this.cal.calendarContainer.contains(evt.relatedTarget)) {
              _this.cal.close();
            }
          });

          _this.toInputField.addEventListener('keydown', function (e) {
            if (match(e, ArrowDown)) {
              (cal.selectedDateElem || cal.todayDateElem || cal.calendarContainer.querySelector('.flatpickr-day[tabindex]') || cal.calendarContainer).focus();
            }
          });

          _this.toInputField.addEventListener('change', _this.onChange);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "openCalendar", function () {
        if (_this.cal) {
          _this.cal.open();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "updateClassNames", function (calendar) {
        var calendarContainer = calendar.calendarContainer;
        var daysContainer = calendar.days;

        if (calendarContainer && daysContainer) {
          // calendarContainer and daysContainer are undefined if flatpickr detects a mobile device
          calendarContainer.classList.add("".concat(prefix$Q, "--date-picker__calendar"));
          calendarContainer.querySelector('.flatpickr-month').classList.add("".concat(prefix$Q, "--date-picker__month"));
          calendarContainer.querySelector('.flatpickr-weekdays').classList.add("".concat(prefix$Q, "--date-picker__weekdays"));
          calendarContainer.querySelector('.flatpickr-days').classList.add("".concat(prefix$Q, "--date-picker__days"));
          forEach$1.call(calendarContainer.querySelectorAll('.flatpickr-weekday'), function (item) {
            var currentItem = item;
            currentItem.innerHTML = currentItem.innerHTML.replace(/\s+/g, '');
            currentItem.classList.add("".concat(prefix$Q, "--date-picker__weekday"));
          });
          forEach$1.call(daysContainer.querySelectorAll('.flatpickr-day'), function (item) {
            item.classList.add("".concat(prefix$Q, "--date-picker__day"));

            if (item.classList.contains('today') && calendar.selectedDates.length > 0) {
              item.classList.add('no-border');
            } else if (item.classList.contains('today') && calendar.selectedDates.length === 0) {
              item.classList.remove('no-border');
            }
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "assignInputFieldRef", function (node) {
        _this.inputField = !node ? null : // Child is a regular DOM node, seen in tests
        node.nodeType === Node.ELEMENT_NODE ? node.querySelector(".".concat(prefix$Q, "--date-picker__input")) : // Child is a React component
        node.input && node.input.nodeType === Node.ELEMENT_NODE ? node.input : null;
      });

      _defineProperty(_assertThisInitialized(_this), "assignToInputFieldRef", function (node) {
        _this.toInputField = !node ? null : // Child is a regular DOM node, seen in tests
        node.nodeType === Node.ELEMENT_NODE ? node.querySelector(".".concat(prefix$Q, "--date-picker__input")) : // Child is a React component
        node.input && node.input.nodeType === Node.ELEMENT_NODE ? node.input : null;
      });

      _defineProperty(_assertThisInitialized(_this), "isLabelTextEmpty", function (children) {
        return children.every(function (child) {
          return !child.props.labelText;
        });
      });

      return _this;
    }

    _createClass(DatePicker, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        var _this$props = this.props,
            appendTo = _this$props.appendTo,
            datePickerType = _this$props.datePickerType,
            dateFormat = _this$props.dateFormat,
            locale = _this$props.locale,
            minDate = _this$props.minDate,
            maxDate = _this$props.maxDate,
            value = _this$props.value,
            onClose = _this$props.onClose;

        if (datePickerType === 'single' || datePickerType === 'range') {
          var onHook = function onHook(electedDates, dateStr, instance) {
            _this2.updateClassNames(instance);
          }; // inputField ref might not be set in enzyme tests


          if (this.inputField) {
            this.cal = new flatpickr(this.inputField, {
              disableMobile: true,
              defaultDate: value,
              mode: datePickerType,
              allowInput: true,
              dateFormat: dateFormat,
              locale: l10n$1[locale],
              minDate: minDate,
              maxDate: maxDate,
              plugins: [datePickerType === 'range' ? new carbonFlatpickrRangePlugin({
                input: this.toInputField
              }) : function () {}, appendTo ? carbonFlatpickrAppendToPlugin({
                appendTo: appendTo
              }) : function () {}, carbonFlatpickrMonthSelectPlugin$1({
                selectorFlatpickrMonthYearContainer: '.flatpickr-current-month',
                selectorFlatpickrYearContainer: '.numInputWrapper',
                selectorFlatpickrCurrentMonth: '.cur-month',
                classFlatpickrCurrentMonth: 'cur-month'
              }), carbonFlatpickrFixEventsPlugin({
                inputFrom: this.inputField,
                inputTo: this.toInputField
              })],
              clickOpens: true,
              nextArrow: this.rightArrowHTML(),
              prevArrow: this.leftArrowHTML(),
              onChange: function onChange() {
                var onChange = _this2.props.onChange;

                if (onChange) {
                  onChange.apply(void 0, arguments);
                }
              },
              onClose: onClose,
              onReady: onHook,
              onMonthChange: onHook,
              onYearChange: onHook,
              onOpen: onHook,
              onValueUpdate: onHook
            });
            this.addKeyboardEvents(this.cal);
          }
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(_ref) {
        var prevDateFormat = _ref.dateFormat,
            prevMinDate = _ref.minDate,
            prevMaxDate = _ref.maxDate,
            prevValue = _ref.value;
        var _this$props2 = this.props,
            dateFormat = _this$props2.dateFormat,
            minDate = _this$props2.minDate,
            maxDate = _this$props2.maxDate,
            value = _this$props2.value;

        if (this.cal) {
          if (prevDateFormat !== dateFormat) {
            this.cal.set({
              dateFormat: dateFormat
            });
          }

          if (prevMinDate !== minDate) {
            this.cal.set('minDate', minDate);
          }

          if (prevMaxDate !== maxDate) {
            this.cal.set('maxDate', maxDate);
          }
        } // Coordinate when the given `value` prop changes. When this happens, we
        // should update the calendar to the new value.


        if (prevValue !== value) {
          if (this.cal) {
            this.cal.setDate(this.props.value);
            this.updateClassNames(this.cal);
          } else if (this.inputField) {
            this.inputField.value = this.props.value;
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.cal) {
          this.cal.destroy();
        }

        if (this.inputField) {
          this.inputField.removeEventListener('change', this.onChange);
        }

        if (this.toInputField) {
          this.toInputField.removeEventListener('change', this.onChange);
        }
      }
    }, {
      key: "rightArrowHTML",
      value: function rightArrowHTML() {
        return "\n      <svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\">\n        <polygon points=\"11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 \"/>\n        <rect width=\"16\" height=\"16\" style=\"fill:none\" />\n      </svg>";
      }
    }, {
      key: "leftArrowHTML",
      value: function leftArrowHTML() {
        return "\n      <svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\">\n        <polygon points=\"5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 \"/>\n        <rect width=\"16\" height=\"16\" style=\"fill:none\" />\n      </svg>";
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames,
            _this3 = this;

        var _this$props3 = this.props,
            appendTo = _this$props3.appendTo,
            children = _this$props3.children,
            className = _this$props3.className,
            short = _this$props3.short,
            light = _this$props3.light,
            datePickerType = _this$props3.datePickerType,
            minDate = _this$props3.minDate,
            maxDate = _this$props3.maxDate,
            dateFormat = _this$props3.dateFormat,
            onChange = _this$props3.onChange,
            locale = _this$props3.locale,
            value = _this$props3.value,
            other = _objectWithoutProperties(_this$props3, ["appendTo", "children", "className", "short", "light", "datePickerType", "minDate", "maxDate", "dateFormat", "onChange", "locale", "value"]);

        var datePickerClasses = classnames("".concat(prefix$Q, "--date-picker"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$Q, "--date-picker--short"), short), _defineProperty(_classNames, "".concat(prefix$Q, "--date-picker--light"), light), _defineProperty(_classNames, "".concat(prefix$Q, "--date-picker--simple"), datePickerType === 'simple'), _defineProperty(_classNames, "".concat(prefix$Q, "--date-picker--single"), datePickerType === 'single'), _defineProperty(_classNames, "".concat(prefix$Q, "--date-picker--range"), datePickerType === 'range'), _defineProperty(_classNames, "".concat(prefix$Q, "--date-picker--nolabel"), datePickerType === 'range' && this.isLabelTextEmpty(children)), _classNames));
        var childArray = React__default.Children.toArray(children);
        var childrenWithProps = childArray.map(function (child, index) {
          if (index === 0 && child.type === /*#__PURE__*/React__default.createElement(DatePickerInput, child.props).type) {
            return /*#__PURE__*/React__default.cloneElement(child, {
              datePickerType: datePickerType,
              ref: _this3.assignInputFieldRef,
              openCalendar: _this3.openCalendar
            });
          }

          if (index === 1 && child.type === /*#__PURE__*/React__default.createElement(DatePickerInput, child.props).type) {
            return /*#__PURE__*/React__default.cloneElement(child, {
              datePickerType: datePickerType,
              ref: _this3.assignToInputFieldRef,
              openCalendar: _this3.openCalendar
            });
          }

          if (index === 0) {
            return /*#__PURE__*/React__default.cloneElement(child, {
              ref: _this3.assignInputFieldRef
            });
          }

          if (index === 1) {
            return /*#__PURE__*/React__default.cloneElement(child, {
              ref: _this3.assignToInputFieldRef
            });
          }
        });
        return /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$Q, "--form-item")
        }, /*#__PURE__*/React__default.createElement("div", _extends({
          className: datePickerClasses
        }, other), childrenWithProps));
      }
    }]);

    return DatePicker;
  }(React.Component);

  _defineProperty(DatePicker$1, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes.node,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * `true` to use the short version.
     */
    short: PropTypes.bool,

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool,

    /**
     * The type of the date picker:
     *
     * * `simple` - Without calendar dropdown.
     * * `single` - With calendar dropdown and single date.
     * * `range` - With calendar dropdown and a date range.
     */
    datePickerType: PropTypes.oneOf(['simple', 'single', 'range']),

    /**
     * The date format.
     */
    dateFormat: PropTypes.string,

    /**
     *  The language locale used to format the days of the week, months, and numbers.
     *
     * * `ar` - Arabic
     * * `at` - Austria
     * * `be` - Belarusian
     * * `bg` - Bulgarian
     * * `bn` - Bangla
     * * `cat` - Catalan
     * * `cs` - Czech
     * * `cy` - Welsh
     * * `da` - Danish
     * * `de` - German
     * * `en` - English
     * * `eo` - Esperanto
     * * `es` - Spanish
     * * `et` - Estonian
     * * `fa` - Persian
     * * `fi` - Finnish
     * * `fr` - French
     * * `gr` - Greek
     * * `he` - Hebrew
     * * `hi` - Hindi
     * * `hr` - Croatian
     * * `hu` - Hungarian
     * * `id` - Indonesian
     * * `it` - Italian
     * * `ja` - Japanese
     * * `ko` - Korean
     * * `lt` - Lithuanian
     * * `lv` - Latvian
     * * `mk` - Macedonian
     * * `mn` - Mongolian
     * * `ms` - Malaysian
     * * `my` - Burmese
     * * `nl` - Dutch
     * * `no` - Norwegian
     * * `pa` - Punjabi
     * * `pl` - Polish
     * * `pt` - Portuguese
     * * `ro` - Romanian
     * * `si` - Sinhala
     * * `sk` - Slovak
     * * `sl` - Slovenian
     * * `sq` - Albanian
     * * `sr` - Serbian
     * * `sv` - Swedish
     * * `th` - Thai
     * * `tr` - Turkish
     * * `uk` - Ukrainian
     * * `vn` - Vietnamese
     * * `zh` - Mandarin
     */
    locale: PropTypes.oneOf(['ar', 'at', 'be', 'bg', 'bn', 'cat', 'cs', 'cy', 'da', 'de', 'en', 'en', 'eo', 'es', 'et', 'fa', 'fi', 'fr', 'gr', 'he', 'hi', 'hr', 'hu', 'id', 'it', 'ja', 'ko', 'lt', 'lv', 'mk', 'mn', 'ms', 'my', 'nl', 'no', 'pa', 'pl', 'pt', 'ro', 'ru', 'si', 'sk', 'sl', 'sq', 'sr', 'sv', 'th', 'tr', 'uk', 'vn', 'zh']),

    /**
     * The value of the date value provided to flatpickr, could
     * be a date, a date number, a date string, an array of dates.
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.object])), PropTypes.object, PropTypes.number]),

    /**
     * The DOM element the Flatpicker should be inserted into. `<body>` by default.
     */
    appendTo: PropTypes.object,

    /**
     * The `change` event handler.
     */
    onChange: PropTypes.func,

    /**
     * The `close` event handler.
     */
    onClose: PropTypes.func,

    /**
     * The minimum date that a user can start picking from.
     */
    minDate: PropTypes.string,

    /**
     * The maximum date that a user can pick to.
     */
    maxDate: PropTypes.string
  });

  _defineProperty(DatePicker$1, "defaultProps", {
    short: false,
    light: false,
    dateFormat: 'm/d/Y',
    locale: 'en'
  });

  var prefix$R = settings_1.prefix;

  var DropdownSkeleton = function DropdownSkeleton(_ref) {
    var _cx;

    var inline = _ref.inline,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["inline", "className"]);

    var wrapperClasses = classnames(className, (_cx = {}, _defineProperty(_cx, "".concat(prefix$R, "--skeleton"), true), _defineProperty(_cx, "".concat(prefix$R, "--dropdown-v2"), true), _defineProperty(_cx, "".concat(prefix$R, "--list-box"), true), _defineProperty(_cx, "".concat(prefix$R, "--form-item"), true), _defineProperty(_cx, "".concat(prefix$R, "--list-box--inline"), inline), _cx));
    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: wrapperClasses
    }, rest), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$R, "--list-box__field")
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$R, "--list-box__label")
    })));
  };

  DropdownSkeleton.propTypes = {
    /**
     * Specify whether you want the inline version of this control
     */
    inline: PropTypes.bool,

    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };
  DropdownSkeleton.defaultProps = {
    inline: false
  };

  var prefix$S = settings_1.prefix;

  var defaultItemToString$1 = function defaultItemToString(item) {
    if (typeof item === 'string') {
      return item;
    }

    return item ? item.label : '';
  };

  var Dropdown$1 = /*#__PURE__*/React__default.forwardRef(function Dropdown(_ref, ref) {
    var _cx, _cx4;

    var containerClassName = _ref.className,
        disabled = _ref.disabled,
        direction = _ref.direction,
        items = _ref.items,
        label = _ref.label,
        ariaLabel = _ref.ariaLabel,
        itemToString = _ref.itemToString,
        itemToElement = _ref.itemToElement,
        type = _ref.type,
        size = _ref.size,
        onChange = _ref.onChange,
        id = _ref.id,
        titleText = _ref.titleText,
        helperText = _ref.helperText,
        translateWithId = _ref.translateWithId,
        light = _ref.light,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        initialSelectedItem = _ref.initialSelectedItem,
        controlledSelectedItem = _ref.selectedItem,
        downshiftProps = _ref.downshiftProps,
        other = _objectWithoutProperties(_ref, ["className", "disabled", "direction", "items", "label", "ariaLabel", "itemToString", "itemToElement", "type", "size", "onChange", "id", "titleText", "helperText", "translateWithId", "light", "invalid", "invalidText", "initialSelectedItem", "selectedItem", "downshiftProps"]);

    var selectProps = mapDownshiftProps(_objectSpread2(_objectSpread2({}, downshiftProps), {}, {
      items: items,
      itemToString: itemToString,
      initialSelectedItem: initialSelectedItem,
      onSelectedItemChange: onSelectedItemChange
    })); // only set selectedItem if the prop is defined. Setting if it is undefined
    // will overwrite default selected items from useSelect

    if (controlledSelectedItem !== undefined) {
      selectProps.selectedItem = controlledSelectedItem;
    }

    var _useSelect = useSelect(selectProps),
        isOpen = _useSelect.isOpen,
        getToggleButtonProps = _useSelect.getToggleButtonProps,
        getLabelProps = _useSelect.getLabelProps,
        getMenuProps = _useSelect.getMenuProps,
        getItemProps = _useSelect.getItemProps,
        highlightedIndex = _useSelect.highlightedIndex,
        selectedItem = _useSelect.selectedItem;

    var inline = type === 'inline';
    var className = classnames("".concat(prefix$S, "--dropdown"), containerClassName, (_cx = {}, _defineProperty(_cx, "".concat(prefix$S, "--dropdown--invalid"), invalid), _defineProperty(_cx, "".concat(prefix$S, "--dropdown--open"), isOpen), _defineProperty(_cx, "".concat(prefix$S, "--dropdown--inline"), inline), _defineProperty(_cx, "".concat(prefix$S, "--dropdown--disabled"), disabled), _defineProperty(_cx, "".concat(prefix$S, "--dropdown--light"), light), _defineProperty(_cx, "".concat(prefix$S, "--dropdown--").concat(size), size), _defineProperty(_cx, "".concat(prefix$S, "--list-box--up"), direction === 'top'), _cx));
    var titleClasses = classnames("".concat(prefix$S, "--label"), _defineProperty({}, "".concat(prefix$S, "--label--disabled"), disabled));
    var helperClasses = classnames("".concat(prefix$S, "--form__helper-text"), _defineProperty({}, "".concat(prefix$S, "--form__helper-text--disabled"), disabled));
    var wrapperClasses = classnames("".concat(prefix$S, "--dropdown__wrapper"), "".concat(prefix$S, "--list-box__wrapper"), (_cx4 = {}, _defineProperty(_cx4, "".concat(prefix$S, "--dropdown__wrapper--inline"), inline), _defineProperty(_cx4, "".concat(prefix$S, "--list-box__wrapper--inline"), inline), _defineProperty(_cx4, "".concat(prefix$S, "--dropdown__wrapper--inline--invalid"), inline && invalid), _defineProperty(_cx4, "".concat(prefix$S, "--list-box__wrapper--inline--invalid"), inline && invalid), _cx4)); // needs to be Capitalized for react to render it correctly

    var ItemToElement = itemToElement;
    var helper = helperText ? /*#__PURE__*/React__default.createElement("div", {
      className: helperClasses
    }, helperText) : null;

    function onSelectedItemChange(_ref2) {
      var selectedItem = _ref2.selectedItem;

      if (onChange) {
        onChange({
          selectedItem: selectedItem
        });
      }
    }

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: wrapperClasses
    }, other), titleText && /*#__PURE__*/React__default.createElement("label", _extends({
      className: titleClasses
    }, getLabelProps()), titleText), /*#__PURE__*/React__default.createElement(ListBox, {
      "aria-label": ariaLabel,
      size: size,
      className: className,
      invalid: invalid,
      invalidText: invalidText,
      light: light,
      isOpen: isOpen,
      id: id
    }, invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
      className: "".concat(prefix$S, "--list-box__invalid-icon")
    }), /*#__PURE__*/React__default.createElement("button", _extends({
      ref: ref,
      className: "".concat(prefix$S, "--list-box__field"),
      disabled: disabled,
      "aria-disabled": disabled
    }, getToggleButtonProps()), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$S, "--list-box__label")
    }, selectedItem ? itemToString(selectedItem) : label), /*#__PURE__*/React__default.createElement(ListBox.MenuIcon, {
      isOpen: isOpen,
      translateWithId: translateWithId
    })), /*#__PURE__*/React__default.createElement(ListBox.Menu, getMenuProps(), isOpen && items.map(function (item, index) {
      var itemProps = getItemProps({
        item: item,
        index: index
      });
      return /*#__PURE__*/React__default.createElement(ListBox.MenuItem, _extends({
        key: itemProps.id,
        isActive: selectedItem === item,
        isHighlighted: highlightedIndex === index || selectedItem === item,
        title: itemToElement ? item.text : itemToString(item)
      }, itemProps), itemToElement ? /*#__PURE__*/React__default.createElement(ItemToElement, _extends({
        key: itemProps.id
      }, item)) : itemToString(item), selectedItem === item && /*#__PURE__*/React__default.createElement(Checkmark16, {
        className: "".concat(prefix$S, "--list-box__menu-item__selected-icon")
      }));
    }))), !inline && !invalid && helper);
  });
  Dropdown$1.displayName = 'Dropdown';
  Dropdown$1.propTypes = {
    /**
     * Disable the control
     */
    disabled: PropTypes.bool,

    /**
     * Provide a custom className to be applied on the bx--dropdown node
     */
    className: PropTypes.string,

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes.array.isRequired,

    /**
     * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
     * from their collection that are pre-selected
     */
    initialSelectedItem: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),

    /**
     * Specify a custom `id`
     */
    id: PropTypes.string.isRequired,

    /**
     * Specify whether you want the inline version of this control
     */
    inline: PropTypes.bool,

    /**
     * Specify if the currently selected value is invalid.
     */
    invalid: PropTypes.bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes.string,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list.
     */
    itemToString: PropTypes.func,

    /**
     * Function to render items as custom components instead of strings.
     * Defaults to null and is overriden by a getter
     */
    itemToElement: PropTypes.func,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component what kind of internal state changes are occuring.
     */
    onChange: PropTypes.func,

    /**
     * Generic `label` that will be used as the textual representation of what
     * this field is for
     */
    label: PropTypes.node.isRequired,

    /**
     * Callback function for translating ListBoxMenuIcon SVG title
     */
    translateWithId: PropTypes.func,

    /**
     * 'aria-label' of the ListBox component.
     */
    ariaLabel: PropTypes.string,

    /**
     * The dropdown type, `default` or `inline`
     */
    type: ListBoxType,

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `lg` or `xl` as an option.
     */
    size: ListBoxSize,

    /**
     * In the case you want to control the dropdown selection entirely.
     */
    selectedItem: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool,

    /**
     * Provide the title text that will be read by a screen reader when
     * visiting this control
     */
    titleText: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),

    /**
     * Provide helper text that is used alongside the control label for
     * additional help
     */
    helperText: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),

    /**
     * Specify the direction of the dropdown. Can be either top or bottom.
     */
    direction: PropTypes.oneOf(['top', 'bottom']),

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes.object
  };
  Dropdown$1.defaultProps = {
    disabled: false,
    type: 'default',
    itemToString: defaultItemToString$1,
    itemToElement: null,
    light: false,
    titleText: '',
    helperText: '',
    direction: 'bottom'
  };

  var ErrorBoundaryContext = React.createContext({
    log: function log(error, info) {
      console.log(info.componentStack);
    }
  });

  /**
   * React introduced additional lifecycle methods in v16 for capturing errors
   * that occur in a specific sub-tree of components. This component helps to
   * consolidate some of the duplication that occurs when using these lifecycle
   * methods across a codebase. In addition, it allows you to specify the fallback
   * UI to display when an error occurs in the sub-tree through the `fallback`
   * prop.
   *
   * This component roughly follows the React.js docs example code for these
   * methods. In addition, it takes advantage of an `ErrorBoundaryContext` so that
   * consumers can specify their own logic for logging errors. For example,
   * reporting an error in the UI to an external service for every `ErrorBoundary`
   * used.
   *
   * Reference:
   * https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries
   */

  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
    _inherits(ErrorBoundary, _React$Component);

    var _super = _createSuper(ErrorBoundary);

    function ErrorBoundary() {
      var _this;

      _classCallCheck(this, ErrorBoundary);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {
        hasError: false
      });

      return _this;
    }

    _createClass(ErrorBoundary, [{
      key: "componentDidCatch",
      value: function componentDidCatch(error, info) {
        this.context.log(error, info);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (prevProps.children !== this.props.children) {
          this.setState({
            hasError: false
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        if (this.state.hasError) {
          return this.props.fallback;
        }

        return this.props.children;
      }
    }], [{
      key: "getDerivedStateFromError",
      value: function getDerivedStateFromError() {
        return {
          hasError: true
        };
      }
    }]);

    return ErrorBoundary;
  }(React__default.Component);

  _defineProperty(ErrorBoundary, "propTypes", {
    children: PropTypes.node,
    fallback: PropTypes.node
  });

  _defineProperty(ErrorBoundary, "contextType", ErrorBoundaryContext);

  var prefix$T = settings_1.prefix;
  var getInstanceId$3 = setupGetInstanceId();

  function Loading$1(_ref) {
    var _cx, _cx2;

    var id = _ref.id,
        active = _ref.active,
        customClassName = _ref.className,
        withOverlay = _ref.withOverlay,
        small = _ref.small,
        description = _ref.description,
        rest = _objectWithoutProperties(_ref, ["id", "active", "className", "withOverlay", "small", "description"]);

    var _useRef = React.useRef(getInstanceId$3()),
        instanceId = _useRef.current;

    var loadingClassName = classnames(customClassName, (_cx = {}, _defineProperty(_cx, "".concat(prefix$T, "--loading"), true), _defineProperty(_cx, "".concat(prefix$T, "--loading--small"), small), _defineProperty(_cx, "".concat(prefix$T, "--loading--stop"), !active), _cx));
    var overlayClassName = classnames((_cx2 = {}, _defineProperty(_cx2, "".concat(prefix$T, "--loading-overlay"), true), _defineProperty(_cx2, "".concat(prefix$T, "--loading-overlay--stop"), !active), _cx2));
    var loadingId = id || "loading-id-".concat(instanceId);
    var spinnerRadius = small ? '26.8125' : '37.5';
    var loading = /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
      "aria-atomic": "true",
      "aria-labelledby": loadingId,
      "aria-live": active ? 'assertive' : 'off',
      className: loadingClassName
    }), /*#__PURE__*/React__default.createElement("label", {
      id: loadingId,
      className: "".concat(prefix$T, "--visually-hidden")
    }, description), /*#__PURE__*/React__default.createElement("svg", {
      className: "".concat(prefix$T, "--loading__svg"),
      viewBox: "-75 -75 150 150"
    }, /*#__PURE__*/React__default.createElement("title", null, description), small ? /*#__PURE__*/React__default.createElement("circle", {
      className: "".concat(prefix$T, "--loading__background"),
      cx: "0",
      cy: "0",
      r: spinnerRadius
    }) : null, /*#__PURE__*/React__default.createElement("circle", {
      className: "".concat(prefix$T, "--loading__stroke"),
      cx: "0",
      cy: "0",
      r: spinnerRadius
    })));
    return withOverlay ? /*#__PURE__*/React__default.createElement("div", {
      className: overlayClassName
    }, loading) : loading;
  }

  Loading$1.propTypes = {
    /**
     * Provide an `id` to uniquely identify the label
     */
    id: PropTypes.string,

    /**
     * Specify whether you want the loading indicator to be spinning or not
     */
    active: PropTypes.bool,

    /**
     * Provide an optional className to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Specify whether you want the loader to be applied with an overlay
     */
    withOverlay: PropTypes.bool,

    /**
     * Specify whether you would like the small variant of <Loading>
     */
    small: PropTypes.bool,

    /**
     * Specify an description that would be used to best describe the loading state
     */
    description: PropTypes.string
  };
  Loading$1.defaultProps = {
    active: true,
    withOverlay: true,
    small: false,
    description: 'Active loading indicator'
  };

  var prefix$U = settings_1.prefix;

  function Filename(_ref) {
    var iconDescription = _ref.iconDescription,
        status = _ref.status,
        invalid = _ref.invalid,
        rest = _objectWithoutProperties(_ref, ["iconDescription", "status", "invalid"]);

    switch (status) {
      case 'uploading':
        return /*#__PURE__*/React__default.createElement(Loading$1, {
          description: iconDescription,
          small: true,
          withOverlay: false
        });

      case 'edit':
        return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
          className: "".concat(prefix$U, "--file-invalid")
        }), /*#__PURE__*/React__default.createElement("button", _extends({
          "aria-label": iconDescription,
          className: "".concat(prefix$U, "--file-close"),
          type: "button"
        }, rest), /*#__PURE__*/React__default.createElement(Close16, null)));

      case 'complete':
        return /*#__PURE__*/React__default.createElement(CheckmarkFilled16, _extends({
          "aria-label": iconDescription,
          className: "".concat(prefix$U, "--file-complete")
        }, rest), iconDescription && /*#__PURE__*/React__default.createElement("title", null, iconDescription));

      default:
        return null;
    }
  }

  Filename.propTypes = {
    /**
     * Provide a description of the SVG icon to denote file upload status
     */
    iconDescription: PropTypes.string,

    /**
     * Status of the file upload
     */
    status: PropTypes.oneOf(['edit', 'complete', 'uploading']),

    /**
     * Provide a custom tabIndex value for the <Filename>
     */
    tabIndex: PropTypes.string,

    /**
     * Specify if the file is invalid
     */
    invalid: PropTypes.bool
  };
  Filename.defaultProps = {
    iconDescription: 'Uploading file',
    status: 'uploading',
    tabIndex: '0'
  };

  var prefix$V = settings_1.prefix;

  function noop$1() {}

  function FileUploaderButton(_ref) {
    var _cx;

    var accept = _ref.accept,
        _ref$buttonKind = _ref.buttonKind,
        buttonKind = _ref$buttonKind === void 0 ? 'primary' : _ref$buttonKind,
        className = _ref.className,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        _ref$disableLabelChan = _ref.disableLabelChanges,
        disableLabelChanges = _ref$disableLabelChan === void 0 ? false : _ref$disableLabelChan,
        id = _ref.id,
        _ref$labelText = _ref.labelText,
        ownerLabelText = _ref$labelText === void 0 ? 'Add file' : _ref$labelText,
        _ref$multiple = _ref.multiple,
        multiple = _ref$multiple === void 0 ? false : _ref$multiple,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? noop$1 : _ref$onChange,
        _ref$role = _ref.role,
        role = _ref$role === void 0 ? 'button' : _ref$role,
        name = _ref.name,
        size = _ref.size,
        _ref$tabIndex = _ref.tabIndex,
        tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
        other = _objectWithoutProperties(_ref, ["accept", "buttonKind", "className", "disabled", "disableLabelChanges", "id", "labelText", "multiple", "onChange", "role", "name", "size", "tabIndex"]);

    var _useState = React.useState(ownerLabelText),
        _useState2 = _slicedToArray(_useState, 2),
        labelText = _useState2[0],
        setLabelText = _useState2[1];

    var _useState3 = React.useState(ownerLabelText),
        _useState4 = _slicedToArray(_useState3, 2),
        prevOwnerLabelText = _useState4[0],
        setPrevOwnerLabelText = _useState4[1];

    var _useRef = React.useRef(id || uid()),
        inputId = _useRef.current;

    var inputNode = React.useRef(null);
    var classes = classnames("".concat(prefix$V, "--btn"), className, (_cx = {}, _defineProperty(_cx, "".concat(prefix$V, "--btn--").concat(buttonKind), buttonKind), _defineProperty(_cx, "".concat(prefix$V, "--btn--disabled"), disabled), _defineProperty(_cx, "".concat(prefix$V, "--btn--field"), size === 'field'), _defineProperty(_cx, "".concat(prefix$V, "--btn--sm"), size === 'small'), _cx)); // Adjust label text state based on changes to the labelText prop

    if (ownerLabelText !== prevOwnerLabelText) {
      setLabelText(ownerLabelText);
      setPrevOwnerLabelText(ownerLabelText);
    }

    function onClick(event) {
      event.target.value = null;
    }

    function onKeyDown(event) {
      if (matches(event, [Enter, Space])) {
        inputNode.current.click();
      }
    }

    function handleOnChange(event) {
      var files = event.target.files;
      var length = event.target.files.length;

      if (files && !disableLabelChanges) {
        if (length > 1) {
          setLabelText("".concat(length, " files"));
        } else if (length === 1) {
          setLabelText(files[0].name);
        }
      }

      onChange(event);
    }

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("label", _extends({
      tabIndex: disabled ? -1 : tabIndex || 0,
      "aria-disabled": disabled,
      className: classes,
      onKeyDown: onKeyDown,
      htmlFor: inputId
    }, other), /*#__PURE__*/React__default.createElement("span", {
      role: role
    }, labelText)), /*#__PURE__*/React__default.createElement("input", {
      className: "".concat(prefix$V, "--visually-hidden"),
      ref: inputNode,
      id: inputId,
      disabled: disabled,
      type: "file",
      tabIndex: "-1",
      multiple: multiple,
      accept: accept,
      name: name,
      onChange: handleOnChange,
      onClick: onClick
    }));
  }

  FileUploaderButton.propTypes = {
    /**
     * Provide a custom className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify whether you want to disable any updates to the FileUploaderButton
     * label
     */
    disableLabelChanges: PropTypes.bool,

    /**
     * Provide a unique id for the underlying <input> node
     */
    id: PropTypes.string,

    /**
     * Provide the label text to be read by screen readers when interacting with
     * this control
     */
    labelText: PropTypes.node,

    /**
     * Specify whether you want the component to list the files that have been
     * submitted to be uploaded
     */
    listFiles: PropTypes.bool,

    /**
     * Specify if the component should accept multiple files to upload
     */
    multiple: PropTypes.bool,

    /**
     * Provide a name for the underlying <input> node
     */
    name: PropTypes.string,

    /**
     * Provide an optional `onChange` hook that is called each time the <input>
     * value changes
     */
    onChange: PropTypes.func,

    /**
     * Provide an optional `onClick` hook that is called each time the button is
     * clicked
     */
    onClick: PropTypes.func,

    /**
     * Provide an accessibility role for the <FileUploaderButton>
     */
    role: PropTypes.string,

    /**
     * Provide a custom tabIndex value for the <FileUploaderButton>
     */
    tabIndex: PropTypes.number,

    /**
     * Specify the type of underlying button
     */
    buttonKind: PropTypes.oneOf(ButtonKinds),

    /**
     * Specify the types of files that this input should be able to receive
     */
    accept: PropTypes.arrayOf(PropTypes.string),

    /**
     * Specify whether file input is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Specify the size of the button, from a list of available sizes.
     * For `default` buttons, this prop can remain unspecified.
     */
    size: PropTypes.oneOf(['default', 'field', 'small'])
  };

  var prefix$W = settings_1.prefix;

  var FileUploader$1 = /*#__PURE__*/function (_React$Component) {
    _inherits(FileUploader, _React$Component);

    var _super = _createSuper(FileUploader);

    function FileUploader() {
      var _this;

      _classCallCheck(this, FileUploader);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {
        filenames: []
      });

      _defineProperty(_assertThisInitialized(_this), "nodes", []);

      _defineProperty(_assertThisInitialized(_this), "handleChange", function (evt) {
        evt.stopPropagation();
        var filenames = Array.prototype.map.call(evt.target.files, function (file) {
          return file.name;
        });

        _this.setState({
          filenames: _this.props.multiple ? _this.state.filenames.concat(filenames) : filenames
        });

        if (_this.props.onChange) {
          _this.props.onChange(evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleClick", function (evt, _ref) {
        var index = _ref.index,
            filenameStatus = _ref.filenameStatus;

        if (filenameStatus === 'edit') {
          evt.stopPropagation();

          var filteredArray = _this.state.filenames.filter(function (filename) {
            return filename !== _this.nodes[index].innerText.trim();
          });

          _this.setState({
            filenames: filteredArray
          });

          if (_this.props.onDelete) {
            _this.props.onDelete(evt);
          }

          _this.props.onClick(evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "clearFiles", function () {
        // A clearFiles function that resets filenames and can be referenced using a ref by the parent.
        _this.setState({
          filenames: []
        });
      });

      return _this;
    }

    _createClass(FileUploader, [{
      key: "render",
      value: function render() {
        var _classNames,
            _classNames2,
            _this2 = this;

        var _this$props = this.props,
            iconDescription = _this$props.iconDescription,
            buttonLabel = _this$props.buttonLabel,
            buttonKind = _this$props.buttonKind,
            filenameStatus = _this$props.filenameStatus,
            labelDescription = _this$props.labelDescription,
            labelTitle = _this$props.labelTitle,
            className = _this$props.className,
            multiple = _this$props.multiple,
            accept = _this$props.accept,
            name = _this$props.name,
            size = _this$props.size,
            onDelete = _this$props.onDelete,
            other = _objectWithoutProperties(_this$props, ["iconDescription", "buttonLabel", "buttonKind", "filenameStatus", "labelDescription", "labelTitle", "className", "multiple", "accept", "name", "size", "onDelete"]);

        var classes = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$W, "--form-item"), true), _defineProperty(_classNames, className, className), _classNames));
        var selectedFileClasses = classnames("".concat(prefix$W, "--file__selected-file"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$W, "--file__selected-file--field"), size === 'field'), _defineProperty(_classNames2, "".concat(prefix$W, "--file__selected-file--sm"), size === 'small'), _classNames2));
        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: classes
        }, other), /*#__PURE__*/React__default.createElement("strong", {
          className: "".concat(prefix$W, "--file--label")
        }, labelTitle), /*#__PURE__*/React__default.createElement("p", {
          className: "".concat(prefix$W, "--label-description")
        }, labelDescription), /*#__PURE__*/React__default.createElement(FileUploaderButton, {
          labelText: buttonLabel,
          multiple: multiple,
          buttonKind: buttonKind,
          onChange: this.handleChange,
          disableLabelChanges: true,
          accept: accept,
          name: name,
          size: size
        }), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$W, "--file-container")
        }, this.state.filenames.length === 0 ? null : this.state.filenames.map(function (name, index) {
          return /*#__PURE__*/React__default.createElement("span", _extends({
            key: index,
            className: selectedFileClasses,
            ref: function ref(node) {
              return _this2.nodes[index] = node;
            } // eslint-disable-line

          }, other), /*#__PURE__*/React__default.createElement("p", {
            className: "".concat(prefix$W, "--file-filename")
          }, name), /*#__PURE__*/React__default.createElement("span", {
            className: "".concat(prefix$W, "--file__state-container")
          }, /*#__PURE__*/React__default.createElement(Filename, {
            iconDescription: iconDescription,
            status: filenameStatus,
            onKeyDown: function onKeyDown(evt) {
              if (matches(evt, [Enter, Space])) {
                _this2.handleClick(evt, {
                  index: index,
                  filenameStatus: filenameStatus
                });
              }
            },
            onClick: function onClick(evt) {
              return _this2.handleClick(evt, {
                index: index,
                filenameStatus: filenameStatus
              });
            }
          })));
        })));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, state) {
        var filenameStatus = _ref2.filenameStatus;
        var prevFilenameStatus = state.prevFilenameStatus;
        return prevFilenameStatus === filenameStatus ? null : {
          filenameStatus: filenameStatus,
          prevFilenameStatus: filenameStatus
        };
      }
    }]);

    return FileUploader;
  }(React__default.Component);

  _defineProperty(FileUploader$1, "propTypes", {
    /**
     * Provide a description for the complete/close icon that can be read by screen readers
     */
    iconDescription: PropTypes.string,

    /**
     * Provide the label text to be read by screen readers when interacting with
     * the <FileUploaderButton>
     */
    buttonLabel: PropTypes.string,

    /**
     * Specify the type of the <FileUploaderButton>
     */
    buttonKind: PropTypes.oneOf(ButtonKinds),

    /**
     * Specify the status of the File Upload
     */
    filenameStatus: PropTypes.oneOf(['edit', 'complete', 'uploading']).isRequired,

    /**
     * Specify the description text of this <FileUploader>
     */
    labelDescription: PropTypes.string,

    /**
     * Specify the title text of this <FileUploader>
     */
    labelTitle: PropTypes.string,

    /**
     * Specify if the component should accept multiple files to upload
     */
    multiple: PropTypes.bool,

    /**
     * Provide a name for the underlying <input> node
     */
    name: PropTypes.string,

    /**
     * Provide an optional `onChange` hook that is called each time the input is
     * changed
     */
    onChange: PropTypes.func,

    /**
     * Provide an optional `onDelete` hook that is called when an uploaded item
     * is removed
     */
    onDelete: PropTypes.func,

    /**
     * Provide an optional `onClick` hook that is called each time the
     * FileUploader is clicked
     */
    onClick: PropTypes.func,

    /**
     * Provide a custom className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify the types of files that this input should be able to receive
     */
    accept: PropTypes.arrayOf(PropTypes.string),

    /**
     * Specify the size of the FileUploaderButton, from a list of available
     * sizes. For `default` buttons, this prop can remain unspecified.
     */
    size: PropTypes.oneOf(['default', 'field', 'small'])
  });

  _defineProperty(FileUploader$1, "defaultProps", {
    iconDescription: 'Provide icon description',
    filenameStatus: 'uploading',
    buttonLabel: '',
    buttonKind: 'primary',
    multiple: false,
    onClick: function onClick() {},
    accept: []
  });

  var prefix$X = settings_1.prefix;

  function FileUploaderSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$X, "--form-item"), className)
    }, rest), /*#__PURE__*/React__default.createElement(SkeletonText, {
      heading: true,
      width: "100px"
    }), /*#__PURE__*/React__default.createElement(SkeletonText, {
      width: "225px",
      className: "".concat(prefix$X, "--label-description")
    }), /*#__PURE__*/React__default.createElement(ButtonSkeleton, null));
  }

  FileUploaderSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$Y = settings_1.prefix;

  function FileUploaderDropContainer(_ref) {
    var _classNames2;

    var accept = _ref.accept,
        className = _ref.className,
        id = _ref.id,
        disabled = _ref.disabled,
        labelText = _ref.labelText,
        multiple = _ref.multiple,
        name = _ref.name,
        onAddFiles = _ref.onAddFiles,
        role = _ref.role,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties(_ref, ["accept", "className", "id", "disabled", "labelText", "multiple", "name", "onAddFiles", "role", "tabIndex"]);

    var inputRef = React.useRef(null);

    var _useRef = React.useRef(id || uid()),
        uid$1 = _useRef.current;

    var _useState = React.useState(false),
        _useState2 = _slicedToArray(_useState, 2),
        isActive = _useState2[0],
        setActive = _useState2[1];

    var labelClasses = classnames("".concat(prefix$Y, "--file-browse-btn"), _defineProperty({}, "".concat(prefix$Y, "--file-browse-btn--disabled"), disabled));
    var dropareaClasses = classnames("".concat(prefix$Y, "--file__drop-container"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$Y, "--file__drop-container--drag-over"), isActive), _defineProperty(_classNames2, className, className), _classNames2));
    /**
     * Filters the array of added files based on file type restrictions
     * @param {Event} event - Event object, used to get the list of files added
     */

    function validateFiles(event) {
      if (event.type === 'drop') {
        var transferredFiles = _toConsumableArray(event.dataTransfer.files);

        if (!accept.length) {
          return transferredFiles;
        }

        var acceptedTypes = new Set(accept);
        return transferredFiles.filter(function (_ref2) {
          var name = _ref2.name,
              _ref2$type = _ref2.type,
              mimeType = _ref2$type === void 0 ? '' : _ref2$type;
          var fileExtensionRegExp = new RegExp(/\.[0-9a-z]+$/, 'i');
          var hasFileExtension = fileExtensionRegExp.test(name);

          if (!hasFileExtension) {
            return false;
          }

          var _name$match = name.match(fileExtensionRegExp),
              _name$match2 = _slicedToArray(_name$match, 1),
              fileExtension = _name$match2[0];

          return acceptedTypes.has(mimeType) || acceptedTypes.has(fileExtension);
        });
      }

      return _toConsumableArray(event.target.files);
    }

    function handleChange(event) {
      var addedFiles = validateFiles(event);
      return onAddFiles(event, {
        addedFiles: addedFiles
      });
    }

    return /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$Y, "--file"),
      onDragOver: function onDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        if (disabled) {
          return;
        }

        setActive(true);
        evt.dataTransfer.dropEffect = 'copy';
      },
      onDragLeave: function onDragLeave(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        if (disabled) {
          return;
        }

        setActive(false);
        evt.dataTransfer.dropEffect = 'move';
      },
      onDrop: function onDrop(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        if (disabled) {
          return;
        }

        setActive(false);
        handleChange(evt);
      }
    }, /*#__PURE__*/React__default.createElement("label", _extends({
      className: labelClasses,
      htmlFor: uid$1,
      tabIndex: tabIndex || 0,
      onKeyDown: function onKeyDown(evt) {
        if (matches(evt, [Enter, Space])) {
          inputRef.current.click();
        }
      }
    }, rest), /*#__PURE__*/React__default.createElement("div", {
      className: dropareaClasses,
      role: role || 'button'
    }, labelText, /*#__PURE__*/React__default.createElement("input", {
      type: "file",
      id: uid$1,
      className: "".concat(prefix$Y, "--file-input"),
      ref: inputRef,
      tabIndex: "-1",
      disabled: disabled,
      accept: accept,
      name: name,
      multiple: multiple,
      onChange: handleChange,
      onClick: function onClick(evt) {
        evt.target.value = null;
      }
    }))));
  }

  FileUploaderDropContainer.propTypes = {
    /**
     * Provide a custom className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Provide a unique id for the underlying <input> node
     */
    id: PropTypes.string,

    /**
     * Provide the label text to be read by screen readers when interacting with
     * this control
     */
    labelText: PropTypes.string.isRequired,

    /**
     * Specify if the component should accept multiple files to upload
     */
    multiple: PropTypes.bool,

    /**
     * Provide a name for the underlying <input> node
     */
    name: PropTypes.string,

    /**
     * Provide an accessibility role for the <FileUploaderButton>
     */
    role: PropTypes.string,

    /**
     * Provide a custom tabIndex value for the <FileUploaderButton>
     */
    tabIndex: PropTypes.number,

    /**
     * Specify whether file input is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Specify the types of files that this input should be able to receive
     */
    accept: PropTypes.arrayOf(PropTypes.string),

    /**
     * Event handler that is called after files are added to the uploader
     * The event handler signature looks like `onAddFiles(evt, { addedFiles })`
     */
    onAddFiles: PropTypes.func,

    /**
     * Specify the size of the uploaded items, from a list of available
     * sizes. For `default` size, this prop can remain unspecified.
     */
    size: PropTypes.oneOf(['default', 'field', 'small'])
  };
  FileUploaderDropContainer.defaultProps = {
    tabIndex: 0,
    labelText: 'Add file',
    multiple: false,
    onAddFiles: function onAddFiles() {},
    accept: []
  };

  var prefix$Z = settings_1.prefix;

  function FileUploaderItem(_ref) {
    var _cx;

    var uuid = _ref.uuid,
        name = _ref.name,
        status = _ref.status,
        iconDescription = _ref.iconDescription,
        onDelete = _ref.onDelete,
        invalid = _ref.invalid,
        errorSubject = _ref.errorSubject,
        errorBody = _ref.errorBody,
        size = _ref.size,
        other = _objectWithoutProperties(_ref, ["uuid", "name", "status", "iconDescription", "onDelete", "invalid", "errorSubject", "errorBody", "size"]);

    var _useRef = React.useRef(uuid || uid()),
        id = _useRef.current;

    var classes = classnames("".concat(prefix$Z, "--file__selected-file"), (_cx = {}, _defineProperty(_cx, "".concat(prefix$Z, "--file__selected-file--invalid"), invalid), _defineProperty(_cx, "".concat(prefix$Z, "--file__selected-file--field"), size === 'field'), _defineProperty(_cx, "".concat(prefix$Z, "--file__selected-file--sm"), size === 'small'), _cx));
    return /*#__PURE__*/React__default.createElement("span", _extends({
      className: classes
    }, other), /*#__PURE__*/React__default.createElement("p", {
      className: "".concat(prefix$Z, "--file-filename")
    }, name), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$Z, "--file__state-container")
    }, /*#__PURE__*/React__default.createElement(Filename, {
      iconDescription: iconDescription,
      status: status,
      invalid: invalid,
      onKeyDown: function onKeyDown(evt) {
        if (matches(evt, [Enter, Space])) {
          if (status === 'edit') {
            onDelete(evt, {
              uuid: id
            });
          }
        }
      },
      onClick: function onClick(evt) {
        if (status === 'edit') {
          onDelete(evt, {
            uuid: id
          });
        }
      }
    })), invalid && errorSubject && /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$Z, "--form-requirement")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$Z, "--form-requirement__title")
    }, errorSubject), errorBody && /*#__PURE__*/React__default.createElement("p", {
      className: "".concat(prefix$Z, "--form-requirement__supplement")
    }, errorBody)));
  }

  FileUploaderItem.propTypes = {
    /**
     * Unique identifier for the file object
     */
    uuid: PropTypes.string,

    /**
     * Name of the uploaded file
     */
    name: PropTypes.string,

    /**
     * Status of the file upload
     */
    status: PropTypes.oneOf(['uploading', 'edit', 'complete']),

    /**
     * Specify the size of the uploaded items, from a list of available
     * sizes. For `default` size, this prop can remain unspecified.
     */
    size: PropTypes.oneOf(['default', 'field', 'small']),

    /**
     * Description of status icon (displayed in native tooltip)
     */
    iconDescription: PropTypes.string,

    /**
     * Specify if the currently uploaded file is invalid
     */
    invalid: PropTypes.bool,

    /**
     * Event handler that is called after removing a file from the file uploader
     * The event handler signature looks like `onDelete(evt, { uuid })`
     */
    onDelete: PropTypes.func,

    /**
     * Error message subject for an invalid file upload
     */
    errorSubject: PropTypes.string,

    /**
     * Error message body for an invalid file upload
     */
    errorBody: PropTypes.string
  };
  FileUploaderItem.defaultProps = {
    status: 'uploading',
    onDelete: function onDelete() {}
  };

  var prefix$_ = settings_1.prefix;

  var Form = function Form(_ref) {
    var className = _ref.className,
        children = _ref.children,
        other = _objectWithoutProperties(_ref, ["className", "children"]);

    var classNames = classnames("".concat(prefix$_, "--form"), className);
    return /*#__PURE__*/React__default.createElement("form", _extends({
      className: classNames
    }, other), ' ', children, ' ');
  };

  Form.propTypes = {
    /**
     * Provide children to be rendered inside of the <form> element
     */
    children: PropTypes.node,

    /**
     * Provide a custom className to be applied on the containing <form> node
     */
    className: PropTypes.string
  };

  var FormContext = React.createContext({
    isFluid: false
  });

  var prefix$$ = settings_1.prefix;

  function FluidForm(_ref) {
    var className = _ref.className,
        children = _ref.children,
        other = _objectWithoutProperties(_ref, ["className", "children"]);

    var classNames = classnames("".concat(prefix$$, "--form--fluid"), className);
    return /*#__PURE__*/React__default.createElement(FormContext.Provider, {
      value: {
        isFluid: true
      }
    }, /*#__PURE__*/React__default.createElement(Form, _extends({
      className: classNames
    }, other), children));
  }

  FluidForm.propTypes = {
    /**
     * Provide children to be rendered inside of the <form> element
     */
    children: PropTypes.node,

    /**
     * Provide a custom className to be applied on the containing <form> node
     */
    className: PropTypes.string
  };

  var prefix$10 = settings_1.prefix;

  var FormGroup = function FormGroup(_ref) {
    var legendText = _ref.legendText,
        invalid = _ref.invalid,
        children = _ref.children,
        className = _ref.className,
        message = _ref.message,
        messageText = _ref.messageText,
        other = _objectWithoutProperties(_ref, ["legendText", "invalid", "children", "className", "message", "messageText"]);

    var classNamesLegend = classnames("".concat(prefix$10, "--label"), className);
    var classNamesFieldset = classnames("".concat(prefix$10, "--fieldset"), className);
    return /*#__PURE__*/React__default.createElement("fieldset", _extends({}, invalid && {
      'data-invalid': ''
    }, {
      className: classNamesFieldset
    }, other), /*#__PURE__*/React__default.createElement("legend", {
      className: classNamesLegend
    }, legendText), children, message ? /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$10, "--form__requirements")
    }, messageText) : null);
  };

  FormGroup.propTypes = {
    /**
     * Provide the children form elements to be rendered inside of the <fieldset>
     */
    children: PropTypes.node,

    /**
     * Provide the text to be rendered inside of the fieldset <legend>
     */
    legendText: PropTypes.string.isRequired,

    /**
     * Provide a custom className to be applied to the containing <fieldset> node
     */
    className: PropTypes.string,

    /**
     * Specify whether the <FormGroup> is invalid
     */
    invalid: PropTypes.bool,

    /**
     * Specify whether the message should be displayed in the <FormGroup>
     */
    message: PropTypes.bool,

    /**
     * Provide the text for the message in the <FormGroup>
     */
    messageText: PropTypes.string
  };
  FormGroup.defaultProps = {
    invalid: false,
    message: false,
    messageText: ''
  };

  var prefix$11 = settings_1.prefix;

  var FormItem = function FormItem(_ref) {
    var className = _ref.className,
        children = _ref.children,
        other = _objectWithoutProperties(_ref, ["className", "children"]);

    var classNames = classnames("".concat(prefix$11, "--form-item"), className);
    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classNames
    }, other), children);
  };

  FormItem.propTypes = {
    /**
     * Provide content to be rendered in the form item
     */
    children: PropTypes.node,

    /**
     * Provide a custom className to be applied to the containing node
     */
    className: PropTypes.string
  };

  var prefix$12 = settings_1.prefix;

  var FormLabel = function FormLabel(_ref) {
    var className = _ref.className,
        children = _ref.children,
        id = _ref.id,
        other = _objectWithoutProperties(_ref, ["className", "children", "id"]);

    var classNames = classnames("".concat(prefix$12, "--label"), className);
    return /*#__PURE__*/React__default.createElement("label", _extends({
      htmlFor: id,
      className: classNames
    }, other), children);
  };

  FormLabel.propTypes = {
    /**
     * Specify the content of the form label
     */
    children: PropTypes.node,

    /**
     * Provide a custom className to be applied to the containing <label> node
     */
    className: PropTypes.string,

    /**
     * Provide a unique id for the given <FormLabel>
     */
    id: PropTypes.string
  };

  var prefix$13 = settings_1.prefix;

  function Grid(_ref) {
    var _cx;

    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        _ref$condensed = _ref.condensed,
        condensed = _ref$condensed === void 0 ? false : _ref$condensed,
        _ref$fullWidth = _ref.fullWidth,
        fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,
        containerClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties(_ref, ["as", "condensed", "fullWidth", "className", "children"]);

    var className = classnames(containerClassName, (_cx = {}, _defineProperty(_cx, "".concat(prefix$13, "--grid"), true), _defineProperty(_cx, "".concat(prefix$13, "--grid--condensed"), condensed), _defineProperty(_cx, "".concat(prefix$13, "--grid--full-width"), fullWidth), _cx));
    return /*#__PURE__*/React__default.createElement(BaseComponent, _extends({
      className: className
    }, rest), children);
  }

  Grid.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),

    /**
     * Collapse the gutter to 2px. Useful for fluid layouts.
     * Rows have 2px of margin between them to match gutter.
     */
    condensed: PropTypes.bool,

    /**
     * Remove the default max width that the grid has set
     */
    fullWidth: PropTypes.bool,

    /**
     * Specify a custom className to be applied to the `Grid`
     */
    className: PropTypes.string,

    /**
     * Pass in content that will be rendered within the `Grid`
     */
    children: PropTypes.node
  };

  var prefix$14 = settings_1.prefix;

  function Row(_ref) {
    var _cx;

    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        _ref$condensed = _ref.condensed,
        condensed = _ref$condensed === void 0 ? false : _ref$condensed,
        containerClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties(_ref, ["as", "condensed", "className", "children"]);

    var className = classnames(containerClassName, (_cx = {}, _defineProperty(_cx, "".concat(prefix$14, "--row"), true), _defineProperty(_cx, "".concat(prefix$14, "--row--condensed"), condensed), _cx));
    return /*#__PURE__*/React__default.createElement(BaseComponent, _extends({
      className: className
    }, rest), children);
  }

  Row.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),

    /**
     * Specify a single row as condensed.Rows that are adjacent
     * and are condensed will have 2px of margin between them to match gutter.
     */
    condensed: PropTypes.bool,

    /**
     * Specify a custom className to be applied to the `Row`
     */
    className: PropTypes.string,

    /**
     * Pass in content that will be rendered within the `Row`
     */
    children: PropTypes.node
  };

  var prefix$15 = settings_1.prefix;

  function Column(_ref) {
    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        children = _ref.children,
        containerClassName = _ref.className,
        sm = _ref.sm,
        md = _ref.md,
        lg = _ref.lg,
        xlg = _ref.xlg,
        max = _ref.max,
        rest = _objectWithoutProperties(_ref, ["as", "children", "className", "sm", "md", "lg", "xlg", "max"]);

    var columnClassName = getClassNameForBreakpoints([sm, md, lg, xlg, max]);
    var className = classnames(containerClassName, columnClassName, _defineProperty({}, "".concat(prefix$15, "--col"), columnClassName.length === 0));
    return /*#__PURE__*/React__default.createElement(BaseComponent, _extends({
      className: className
    }, rest), children);
  }

  var spanPropType = PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.shape({
    span: PropTypes.number,
    offset: PropTypes.number
  })]);
  Column.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),

    /**
     * Specify column span for the `sm` breakpoint (Default breakpoint up to 672px)
     * This breakpoint supports 4 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    sm: spanPropType,

    /**
     * Specify column span for the `md` breakpoint (Default breakpoint up to 1056px)
     * This breakpoint supports 8 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    md: spanPropType,

    /**
     * Specify column span for the `lg` breakpoint (Default breakpoint up to 1312px)
     * This breakpoint supports 16 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    lg: spanPropType,

    /**
     * Specify column span for the `xlg` breakpoint (Default breakpoint up to
     * 1584px) This breakpoint supports 16 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    xlg: spanPropType,

    /**
     * Specify column span for the `max` breakpoint. This breakpoint supports 16
     * columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    max: spanPropType,

    /**
     * Specify a custom className to be applied to the `Column`
     */
    className: PropTypes.string,

    /**
     * Pass in content that will be rendered within the `Column`
     */
    children: PropTypes.node
  };
  var breakpointNames = ['sm', 'md', 'lg', 'xlg', 'max'];
  /**
   * @typedef {object} Breakpoint
   * @property {boolean|number} [span]
   * @property {number} [offset]
   */

  /**
   * Build the appropriate className for the given set of breakpoints.
   * @param {Array<boolean|number|Breakpoint>} breakpoints
   * @returns {string}
   */

  function getClassNameForBreakpoints(breakpoints) {
    var classNames = [];

    for (var i = 0; i < breakpoints.length; i++) {
      var breakpoint = breakpoints[i];

      if (!breakpoint) {
        continue;
      }

      var name = breakpointNames[i]; // If our breakpoint is a boolean, the user has specified that the column
      // should be "auto" at this size

      if (breakpoint === true) {
        classNames.push("".concat(prefix$15, "--col-").concat(name));
        continue;
      } // If our breakpoint is a number, the user has specified the number of
      // columns they'd like this column to span


      if (typeof breakpoint === 'number') {
        classNames.push("".concat(prefix$15, "--col-").concat(name, "-").concat(breakpoint));
        continue;
      }

      var span = breakpoint.span,
          offset = breakpoint.offset;

      if (typeof span === 'number') {
        classNames.push("".concat(prefix$15, "--col-").concat(name, "-").concat(span));
      }

      if (span === true) {
        classNames.push("".concat(prefix$15, "--col-").concat(name));
      }

      if (typeof offset === 'number') {
        classNames.push("".concat(prefix$15, "--offset-").concat(name, "-").concat(offset));
      }
    }

    return classNames.join(' ');
  }

  /**
   * @param {object} svgData - JSON Object for an SVG icon
   * @returns {ReactElement} Elements/Nodes for SVG
   * @example
   * // Returns SVG elements
   * const svgData = getSvgData('copy-code');
   * svgShapes(svgData);
   */

  function svgShapes(svgData) {
    var svgElements = Object.keys(svgData).filter(function (key) {
      return svgData[key];
    }).map(function (svgProp) {
      var data = svgData[svgProp];

      if (svgProp === 'circles') {
        return data.map(function (circle, index) {
          var circleProps = {
            cx: circle.cx,
            cy: circle.cy,
            r: circle.r,
            key: "circle".concat(index)
          };
          return /*#__PURE__*/React__default.createElement("circle", _extends({
            key: index
          }, circleProps));
        });
      } else if (svgProp === 'paths') {
        return data.map(function (path, index) {
          return /*#__PURE__*/React__default.createElement("path", {
            d: path.d,
            key: "key".concat(index)
          });
        });
      } else if (svgProp === 'polygons') {
        return data.map(function (polygon, index) {
          return /*#__PURE__*/React__default.createElement("polygon", {
            points: polygon.points,
            key: "key".concat(index)
          });
        });
      }

      return '';
    });
    return svgElements;
  }
  function isPrefixed(name) {
    {
      !(typeof name === 'string') ?  invariant_1(false, '[Icon] icon name is missing. You likely forgot to specify the icon, ' + 'or are using older (pre-`7.x`) version of `carbon-icons` library. ' + 'To specify the icon, use either `icon` (data) or `name` (icon name) properties.')  : void 0;
    }

    return name && name.split('--')[0] === 'icon';
  }

  var Icon$1 = function Icon(_ref) {
    var className = _ref.className,
        iconTitle = _ref.iconTitle,
        description = _ref.description,
        fill = _ref.fill,
        fillRule = _ref.fillRule,
        height = _ref.height,
        name = _ref.name,
        icon = _ref.icon,
        role = _ref.role,
        style = _ref.style,
        width = _ref.width,
        iconRef = _ref.iconRef,
        other = _objectWithoutProperties(_ref, ["className", "iconTitle", "description", "fill", "fillRule", "height", "name", "icon", "role", "style", "width", "iconRef"]);

    var props = _objectSpread2({
      className: className,
      fill: fill,
      fillRule: fillRule,
      height: height || icon.height,
      name: isPrefixed ? name : "icon--".concat(name),
      role: role,
      style: style,
      viewBox: icon.viewBox,
      width: width || icon.width,
      ref: iconRef
    }, other);

    var svgContent = icon ? svgShapes(icon.svgData) : '';
    return /*#__PURE__*/React__default.createElement("svg", _extends({}, props, {
      "aria-label": description
    }), /*#__PURE__*/React__default.createElement("title", null, typeof iconTitle === 'undefined' ? description : iconTitle), svgContent);
  };

  Icon$1.propTypes = {
    /**
     * The CSS class name.
     */
    className: PropTypes.string,

    /**
     * The name of the icon.
     */
    name: PropTypes.string,

    /**
     * The icon title.
     */
    iconTitle: PropTypes.string,

    /**
     * The icon description.
     */
    description: PropTypes.string.isRequired,

    /**
     * The `<svg>` `fill` attribute.
     */
    fill: PropTypes.string,

    /**
     * The `<svg>` `fillRule` attribute.
     */
    fillRule: PropTypes.string,

    /**
     * The `<svg>` `height` attribute.
     */
    height: PropTypes.string,

    /**
     * The icon data.
     */
    icon: PropTypes.shape({
      width: PropTypes.string,
      height: PropTypes.string,
      viewBox: PropTypes.string.isRequired,
      svgData: PropTypes.object.isRequired
    }),

    /**
     * The `role` attribute.
     */
    role: PropTypes.string,

    /**
     * The CSS styles.
     */
    style: PropTypes.object,

    /**
     * The `<svg>` `viewbox` attribute.
     */
    viewBox: PropTypes.string,

    /**
     * The `<svg>` `width` attribute.
     */
    width: PropTypes.string,

    /**
     * The `ref` callback for the icon.
     */
    iconRef: PropTypes.func
  };
  Icon$1.defaultProps = {
    fillRule: 'evenodd',
    role: 'img'
  };

  var prefix$16 = settings_1.prefix;

  var IconSkeleton = function IconSkeleton(_ref) {
    var style = _ref.style,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["style", "className"]);

    var props = _objectSpread2({
      style: style
    }, rest);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$16, "--icon--skeleton"), className)
    }, props));
  };

  IconSkeleton.propTypes = {
    /**
     * The CSS styles.
     */
    style: PropTypes.object,

    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$17 = settings_1.prefix;
  function InlineLoading$1(_ref) {
    var className = _ref.className,
        success = _ref.success,
        _ref$status = _ref.status,
        status = _ref$status === void 0 ? success ? 'finished' : 'active' : _ref$status,
        iconDescription = _ref.iconDescription,
        description = _ref.description,
        onSuccess = _ref.onSuccess,
        successDelay = _ref.successDelay,
        other = _objectWithoutProperties(_ref, ["className", "success", "status", "iconDescription", "description", "onSuccess", "successDelay"]);

    var loadingClasses = classnames("".concat(prefix$17, "--inline-loading"), className);

    var getLoading = function getLoading() {
      if (status === 'error') {
        return /*#__PURE__*/React__default.createElement(ErrorFilled16, {
          className: "".concat(prefix$17, "--inline-loading--error")
        });
      }

      if (status === 'finished') {
        setTimeout(function () {
          if (onSuccess) {
            onSuccess();
          }
        }, successDelay);
        return /*#__PURE__*/React__default.createElement(CheckmarkFilled16, {
          className: "".concat(prefix$17, "--inline-loading__checkmark-container")
        });
      }

      if (status === 'inactive' || status === 'active') {
        return /*#__PURE__*/React__default.createElement(Loading$1, {
          small: true,
          description: iconDescription,
          withOverlay: false,
          active: status === 'active'
        });
      }

      return undefined;
    };

    var loadingText = /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$17, "--inline-loading__text")
    }, description);
    var loading = getLoading();
    var loadingAnimation = loading && /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$17, "--inline-loading__animation")
    }, loading);
    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: loadingClasses
    }, other, {
      "aria-live": 'assertive' 
    }), loadingAnimation, description && loadingText);
  }
  InlineLoading$1.propTypes = {
    /**
     * Specify a custom className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify whether the load was successful
     */
    success: deprecate(PropTypes.bool, "\nThe prop `success` for InlineLoading has been deprecated in favor of `status`. Please use `status=\"finished\"` instead."),

    /**
     * Specify the loading status
     */
    status: PropTypes.oneOf(['inactive', 'active', 'finished', 'error']),

    /**
     * Specify the description for the inline loading text
     */
    description: PropTypes.node,

    /**
     * Specify the description for the inline loading text
     */
    iconDescription: PropTypes.string,

    /**
     * Provide an optional handler to be inovked when <InlineLoading> is
     * successful
     */
    onSuccess: PropTypes.func,

    /**
     * Provide a delay for the `setTimeout` for success
     */
    successDelay: PropTypes.number
  };
  InlineLoading$1.defaultProps = {
    successDelay: 1500
  };

  var prefix$18 = settings_1.prefix;

  var ListItem = function ListItem(_ref) {
    var children = _ref.children,
        className = _ref.className,
        other = _objectWithoutProperties(_ref, ["children", "className"]);

    var classNames = classnames("".concat(prefix$18, "--list__item"), className);
    return /*#__PURE__*/React__default.createElement("li", _extends({
      className: classNames
    }, other), children);
  };

  ListItem.propTypes = {
    /**
     * Specify the content for the ListItem
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to apply to the underlying <li> node
     */
    className: PropTypes.string
  };

  var prefix$19 = settings_1.prefix;
  var getInstanceId$4 = setupGetInstanceId();

  var Modal$1 = /*#__PURE__*/function (_Component) {
    _inherits(Modal, _Component);

    var _super = _createSuper(Modal);

    function Modal() {
      var _this;

      _classCallCheck(this, Modal);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "button", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "outerModal", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "innerModal", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "startTrap", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "endTrap", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "modalInstanceId", "modal-".concat(getInstanceId$4()));

      _defineProperty(_assertThisInitialized(_this), "modalLabelId", "".concat(prefix$19, "--modal-header__label--").concat(_this.modalInstanceId));

      _defineProperty(_assertThisInitialized(_this), "modalHeadingId", "".concat(prefix$19, "--modal-header__heading--").concat(_this.modalInstanceId));

      _defineProperty(_assertThisInitialized(_this), "handleKeyDown", function (evt) {
        if (_this.props.open) {
          if (evt.which === 27) {
            _this.props.onRequestClose(evt);
          }

          if (evt.which === 13 && _this.props.shouldSubmitOnEnter) {
            _this.props.onRequestSubmit(evt);
          }
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleMousedown", function (evt) {
        if (_this.innerModal.current && !_this.innerModal.current.contains(evt.target) && !elementOrParentIsFloatingMenu(evt.target, _this.props.selectorsFloatingMenus)) {
          _this.props.onRequestClose(evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleBlur", function (_ref) {
        var oldActiveNode = _ref.target,
            currentActiveNode = _ref.relatedTarget;
        var _this$props = _this.props,
            open = _this$props.open,
            selectorsFloatingMenus = _this$props.selectorsFloatingMenus;

        if (open && currentActiveNode && oldActiveNode) {
          var modalNode = _this.innerModal.current;
          var startTrapNode = _this.startTrap.current;
          var endTrapNode = _this.endTrap.current;
          wrapFocus({
            modalNode: modalNode,
            startTrapNode: startTrapNode,
            endTrapNode: endTrapNode,
            currentActiveNode: currentActiveNode,
            oldActiveNode: oldActiveNode,
            selectorsFloatingMenus: selectorsFloatingMenus
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "initialFocus", function (focusContainerElement) {
        var containerElement = focusContainerElement || _this.innerModal.current;
        var primaryFocusElement = containerElement ? containerElement.querySelector(_this.props.selectorPrimaryFocus) : null;

        if (primaryFocusElement) {
          return primaryFocusElement;
        }

        return _this.button && _this.button.current;
      });

      _defineProperty(_assertThisInitialized(_this), "focusButton", function (focusContainerElement) {
        var target = _this.initialFocus(focusContainerElement);

        if (target) {
          target.focus();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleTransitionEnd", function (evt) {
        if (evt.target === evt.currentTarget && // Not to handle `onTransitionEnd` on child DOM nodes
        _this.outerModal.current && _this.outerModal.current.offsetWidth && _this.outerModal.current.offsetHeight && _this.beingOpen) {
          _this.focusButton(evt.currentTarget);

          _this.beingOpen = false;
        }
      });

      return _this;
    }

    _createClass(Modal, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (!prevProps.open && this.props.open) {
          this.beingOpen = true;
        } else if (prevProps.open && !this.props.open) {
          this.beingOpen = false;
        }

        toggleClass(document.body, "".concat(prefix$19, "--body--with-modal-open"), this.props.open);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        toggleClass(document.body, "".concat(prefix$19, "--body--with-modal-open"), false);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        toggleClass(document.body, "".concat(prefix$19, "--body--with-modal-open"), this.props.open);

        if (!this.props.open) {
          return;
        }

        this.focusButton(this.innerModal.current);
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames, _classNames3;

        var _this$props2 = this.props,
            modalHeading = _this$props2.modalHeading,
            modalLabel = _this$props2.modalLabel,
            modalAriaLabel = _this$props2.modalAriaLabel,
            passiveModal = _this$props2.passiveModal,
            hasForm = _this$props2.hasForm,
            secondaryButtonText = _this$props2.secondaryButtonText,
            primaryButtonText = _this$props2.primaryButtonText,
            open = _this$props2.open,
            onRequestClose = _this$props2.onRequestClose,
            onRequestSubmit = _this$props2.onRequestSubmit,
            onSecondarySubmit = _this$props2.onSecondarySubmit,
            iconDescription = _this$props2.iconDescription,
            primaryButtonDisabled = _this$props2.primaryButtonDisabled,
            danger = _this$props2.danger,
            selectorPrimaryFocus = _this$props2.selectorPrimaryFocus,
            selectorsFloatingMenus = _this$props2.selectorsFloatingMenus,
            shouldSubmitOnEnter = _this$props2.shouldSubmitOnEnter,
            size = _this$props2.size,
            hasScrollingContent = _this$props2.hasScrollingContent,
            other = _objectWithoutProperties(_this$props2, ["modalHeading", "modalLabel", "modalAriaLabel", "passiveModal", "hasForm", "secondaryButtonText", "primaryButtonText", "open", "onRequestClose", "onRequestSubmit", "onSecondarySubmit", "iconDescription", "primaryButtonDisabled", "danger", "selectorPrimaryFocus", "selectorsFloatingMenus", "shouldSubmitOnEnter", "size", "hasScrollingContent"]);

        var onSecondaryButtonClick = onSecondarySubmit ? onSecondarySubmit : onRequestClose;
        var modalClasses = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$19, "--modal"), true), _defineProperty(_classNames, "".concat(prefix$19, "--modal-tall"), !passiveModal), _defineProperty(_classNames, 'is-visible', open), _defineProperty(_classNames, "".concat(prefix$19, "--modal--danger"), this.props.danger), _defineProperty(_classNames, this.props.className, this.props.className), _classNames));
        var containerClasses = classnames("".concat(prefix$19, "--modal-container"), _defineProperty({}, "".concat(prefix$19, "--modal-container--").concat(size), size));
        var contentClasses = classnames("".concat(prefix$19, "--modal-content"), (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$19, "--modal-content--with-form"), hasForm), _defineProperty(_classNames3, "".concat(prefix$19, "--modal-scroll-content"), hasScrollingContent), _classNames3));
        var modalButton = /*#__PURE__*/React__default.createElement("button", {
          className: "".concat(prefix$19, "--modal-close"),
          type: "button",
          onClick: onRequestClose,
          title: iconDescription,
          "aria-label": iconDescription,
          ref: this.button
        }, /*#__PURE__*/React__default.createElement(Close20, {
          "aria-label": iconDescription,
          className: "".concat(prefix$19, "--modal-close__icon")
        }));
        var ariaLabel = modalLabel || this.props['aria-label'] || modalAriaLabel || modalHeading;
        var getAriaLabelledBy = modalLabel ? this.modalLabelId : this.modalHeadingId;
        var hasScrollingContentProps = hasScrollingContent ? {
          tabIndex: 0,
          role: 'region',
          'aria-label': ariaLabel,
          'aria-labelledby': getAriaLabelledBy
        } : {};
        var modalBody = /*#__PURE__*/React__default.createElement("div", {
          ref: this.innerModal,
          role: "dialog",
          className: containerClasses,
          "aria-label": ariaLabel,
          "aria-modal": "true",
          tabIndex: "-1"
        }, /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$19, "--modal-header")
        }, passiveModal && modalButton, modalLabel && /*#__PURE__*/React__default.createElement("h2", {
          id: this.modalLabelId,
          className: "".concat(prefix$19, "--modal-header__label")
        }, modalLabel), /*#__PURE__*/React__default.createElement("h3", {
          id: this.modalHeadingId,
          className: "".concat(prefix$19, "--modal-header__heading")
        }, modalHeading), !passiveModal && modalButton), /*#__PURE__*/React__default.createElement("div", _extends({
          className: contentClasses
        }, hasScrollingContentProps, {
          "aria-labelledby": getAriaLabelledBy
        }), this.props.children), hasScrollingContent && /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$19, "--modal-content--overflow-indicator")
        }), !passiveModal && /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$19, "--modal-footer")
        }, /*#__PURE__*/React__default.createElement(Button, {
          kind: "secondary",
          onClick: onSecondaryButtonClick
        }, secondaryButtonText), /*#__PURE__*/React__default.createElement(Button, {
          kind: danger ? 'danger' : 'primary',
          disabled: primaryButtonDisabled,
          onClick: onRequestSubmit,
          ref: this.button
        }, primaryButtonText)));
        return /*#__PURE__*/React__default.createElement("div", _extends({}, other, {
          onKeyDown: this.handleKeyDown,
          onMouseDown: this.handleMousedown,
          onBlur: this.handleBlur,
          className: modalClasses,
          role: "presentation",
          onTransitionEnd: this.props.open ? this.handleTransitionEnd : undefined,
          ref: this.outerModal
        }), /*#__PURE__*/React__default.createElement("span", {
          ref: this.startTrap,
          tabIndex: "0",
          role: "link",
          className: "".concat(prefix$19, "--visually-hidden")
        }, "Focus sentinel"), modalBody, /*#__PURE__*/React__default.createElement("span", {
          ref: this.endTrap,
          tabIndex: "0",
          role: "link",
          className: "".concat(prefix$19, "--visually-hidden")
        }, "Focus sentinel"));
      }
    }]);

    return Modal;
  }(React.Component);

  _defineProperty(Modal$1, "propTypes", _defineProperty({
    /**
     * Provide the contents of your Modal
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the modal root node
     */
    className: PropTypes.string,

    /**
     * Specify whether the modal should be button-less
     */
    passiveModal: PropTypes.bool,

    /**
     * Provide whether the modal content has a form element.
     * If `true` is used here, non-form child content should have `bx--modal-content__regular-content` class.
     */
    hasForm: PropTypes.bool,

    /**
     * Specify a handler for closing modal.
     * The handler should care of closing modal, e.g. changing `open` prop.
     */
    onRequestClose: PropTypes.func,

    /**
     * Specify the DOM element ID of the top-level node.
     */
    id: PropTypes.string,

    /**
     * Specify the content of the modal header title.
     */
    modalHeading: PropTypes.node,

    /**
     * Specify the content of the modal header label.
     */
    modalLabel: PropTypes.node,

    /**
     * Specify a label to be read by screen readers on the modal root node
     */
    modalAriaLabel: PropTypes.string,

    /**
     * Specify the text for the secondary button
     */
    secondaryButtonText: PropTypes.node,

    /**
     * Specify the text for the primary button
     */
    primaryButtonText: PropTypes.node,

    /**
     * Specify whether the Modal is currently open
     */
    open: PropTypes.bool,

    /**
     * Specify a handler for "submitting" modal.
     * The handler should care of closing modal, e.g. changing `open` prop, if necessary.
     */
    onRequestSubmit: PropTypes.func,

    /**
     * Specify a handler for keypresses.
     */
    onKeyDown: PropTypes.func,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes.string,

    /**
     * Specify whether the Button should be disabled, or not
     */
    primaryButtonDisabled: PropTypes.bool,

    /**
     * Specify a handler for the secondary button.
     * Useful if separate handler from `onRequestClose` is desirable
     */
    onSecondarySubmit: PropTypes.func,

    /**
     * Specify whether the Modal is for dangerous actions
     */
    danger: PropTypes.bool,

    /**
     * Specify if Enter key should be used as "submit" action
     */
    shouldSubmitOnEnter: PropTypes.bool,

    /**
     * Specify CSS selectors that match DOM elements working as floating menus.
     * Focusing on those elements won't trigger "focus-wrap" behavior
     */
    selectorsFloatingMenus: PropTypes.arrayOf(PropTypes.string),

    /**
     * Specify a CSS selector that matches the DOM element that should
     * be focused when the Modal opens
     */
    selectorPrimaryFocus: PropTypes.string,

    /**
     * Specify the size variant.
     */
    size: PropTypes.oneOf(['xs', 'sm', 'lg']),

    /**
     * Deprecated; Used for advanced focus-wrapping feature using 3rd party library,
     * but it's now achieved without a 3rd party library.
     */
    focusTrap: deprecate(PropTypes.bool, "\nThe prop `focusTrap` for Modal has been deprecated, as the feature of `focusTrap` runs by default."),

    /**
     * Specify whether the modal contains scrolling content
     */
    hasScrollingContent: PropTypes.bool
  }, 'aria-label', requiredIfGivenPropIsTruthy('hasScrollingContent', PropTypes.string)));

  _defineProperty(Modal$1, "defaultProps", {
    onRequestClose: function onRequestClose() {},
    onRequestSubmit: function onRequestSubmit() {},
    primaryButtonDisabled: false,
    onKeyDown: function onKeyDown() {},
    passiveModal: false,
    iconDescription: 'Close',
    modalHeading: '',
    modalLabel: '',
    selectorPrimaryFocus: '[data-modal-primary-focus]',
    hasScrollingContent: false
  });

  var ModalWrapper = /*#__PURE__*/function (_React$Component) {
    _inherits(ModalWrapper, _React$Component);

    var _super = _createSuper(ModalWrapper);

    function ModalWrapper() {
      var _this;

      _classCallCheck(this, ModalWrapper);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "triggerButton", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "state", {
        isOpen: false
      });

      _defineProperty(_assertThisInitialized(_this), "handleOpen", function () {
        _this.setState({
          isOpen: true
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleClose", function () {
        _this.setState({
          isOpen: false
        }, function () {
          return _this.triggerButton.current.focus();
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnRequestSubmit", function () {
        var _this$props = _this.props,
            handleSubmit = _this$props.handleSubmit,
            shouldCloseAfterSubmit = _this$props.shouldCloseAfterSubmit;

        if (handleSubmit()) {
          if (shouldCloseAfterSubmit) {
            _this.handleClose();
          }
        }
      });

      return _this;
    }

    _createClass(ModalWrapper, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props2 = this.props,
            children = _this$props2.children,
            _onKeyDown = _this$props2.onKeyDown,
            buttonTriggerText = _this$props2.buttonTriggerText,
            buttonTriggerClassName = _this$props2.buttonTriggerClassName,
            renderTriggerButtonIcon = _this$props2.renderTriggerButtonIcon,
            triggerButtonIconDescription = _this$props2.triggerButtonIconDescription,
            triggerButtonKind = _this$props2.triggerButtonKind,
            disabled = _this$props2.disabled,
            handleSubmit = _this$props2.handleSubmit,
            shouldCloseAfterSubmit = _this$props2.shouldCloseAfterSubmit,
            selectorPrimaryFocus = _this$props2.selectorPrimaryFocus,
            other = _objectWithoutProperties(_this$props2, ["children", "onKeyDown", "buttonTriggerText", "buttonTriggerClassName", "renderTriggerButtonIcon", "triggerButtonIconDescription", "triggerButtonKind", "disabled", "handleSubmit", "shouldCloseAfterSubmit", "selectorPrimaryFocus"]);

        var props = _objectSpread2(_objectSpread2({}, other), {}, {
          selectorPrimaryFocus: selectorPrimaryFocus,
          open: this.state.isOpen,
          onRequestClose: this.handleClose,
          onRequestSubmit: this.handleOnRequestSubmit
        });

        return /*#__PURE__*/React__default.createElement("div", {
          role: "presentation",
          onKeyDown: function onKeyDown(evt) {
            if (evt.which === 27) {
              _this2.handleClose();

              _onKeyDown(evt);
            }
          }
        }, /*#__PURE__*/React__default.createElement(Button, {
          className: buttonTriggerClassName,
          disabled: disabled,
          kind: triggerButtonKind,
          renderIcon: renderTriggerButtonIcon,
          iconDescription: triggerButtonIconDescription,
          onClick: this.handleOpen,
          ref: this.triggerButton
        }, buttonTriggerText), /*#__PURE__*/React__default.createElement(Modal$1, props, children));
      }
    }]);

    return ModalWrapper;
  }(React__default.Component);

  _defineProperty(ModalWrapper, "propTypes", {
    status: PropTypes.string,
    handleOpen: PropTypes.func,
    children: PropTypes.node,
    id: PropTypes.string,
    buttonTriggerText: PropTypes.node,
    buttonTriggerClassName: PropTypes.string,
    modalLabel: PropTypes.string,
    modalHeading: PropTypes.string,
    modalText: PropTypes.string,
    passiveModal: PropTypes.bool,
    withHeader: PropTypes.bool,
    modalBeforeContent: PropTypes.bool,
    primaryButtonText: PropTypes.string,
    secondaryButtonText: PropTypes.string,
    handleSubmit: PropTypes.func,
    disabled: PropTypes.bool,
    renderTriggerButtonIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    triggerButtonIconDescription: PropTypes.string,
    triggerButtonKind: PropTypes.oneOf(ButtonKinds),
    shouldCloseAfterSubmit: PropTypes.bool,
    onKeyDown: PropTypes.func,
    selectorPrimaryFocus: PropTypes.string
  });

  _defineProperty(ModalWrapper, "defaultProps", {
    primaryButtonText: 'Save',
    secondaryButtonText: 'Cancel',
    triggerButtonIconDescription: 'Provide icon description if icon is used',
    triggerButtonKind: 'primary',
    disabled: false,
    selectorPrimaryFocus: '[data-modal-primary-focus]',
    onKeyDown: function onKeyDown() {}
  });

  var sortingPropTypes = {
    /**
     * Provide a compare function that is used to determine the ordering of
     * options. `compareItems` has the following function signature:
     *
     * compareFunction :
     *  (itemA: string, itemB: string, { locale: string }) => number
     */
    compareItems: PropTypes.func.isRequired,

    /**
     * Provide a method that sorts all options in the control. Overriding this
     * prop means that you also have to handle the sort logic for selected versus
     * un-selected items. If you just want to control ordering, consider the
     * `compareItems` prop instead.
     *
     * `sortItems` has the following signature:
     *
     * sortItems :
     *   (items: Array<Item>, {
     *     selectedItems: Array<Item>,
     *     itemToString: Item => string,
     *     compareItems: (itemA: string, itemB: string, {
     *       locale: string
     *     }) => number,
     *     locale: string,
     *   }) => Array<Item>
     */
    sortItems: PropTypes.func.isRequired
  };

  var itemToString$1 = function itemToString(item) {
    !(typeof item.label === 'string') ?  invariant_1(false, '[MultiSelect] the default `itemToString` method expected to receive ' + 'an item with a `label` field of type `string`. Instead received: `%s`', _typeof(item.label))  : void 0;
    return item.label || '';
  };

  var defaultItemToString$2 = function defaultItemToString(item) {
    if (Array.isArray(item)) {
      return item.map(itemToString$1);
    }

    return itemToString$1(item);
  };

  /**
   * Use the local `localCompare` with the `numeric` option to sort two,
   * potentially alpha-numeric, strings in a list of items.
   *
   * @param {string} itemA
   * @param {string} itemB
   * @param {object} options
   * @param {string} options.locale
   * @returns {number}
   */
  var defaultCompareItems = function defaultCompareItems(itemA, itemB, _ref) {
    var locale = _ref.locale;
    return itemA.localeCompare(itemB, locale, {
      numeric: true
    });
  };
  /**
   * Default sorting algorithm for options in a selection control
   */

  var defaultSortItems = function defaultSortItems(items, _ref2) {
    var _ref2$selectedItems = _ref2.selectedItems,
        selectedItems = _ref2$selectedItems === void 0 ? [] : _ref2$selectedItems,
        itemToString = _ref2.itemToString,
        compareItems = _ref2.compareItems,
        _ref2$locale = _ref2.locale,
        locale = _ref2$locale === void 0 ? 'en' : _ref2$locale;
    return items.sort(function (itemA, itemB) {
      var hasItemA = selectedItems.includes(itemA);
      var hasItemB = selectedItems.includes(itemB); // Prefer whichever item is in the `selectedItems` array first

      if (hasItemA && !hasItemB) {
        return -1;
      }

      if (hasItemB && !hasItemA) {
        return 1;
      }

      return compareItems(itemToString(itemA), itemToString(itemB), {
        locale: locale
      });
    });
  };

  function useSelection(_ref) {
    var disabled = _ref.disabled,
        onChange = _ref.onChange,
        _ref$initialSelectedI = _ref.initialSelectedItems,
        initialSelectedItems = _ref$initialSelectedI === void 0 ? [] : _ref$initialSelectedI;
    var isMounted = React.useRef(false);
    var savedOnChange = React.useRef(onChange);

    var _useState = React.useState(initialSelectedItems),
        _useState2 = _slicedToArray(_useState, 2),
        selectedItems = _useState2[0],
        setSelectedItems = _useState2[1];

    var onItemChange = React.useCallback(function (item) {
      if (disabled) {
        return;
      }

      var selectedIndex;
      selectedItems.forEach(function (selectedItem, index) {
        if (lodash_isequal(selectedItem, item)) {
          selectedIndex = index;
        }
      });

      if (selectedIndex === undefined) {
        setSelectedItems(function (selectedItems) {
          return selectedItems.concat(item);
        });
        return;
      }

      setSelectedItems(function (selectedItems) {
        return removeAtIndex(selectedItems, selectedIndex);
      });
    }, [disabled, selectedItems]);
    var clearSelection = React.useCallback(function () {
      if (disabled) {
        return;
      }

      setSelectedItems([]);
    }, [disabled]);
    React.useEffect(function () {
      savedOnChange.current = onChange;
    }, [onChange]);
    React.useEffect(function () {
      if (isMounted.current === true && savedOnChange.current) {
        savedOnChange.current({
          selectedItems: selectedItems
        });
      }
    }, [selectedItems]);
    React.useEffect(function () {
      isMounted.current = true;
      return function () {
        isMounted.current = false;
      };
    }, []);
    return {
      selectedItems: selectedItems,
      onItemChange: onItemChange,
      clearSelection: clearSelection
    };
  }

  var Selection = /*#__PURE__*/function (_React$Component) {
    _inherits(Selection, _React$Component);

    var _super = _createSuper(Selection);

    function Selection(props) {
      var _this;

      _classCallCheck(this, Selection);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "internalSetState", function (stateToSet, callback) {
        return _this.setState(stateToSet, function () {
          if (callback) {
            callback();
          }

          if (_this.props.onChange) {
            _this.props.onChange(_this.state);
          }
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleClearSelection", function () {
        if (_this.props.disabled) {
          return;
        }

        _this.internalSetState({
          selectedItems: []
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleSelectItem", function (item) {
        _this.internalSetState(function (state) {
          return {
            selectedItems: state.selectedItems.concat(item)
          };
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleRemoveItem", function (index) {
        _this.internalSetState(function (state) {
          return {
            selectedItems: removeAtIndex(state.selectedItems, index)
          };
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnItemChange", function (item) {
        if (_this.props.disabled) {
          return;
        }

        var selectedItems = _this.state.selectedItems;
        var selectedIndex;
        selectedItems.forEach(function (selectedItem, index) {
          if (lodash_isequal(selectedItem, item)) {
            selectedIndex = index;
          }
        });

        if (selectedIndex === undefined) {
          _this.handleSelectItem(item);

          return;
        }

        _this.handleRemoveItem(selectedIndex);
      });

      _this.state = {
        selectedItems: props.initialSelectedItems
      };
      return _this;
    }

    _createClass(Selection, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            children = _this$props.children,
            render = _this$props.render;
        var selectedItems = this.state.selectedItems;
        var renderProps = {
          selectedItems: selectedItems,
          onItemChange: this.handleOnItemChange,
          clearSelection: this.handleClearSelection
        };

        if (render !== undefined) {
          return render(renderProps);
        }

        if (children !== undefined) {
          return children(renderProps);
        }

        return null;
      }
    }]);

    return Selection;
  }(React__default.Component); // Generic utility for safely removing an element at a given index from an
  // array.


  _defineProperty(Selection, "propTypes", {
    children: PropTypes.func,
    disabled: PropTypes.bool,
    initialSelectedItems: PropTypes.array.isRequired,
    onChange: PropTypes.func,
    render: PropTypes.func
  });

  _defineProperty(Selection, "defaultProps", {
    initialSelectedItems: []
  });

  var removeAtIndex = function removeAtIndex(array, index) {
    var result = array.slice();
    result.splice(index, 1);
    return result;
  };

  var prefix$1a = settings_1.prefix;

  var noop$2 = function noop() {};

  var getInstanceId$5 = setupGetInstanceId();
  var _useSelect$stateChang = useSelect.stateChangeTypes,
      ItemClick$1 = _useSelect$stateChang.ItemClick,
      MenuBlur$1 = _useSelect$stateChang.MenuBlur,
      MenuKeyDownArrowDown$1 = _useSelect$stateChang.MenuKeyDownArrowDown,
      MenuKeyDownArrowUp$1 = _useSelect$stateChang.MenuKeyDownArrowUp,
      MenuKeyDownEnter$1 = _useSelect$stateChang.MenuKeyDownEnter,
      MenuKeyDownEscape$1 = _useSelect$stateChang.MenuKeyDownEscape,
      MenuKeyDownSpaceButton$1 = _useSelect$stateChang.MenuKeyDownSpaceButton,
      ToggleButtonClick$1 = _useSelect$stateChang.ToggleButtonClick;
  var MultiSelect = /*#__PURE__*/React__default.forwardRef(function MultiSelect(_ref, ref) {
    var _cx, _cx4;

    var containerClassName = _ref.className,
        id = _ref.id,
        items = _ref.items,
        itemToString = _ref.itemToString,
        titleText = _ref.titleText,
        helperText = _ref.helperText,
        label = _ref.label,
        type = _ref.type,
        size = _ref.size,
        disabled = _ref.disabled,
        initialSelectedItems = _ref.initialSelectedItems,
        sortItems = _ref.sortItems,
        compareItems = _ref.compareItems,
        light = _ref.light,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        useTitleInItem = _ref.useTitleInItem,
        translateWithId = _ref.translateWithId,
        downshiftProps = _ref.downshiftProps,
        open = _ref.open,
        selectionFeedback = _ref.selectionFeedback,
        onChange = _ref.onChange,
        direction = _ref.direction;

    var _useRef = React.useRef(getInstanceId$5()),
        multiSelectInstanceId = _useRef.current;

    var _useState = React.useState(null),
        _useState2 = _slicedToArray(_useState, 2),
        highlightedIndex = _useState2[0],
        setHighlightedIndex = _useState2[1];

    var _useState3 = React.useState(open),
        _useState4 = _slicedToArray(_useState3, 2),
        isOpen = _useState4[0],
        setIsOpen = _useState4[1];

    var _useState5 = React.useState(open),
        _useState6 = _slicedToArray(_useState5, 2),
        prevOpenProp = _useState6[0],
        setPrevOpenProp = _useState6[1];

    var _useState7 = React.useState([]),
        _useState8 = _slicedToArray(_useState7, 2),
        topItems = _useState8[0],
        setTopItems = _useState8[1];

    var _useSelection = useSelection({
      disabled: disabled,
      initialSelectedItems: initialSelectedItems,
      onChange: onChange
    }),
        controlledSelectedItems = _useSelection.selectedItems,
        onItemChange = _useSelection.onItemChange,
        clearSelection = _useSelection.clearSelection;

    var _useSelect = useSelect(mapDownshiftProps(_objectSpread2(_objectSpread2({}, downshiftProps), {}, {
      highlightedIndex: highlightedIndex,
      isOpen: isOpen,
      itemToString: itemToString,
      onStateChange: onStateChange,
      selectedItem: controlledSelectedItems,
      items: items
    }))),
        getToggleButtonProps = _useSelect.getToggleButtonProps,
        getLabelProps = _useSelect.getLabelProps,
        getMenuProps = _useSelect.getMenuProps,
        getItemProps = _useSelect.getItemProps,
        selectedItems = _useSelect.selectedItem;
    /**
     * programmatically control this `open` prop
     */


    if (prevOpenProp !== open) {
      setIsOpen(open);
      setPrevOpenProp(open);
    }

    var inline = type === 'inline';
    var wrapperClasses = classnames("".concat(prefix$1a, "--multi-select__wrapper"), "".concat(prefix$1a, "--list-box__wrapper"), (_cx = {}, _defineProperty(_cx, "".concat(prefix$1a, "--multi-select__wrapper--inline"), inline), _defineProperty(_cx, "".concat(prefix$1a, "--list-box__wrapper--inline"), inline), _defineProperty(_cx, "".concat(prefix$1a, "--multi-select__wrapper--inline--invalid"), inline && invalid), _defineProperty(_cx, "".concat(prefix$1a, "--list-box__wrapper--inline--invalid"), inline && invalid), _cx));
    var titleClasses = classnames("".concat(prefix$1a, "--label"), _defineProperty({}, "".concat(prefix$1a, "--label--disabled"), disabled));
    var helperId = !helperText ? undefined : "multiselect-helper-text-".concat(multiSelectInstanceId);
    var fieldLabelId = "multiselect-field-label-".concat(multiSelectInstanceId);
    var helperClasses = classnames("".concat(prefix$1a, "--form__helper-text"), _defineProperty({}, "".concat(prefix$1a, "--form__helper-text--disabled"), disabled));
    var className = classnames("".concat(prefix$1a, "--multi-select"), containerClassName, (_cx4 = {}, _defineProperty(_cx4, "".concat(prefix$1a, "--multi-select--invalid"), invalid), _defineProperty(_cx4, "".concat(prefix$1a, "--multi-select--inline"), inline), _defineProperty(_cx4, "".concat(prefix$1a, "--multi-select--selected"), selectedItems && selectedItems.length > 0), _defineProperty(_cx4, "".concat(prefix$1a, "--list-box--up"), direction === 'top'), _cx4));
    var sortOptions = {
      selectedItems: controlledSelectedItems,
      itemToString: itemToString,
      compareItems: compareItems,
      locale: 'en'
    };

    if (selectionFeedback === 'fixed') {
      sortOptions.selectedItems = [];
    } else if (selectionFeedback === 'top-after-reopen') {
      sortOptions.selectedItems = topItems;
    }

    function onStateChange(changes) {
      if (changes.isOpen && !isOpen) {
        setTopItems(controlledSelectedItems);
      }

      var type = changes.type;

      switch (type) {
        case ItemClick$1:
        case MenuKeyDownSpaceButton$1:
        case MenuKeyDownEnter$1:
          onItemChange(changes.selectedItem);
          break;

        case MenuKeyDownArrowDown$1:
        case MenuKeyDownArrowUp$1:
          setHighlightedIndex(changes.highlightedIndex);
          break;

        case MenuBlur$1:
        case MenuKeyDownEscape$1:
          setIsOpen(false);
          setHighlightedIndex(changes.highlightedIndex);
          break;

        case ToggleButtonClick$1:
          setIsOpen(changes.isOpen || false);
          setHighlightedIndex(changes.highlightedIndex);
          break;
      }
    }

    return /*#__PURE__*/React__default.createElement("div", {
      className: wrapperClasses
    }, titleText && /*#__PURE__*/React__default.createElement("label", _extends({
      className: titleClasses
    }, getLabelProps()), titleText), /*#__PURE__*/React__default.createElement(ListBox, {
      type: type,
      size: size,
      className: className,
      disabled: disabled,
      light: light,
      invalid: invalid,
      invalidText: invalidText,
      isOpen: isOpen,
      id: id
    }, invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
      className: "".concat(prefix$1a, "--list-box__invalid-icon")
    }), /*#__PURE__*/React__default.createElement("button", _extends({
      ref: ref,
      className: "".concat(prefix$1a, "--list-box__field"),
      disabled: disabled,
      "aria-disabled": disabled
    }, getToggleButtonProps()), selectedItems.length > 0 && /*#__PURE__*/React__default.createElement(ListBox.Selection, {
      clearSelection: !disabled ? clearSelection : noop$2,
      selectionCount: selectedItems.length,
      translateWithId: translateWithId,
      disabled: disabled
    }), /*#__PURE__*/React__default.createElement("span", {
      id: fieldLabelId,
      className: "".concat(prefix$1a, "--list-box__label")
    }, label), /*#__PURE__*/React__default.createElement(ListBox.MenuIcon, {
      isOpen: isOpen,
      translateWithId: translateWithId
    })), /*#__PURE__*/React__default.createElement(ListBox.Menu, _extends({
      "aria-multiselectable": "true"
    }, getMenuProps()), isOpen && sortItems(items, sortOptions).map(function (item, index) {
      var itemProps = getItemProps({
        item: item
      });
      var itemText = itemToString(item);
      var isChecked = selectedItems.filter(function (selected) {
        return lodash_isequal(selected, item);
      }).length > 0;
      return /*#__PURE__*/React__default.createElement(ListBox.MenuItem, _extends({
        key: itemProps.id,
        isActive: isChecked,
        isHighlighted: highlightedIndex === index,
        title: itemText
      }, itemProps), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$1a, "--checkbox-wrapper")
      }, /*#__PURE__*/React__default.createElement("span", {
        title: useTitleInItem ? itemText : null,
        className: "".concat(prefix$1a, "--checkbox-label"),
        "data-contained-checkbox-state": isChecked,
        id: "".concat(itemProps.id, "__checkbox")
      }, itemText)));
    }))), !inline && !invalid && helperText && /*#__PURE__*/React__default.createElement("div", {
      id: helperId,
      className: helperClasses
    }, helperText));
  });
  MultiSelect.displayName = 'MultiSelect';
  MultiSelect.propTypes = _objectSpread2(_objectSpread2({}, sortingPropTypes), {}, {
    /**
     * Disable the control
     */
    disabled: PropTypes.bool,

    /**
     * Specify a custom `id`
     */
    id: PropTypes.string.isRequired,

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes.array.isRequired,

    /**
     * Allow users to pass in arbitrary items from their collection that are
     * pre-selected
     */
    initialSelectedItems: PropTypes.array,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list.
     */
    itemToString: PropTypes.func,

    /**
     * Generic `label` that will be used as the textual representation of what
     * this field is for
     */
    label: PropTypes.node.isRequired,

    /**
     * Specify the locale of the control. Used for the default `compareItems`
     * used for sorting the list of items in the control.
     */
    locale: PropTypes.string,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component what kind of internal state changes are occuring.
     */
    onChange: PropTypes.func,

    /**
     * Specify 'inline' to create an inline multi-select.
     */
    type: PropTypes.oneOf(['default', 'inline']),

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `lg` or `xl` as an option.
     */
    size: ListBoxSize,

    /**
     * Specify title to show title on hover
     */
    useTitleInItem: PropTypes.bool,

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool,

    /**
     * Is the current selection invalid?
     */
    invalid: PropTypes.bool,

    /**
     * If invalid, what is the error?
     */
    invalidText: PropTypes.string,

    /**
     * Initialize the component with an open(`true`)/closed(`false`) menu.
     */
    open: PropTypes.bool,

    /**
     * Callback function for translating ListBoxMenuIcon SVG title
     */
    translateWithId: PropTypes.func,

    /**
     * Specify feedback (mode) of the selection.
     * `top`: selected item jumps to top
     * `fixed`: selected item stays at it's position
     * `top-after-reopen`: selected item jump to top after reopen dropdown
     */
    selectionFeedback: PropTypes.oneOf(['top', 'fixed', 'top-after-reopen']),

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes.shape(Downshift.propTypes),

    /**
     * Specify the direction of the multiselect dropdown. Can be either top or bottom.
     */
    direction: PropTypes.oneOf(['top', 'bottom'])
  });
  MultiSelect.defaultProps = {
    compareItems: defaultCompareItems,
    disabled: false,
    locale: 'en',
    itemToString: defaultItemToString$2,
    initialSelectedItems: [],
    sortItems: defaultSortItems,
    type: 'default',
    light: false,
    title: false,
    open: false,
    selectionFeedback: 'top-after-reopen',
    direction: 'bottom'
  };

  var defaultFilterItems = function defaultFilterItems(items, _ref) {
    var itemToString = _ref.itemToString,
        inputValue = _ref.inputValue;
    return items.filter(function (item) {
      if (!inputValue) {
        return true;
      }

      return itemToString(item).toLowerCase().includes(inputValue.toLowerCase());
    });
  };

  var prefix$1b = settings_1.prefix;
  var getInstanceId$6 = setupGetInstanceId();

  var FilterableMultiSelect = /*#__PURE__*/function (_React$Component) {
    _inherits(FilterableMultiSelect, _React$Component);

    var _super = _createSuper(FilterableMultiSelect);

    _createClass(FilterableMultiSelect, null, [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var open = _ref.open;

        /**
         * programmatically control this `open` prop
         */
        var prevOpen = state.prevOpen;
        return prevOpen === open ? null : {
          isOpen: open,
          prevOpen: open
        };
      }
    }]);

    function FilterableMultiSelect(props) {
      var _this;

      _classCallCheck(this, FilterableMultiSelect);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "handleOnChange", function (changes) {
        if (_this.props.onChange) {
          _this.props.onChange(changes);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnToggleMenu", function () {
        _this.setState(function (state) {
          return {
            isOpen: !state.isOpen
          };
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnOuterClick", function () {
        _this.setState({
          isOpen: false,
          inputValue: ''
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnStateChange", function (changes, downshift) {
        if (changes.isOpen && !_this.state.isOpen) {
          _this.setState({
            topItems: downshift.selectedItem
          });
        }

        var type = changes.type;

        switch (type) {
          case Downshift.stateChangeTypes.keyDownArrowUp:
          case Downshift.stateChangeTypes.itemMouseEnter:
            _this.setState({
              highlightedIndex: changes.highlightedIndex
            });

            break;

          case Downshift.stateChangeTypes.keyDownArrowDown:
            _this.setState({
              highlightedIndex: changes.highlightedIndex,
              isOpen: true
            });

            break;

          case Downshift.stateChangeTypes.keyDownEscape:
          case Downshift.stateChangeTypes.mouseUp:
            _this.setState({
              isOpen: false
            });

            break;
          // Opt-in to some cases where we should be toggling the menu based on
          // a given key press or mouse handler
          // Reference: https://github.com/paypal/downshift/issues/206

          case Downshift.stateChangeTypes.clickButton:
          case Downshift.stateChangeTypes.keyDownSpaceButton:
            _this.setState(function () {
              var nextIsOpen = changes.isOpen || false;

              if (changes.isOpen === false) {
                // If Downshift is trying to close the menu, but we know the input
                // is the active element in thedocument, then keep the menu open
                if (_this.inputNode === document.activeElement) {
                  nextIsOpen = true;
                }
              }

              return {
                isOpen: nextIsOpen
              };
            });

            break;
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnInputKeyDown", function (event) {
        event.stopPropagation();
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnInputValueChange", function (inputValue, _ref2) {
        var type = _ref2.type;
        if (type === Downshift.stateChangeTypes.changeInput) _this.setState(function () {
          if (Array.isArray(inputValue)) {
            return {
              inputValue: ''
            };
          }

          return {
            inputValue: inputValue || '',
            isOpen: Boolean(inputValue) || _this.state.isOpen
          };
        });
      });

      _defineProperty(_assertThisInitialized(_this), "clearInputValue", function (event) {
        event.stopPropagation();

        _this.setState({
          inputValue: ''
        });

        _this.inputNode && _this.inputNode.focus && _this.inputNode.focus();
      });

      _this.filterableMultiSelectInstanceId = getInstanceId$6();
      _this.state = {
        isOpen: props.open,
        inputValue: '',
        topItems: []
      };
      return _this;
    }

    _createClass(FilterableMultiSelect, [{
      key: "render",
      value: function render() {
        var _cx,
            _this2 = this;

        var _this$state = this.state,
            highlightedIndex = _this$state.highlightedIndex,
            isOpen = _this$state.isOpen,
            inputValue = _this$state.inputValue;
        var _this$props = this.props,
            ariaLabel = _this$props.ariaLabel,
            containerClassName = _this$props.className,
            disabled = _this$props.disabled,
            filterItems = _this$props.filterItems,
            items = _this$props.items,
            itemToString = _this$props.itemToString,
            titleText = _this$props.titleText,
            helperText = _this$props.helperText,
            type = _this$props.type,
            initialSelectedItems = _this$props.initialSelectedItems,
            id = _this$props.id,
            locale = _this$props.locale,
            size = _this$props.size,
            placeholder = _this$props.placeholder,
            sortItems = _this$props.sortItems,
            compareItems = _this$props.compareItems,
            light = _this$props.light,
            invalid = _this$props.invalid,
            invalidText = _this$props.invalidText,
            useTitleInItem = _this$props.useTitleInItem,
            translateWithId = _this$props.translateWithId,
            downshiftProps = _this$props.downshiftProps;
        var inline = type === 'inline';
        var wrapperClasses = classnames("".concat(prefix$1b, "--multi-select__wrapper"), "".concat(prefix$1b, "--list-box__wrapper"), (_cx = {}, _defineProperty(_cx, "".concat(prefix$1b, "--multi-select__wrapper--inline"), inline), _defineProperty(_cx, "".concat(prefix$1b, "--list-box__wrapper--inline"), inline), _defineProperty(_cx, "".concat(prefix$1b, "--multi-select__wrapper--inline--invalid"), inline && invalid), _defineProperty(_cx, "".concat(prefix$1b, "--list-box__wrapper--inline--invalid"), inline && invalid), _cx));
        var helperId = !helperText ? undefined : "filterablemultiselect-helper-text-".concat(this.filterableMultiSelectInstanceId);
        var labelId = "".concat(id, "-label");
        var titleClasses = classnames("".concat(prefix$1b, "--label"), _defineProperty({}, "".concat(prefix$1b, "--label--disabled"), disabled));
        var title = titleText ? /*#__PURE__*/React__default.createElement("label", {
          id: labelId,
          htmlFor: id,
          className: titleClasses
        }, titleText) : null;
        var helperClasses = classnames("".concat(prefix$1b, "--form__helper-text"), _defineProperty({}, "".concat(prefix$1b, "--form__helper-text--disabled"), disabled));
        var helper = helperText ? /*#__PURE__*/React__default.createElement("div", {
          id: helperId,
          className: helperClasses
        }, helperText) : null;
        var inputClasses = classnames("".concat(prefix$1b, "--text-input"), _defineProperty({}, "".concat(prefix$1b, "--text-input--empty"), !this.state.inputValue));
        var input = /*#__PURE__*/React__default.createElement(Selection, {
          disabled: disabled,
          onChange: this.handleOnChange,
          initialSelectedItems: initialSelectedItems,
          render: function render(_ref3) {
            var selectedItems = _ref3.selectedItems,
                onItemChange = _ref3.onItemChange,
                clearSelection = _ref3.clearSelection;
            return /*#__PURE__*/React__default.createElement(Downshift, _extends({}, mapDownshiftProps(downshiftProps), {
              highlightedIndex: highlightedIndex,
              id: id,
              isOpen: isOpen,
              inputValue: inputValue,
              onInputValueChange: _this2.handleOnInputValueChange,
              onChange: function onChange(selectedItem) {
                // `selectedItem`: The item that was just selected. null if the selection was cleared.
                // https://github.com/downshift-js/downshift#onchange
                if (selectedItem === null) {
                  clearSelection();
                  return;
                }

                onItemChange(selectedItem);
              },
              itemToString: itemToString,
              onStateChange: _this2.handleOnStateChange,
              onOuterClick: _this2.handleOnOuterClick,
              selectedItem: selectedItems
            }), function (_ref4) {
              var _cx5;

              var getToggleButtonProps = _ref4.getToggleButtonProps,
                  getInputProps = _ref4.getInputProps,
                  getItemProps = _ref4.getItemProps,
                  getRootProps = _ref4.getRootProps,
                  isOpen = _ref4.isOpen,
                  inputValue = _ref4.inputValue,
                  selectedItem = _ref4.selectedItem;
              var className = classnames("".concat(prefix$1b, "--multi-select"), "".concat(prefix$1b, "--combo-box"), "".concat(prefix$1b, "--multi-select--filterable"), containerClassName, (_cx5 = {}, _defineProperty(_cx5, "".concat(prefix$1b, "--multi-select--invalid"), invalid), _defineProperty(_cx5, "".concat(prefix$1b, "--multi-select--open"), isOpen), _defineProperty(_cx5, "".concat(prefix$1b, "--multi-select--inline"), inline), _defineProperty(_cx5, "".concat(prefix$1b, "--multi-select--selected"), selectedItem.length > 0), _cx5));

              var buttonProps = _objectSpread2(_objectSpread2({}, getToggleButtonProps({
                disabled: disabled
              })), {}, {
                'aria-label': undefined
              });

              return /*#__PURE__*/React__default.createElement(ListBox, _extends({
                className: className,
                disabled: disabled,
                light: light,
                invalid: invalid,
                invalidText: invalidText,
                isOpen: isOpen,
                size: size
              }, getRootProps()), /*#__PURE__*/React__default.createElement(ListBox.Field, _extends({
                id: id,
                disabled: disabled,
                "aria-labelledby": labelId,
                "aria-describedby": helperId
              }, buttonProps), selectedItem.length > 0 && /*#__PURE__*/React__default.createElement(ListBox.Selection, {
                clearSelection: clearSelection,
                selectionCount: selectedItem.length,
                translateWithId: translateWithId,
                disabled: disabled
              }), /*#__PURE__*/React__default.createElement("input", _extends({
                className: inputClasses,
                "aria-controls": "".concat(id, "__menu"),
                "aria-autocomplete": "list",
                ref: function ref(el) {
                  return _this2.inputNode = el;
                }
              }, getInputProps({
                disabled: disabled,
                id: id,
                placeholder: placeholder,
                onKeyDown: _this2.handleOnInputKeyDown
              }))), invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
                className: "".concat(prefix$1b, "--list-box__invalid-icon")
              }), inputValue && isOpen && /*#__PURE__*/React__default.createElement(ListBox.Selection, {
                clearSelection: _this2.clearInputValue,
                disabled: disabled
              }), /*#__PURE__*/React__default.createElement(ListBox.MenuIcon, {
                isOpen: isOpen,
                translateWithId: translateWithId
              })), isOpen && /*#__PURE__*/React__default.createElement(ListBox.Menu, {
                role: "group",
                "aria-label": ariaLabel,
                id: "".concat(id, "-menu")
              }, sortItems(filterItems(items, {
                itemToString: itemToString,
                inputValue: inputValue
              }), {
                selectedItems: {
                  top: selectedItems,
                  fixed: [],
                  'top-after-reopen': _this2.state.topItems
                }[_this2.props.selectionFeedback],
                itemToString: itemToString,
                compareItems: compareItems,
                locale: locale
              }).map(function (item, index) {
                var itemProps = getItemProps({
                  item: item
                });
                var itemText = itemToString(item);
                var isChecked = selectedItem.filter(function (selected) {
                  return lodash_isequal(selected, item);
                }).length > 0;
                return /*#__PURE__*/React__default.createElement(ListBox.MenuItem, _extends({
                  key: itemProps.id,
                  isActive: isChecked,
                  isHighlighted: highlightedIndex === index,
                  title: itemText
                }, itemProps), /*#__PURE__*/React__default.createElement(Checkbox$1, {
                  id: "".concat(itemProps.id, "-item"),
                  title: useTitleInItem ? itemText : null,
                  name: itemText,
                  checked: isChecked,
                  disabled: disabled,
                  readOnly: true,
                  tabIndex: "-1",
                  labelText: itemText
                }));
              })));
            });
          }
        });
        return /*#__PURE__*/React__default.createElement("div", {
          className: wrapperClasses
        }, title, input, !inline && !invalid ? helper : null);
      }
    }]);

    return FilterableMultiSelect;
  }(React__default.Component);

  _defineProperty(FilterableMultiSelect, "propTypes", _objectSpread2(_objectSpread2({}, sortingPropTypes), {}, {
    /**
     * 'aria-label' of the ListBox component.
     */
    ariaLabel: PropTypes.string,

    /**
     * Disable the control
     */
    disabled: PropTypes.bool,

    /**
     * Specify a custom `id`
     */
    id: PropTypes.string.isRequired,

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes.array.isRequired,

    /**
     * Allow users to pass in arbitrary items from their collection that are
     * pre-selected
     */
    initialSelectedItems: PropTypes.array,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list.
     */
    itemToString: PropTypes.func,

    /**
     * Specify the locale of the control. Used for the default `compareItems`
     * used for sorting the list of items in the control.
     */
    locale: PropTypes.string,

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `lg` or `xl` as an option.
     */
    size: ListBoxSize,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component what kind of internal state changes are occuring.
     */
    onChange: PropTypes.func,

    /**
     * Generic `placeholder` that will be used as the textual representation of
     * what this field is for
     */
    placeholder: PropTypes.string.isRequired,

    /**
     * Specify title to show title on hover
     */
    useTitleInItem: PropTypes.bool,

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool,

    /**
     * Is the current selection invalid?
     */
    invalid: PropTypes.bool,

    /**
     * If invalid, what is the error?
     */
    invalidText: PropTypes.string,

    /**
     * Initialize the component with an open(`true`)/closed(`false`) menu.
     */
    open: PropTypes.bool,

    /**
     * Specify feedback (mode) of the selection.
     * `top`: selected item jumps to top
     * `fixed`: selected item stays at it's position
     * `top-after-reopen`: selected item jump to top after reopen dropdown
     */
    selectionFeedback: PropTypes.oneOf(['top', 'fixed', 'top-after-reopen']),

    /**
     * Callback function for translating ListBoxMenuIcon SVG title
     */
    translateWithId: PropTypes.func,

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes.shape(Downshift.propTypes)
  }));

  _defineProperty(FilterableMultiSelect, "defaultProps", {
    ariaLabel: 'Choose an item',
    compareItems: defaultCompareItems,
    disabled: false,
    filterItems: defaultFilterItems,
    initialSelectedItems: [],
    itemToString: defaultItemToString$2,
    locale: 'en',
    sortItems: defaultSortItems,
    light: false,
    open: false,
    selectionFeedback: 'top-after-reopen'
  });

  FilterableMultiSelect.displayName = 'MultiSelect.Filterable';
  MultiSelect.Filterable = FilterableMultiSelect;

  var _iconTypes;
  var prefix$1c = settings_1.prefix;
  function NotificationActionButton(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        onClick = _ref.onClick,
        rest = _objectWithoutProperties(_ref, ["children", "className", "onClick"]);

    var className = classnames(customClassName, "".concat(prefix$1c, "--inline-notification__action-button"));
    return /*#__PURE__*/React__default.createElement(Button, _extends({
      className: className,
      kind: "ghost",
      onClick: onClick,
      size: "small"
    }, rest), children);
  }
  NotificationActionButton.propTypes = {
    /**
     * Specify an optional className to be applied to the notification action button
     */
    className: PropTypes.string,

    /**
     * Specify the content of the notification action button.
     */
    children: PropTypes.node,

    /**
     * Optionally specify a click handler for the notification action button.
     */
    onClick: PropTypes.func
  };
  function NotificationButton(_ref2) {
    var ariaLabel = _ref2.ariaLabel,
        className = _ref2.className,
        iconDescription = _ref2.iconDescription,
        type = _ref2.type,
        IconTag = _ref2.renderIcon,
        name = _ref2.name,
        notificationType = _ref2.notificationType,
        rest = _objectWithoutProperties(_ref2, ["ariaLabel", "className", "iconDescription", "type", "renderIcon", "name", "notificationType"]);

    var buttonClassName = classnames(className, _defineProperty({}, "".concat(prefix$1c, "--").concat(notificationType, "-notification__close-button"), notificationType));
    var iconClassName = classnames(_defineProperty({}, "".concat(prefix$1c, "--").concat(notificationType, "-notification__close-icon"), notificationType));
    return /*#__PURE__*/React__default.createElement("button", _extends({}, rest, {
      type: type,
      "aria-label": iconDescription,
      title: iconDescription,
      className: buttonClassName
    }), IconTag && /*#__PURE__*/React__default.createElement(IconTag, {
      "aria-label": ariaLabel,
      className: iconClassName,
      name: name
    }));
  }
  NotificationButton.propTypes = {
    /**
     * Specify an optional className to be applied to the notification button
     */
    className: PropTypes.string,

    /**
     * Specify a label to be read by screen readers on the notification button
     */
    ariaLabel: PropTypes.string,

    /**
     * Optional prop to specify the type of the Button
     */
    type: PropTypes.string,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes.string,

    /**
     * Optional prop to allow overriding the icon rendering.
     * Can be a React component class
     */
    renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),

    /**
     * Specify an optional icon for the Button through a string,
     * if something but regular "close" icon is desirable
     */
    name: PropTypes.string,

    /**
     * Specify the notification type
     */
    notificationType: PropTypes.oneOf(['toast', 'inline'])
  };
  NotificationButton.defaultProps = {
    ariaLabel: 'close notification',
    // TODO: deprecate this prop
    notificationType: 'toast',
    type: 'button',
    iconDescription: 'close icon',
    renderIcon: Close20
  };
  function NotificationTextDetails(_ref3) {
    var title = _ref3.title,
        subtitle = _ref3.subtitle,
        caption = _ref3.caption,
        notificationType = _ref3.notificationType,
        children = _ref3.children,
        rest = _objectWithoutProperties(_ref3, ["title", "subtitle", "caption", "notificationType", "children"]);

    if (notificationType === 'toast') {
      return /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
        className: "".concat(prefix$1c, "--toast-notification__details")
      }), /*#__PURE__*/React__default.createElement("h3", {
        className: "".concat(prefix$1c, "--toast-notification__title")
      }, title), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$1c, "--toast-notification__subtitle")
      }, subtitle), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$1c, "--toast-notification__caption")
      }, caption), children);
    }

    if (notificationType === 'inline') {
      return /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
        className: "".concat(prefix$1c, "--inline-notification__text-wrapper")
      }), /*#__PURE__*/React__default.createElement("p", {
        className: "".concat(prefix$1c, "--inline-notification__title")
      }, title), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$1c, "--inline-notification__subtitle")
      }, subtitle), children);
    }
  }
  NotificationTextDetails.propTypes = {
    /**
     * Pass in the children that will be rendered in NotificationTextDetails
     */
    children: PropTypes.node,

    /**
     * Specify the title
     */
    title: PropTypes.string,

    /**
     * Specify the sub-title
     */
    subtitle: PropTypes.node,

    /**
     * Specify the caption
     */
    caption: PropTypes.node,

    /**
     * Specify the notification type
     */
    notificationType: PropTypes.oneOf(['toast', 'inline'])
  };
  NotificationTextDetails.defaultProps = {
    title: 'title',
    caption: 'caption',
    notificationType: 'toast'
  };
  var iconTypes = (_iconTypes = {
    error: ErrorFilled20,
    success: CheckmarkFilled20,
    warning: WarningFilled20
  }, _defineProperty(_iconTypes, 'warning-alt', WarningAltFilled20), _defineProperty(_iconTypes, "info", InformationFilled20), _defineProperty(_iconTypes, 'info-square', InformationSquareFilled20), _iconTypes);

  function NotificationIcon(_ref4) {
    var iconDescription = _ref4.iconDescription,
        kind = _ref4.kind,
        notificationType = _ref4.notificationType;
    var IconForKind = iconTypes[kind];

    if (!IconForKind) {
      return null;
    }

    return /*#__PURE__*/React__default.createElement(IconForKind, {
      className: "".concat(prefix$1c, "--").concat(notificationType, "-notification__icon")
    }, /*#__PURE__*/React__default.createElement("title", null, iconDescription));
  }

  NotificationIcon.propTypes = {
    notificationType: PropTypes.oneOf(['inline', 'toast']).isRequired,
    kind: PropTypes.oneOf(['error', 'success', 'warning', 'warning-alt', 'info', 'info-square']).isRequired,
    iconDescription: PropTypes.string.isRequired
  };
  function ToastNotification(_ref5) {
    var _cx3;

    var role = _ref5.role,
        notificationType = _ref5.notificationType,
        onCloseButtonClick = _ref5.onCloseButtonClick,
        iconDescription = _ref5.iconDescription,
        statusIconDescription = _ref5.statusIconDescription,
        className = _ref5.className,
        caption = _ref5.caption,
        subtitle = _ref5.subtitle,
        title = _ref5.title,
        kind = _ref5.kind,
        lowContrast = _ref5.lowContrast,
        hideCloseButton = _ref5.hideCloseButton,
        children = _ref5.children,
        timeout = _ref5.timeout,
        rest = _objectWithoutProperties(_ref5, ["role", "notificationType", "onCloseButtonClick", "iconDescription", "statusIconDescription", "className", "caption", "subtitle", "title", "kind", "lowContrast", "hideCloseButton", "children", "timeout"]);

    var _useState = React.useState(true),
        _useState2 = _slicedToArray(_useState, 2),
        isOpen = _useState2[0],
        setIsOpen = _useState2[1];

    var containerClassName = classnames(className, (_cx3 = {}, _defineProperty(_cx3, "".concat(prefix$1c, "--toast-notification"), true), _defineProperty(_cx3, "".concat(prefix$1c, "--toast-notification--low-contrast"), lowContrast), _defineProperty(_cx3, "".concat(prefix$1c, "--toast-notification--").concat(kind), kind), _cx3));

    function handleCloseButtonClick(event) {
      setIsOpen(false);
      onCloseButtonClick(event);
    }

    React.useEffect(function () {
      if (!timeout) {
        return;
      }

      var timeoutId = window.setTimeout(function () {
        setIsOpen(false);
        onCloseButtonClick(event);
      }, timeout);
      return function () {
        window.clearTimeout(timeoutId);
      };
    }, [onCloseButtonClick, timeout]);

    if (!isOpen) {
      return null;
    }

    return /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
      role: role,
      kind: kind,
      className: containerClassName
    }), /*#__PURE__*/React__default.createElement(NotificationIcon, {
      notificationType: notificationType,
      kind: kind,
      iconDescription: statusIconDescription || "".concat(kind, " icon")
    }), /*#__PURE__*/React__default.createElement(NotificationTextDetails, {
      title: title,
      subtitle: subtitle,
      caption: caption,
      notificationType: notificationType
    }, children), !hideCloseButton && /*#__PURE__*/React__default.createElement(NotificationButton, {
      iconDescription: iconDescription,
      notificationType: notificationType,
      onClick: handleCloseButtonClick
    }));
  }
  ToastNotification.propTypes = {
    /**
     * Pass in the children that will be rendered within the ToastNotification
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the notification box
     */
    className: PropTypes.string,

    /**
     * Specify what state the notification represents
     */
    kind: PropTypes.oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']).isRequired,

    /**
     * Specify whether you are using the low contrast variant of the ToastNotification.
     */
    lowContrast: PropTypes.bool,

    /**
     * Specify the title
     */
    title: PropTypes.string.isRequired,

    /**
     * Specify the sub-title
     */
    subtitle: PropTypes.node,

    /**
     * By default, this value is "alert". You can also provide an alternate
     * role if it makes sense from the accessibility-side
     */
    role: PropTypes.string.isRequired,

    /**
     * Specify the caption
     */
    caption: PropTypes.node,

    /**
     * Provide a function that is called when menu is closed
     */
    onCloseButtonClick: PropTypes.func,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes.string,

    /**
     * Provide a description for "status" icon that can be read by screen readers
     */
    statusIconDescription: PropTypes.string,

    /**
     * By default, this value is "toast". You can also provide an alternate type
     * if it makes sense for the underlying `<NotificationTextDetails>` and `<NotificationButton>`
     */
    notificationType: PropTypes.string,

    /**
     * Specify the close button should be disabled, or not
     */
    hideCloseButton: PropTypes.bool,

    /**
     * Specify an optional duration the notification should be closed in
     */
    timeout: PropTypes.number
  };
  ToastNotification.defaultProps = {
    kind: 'error',
    title: 'provide a title',
    caption: 'provide a caption',
    role: 'alert',
    notificationType: 'toast',
    iconDescription: 'closes notification',
    onCloseButtonClick: function onCloseButtonClick() {},
    hideCloseButton: false,
    timeout: 0
  };
  function InlineNotification(_ref6) {
    var _cx4;

    var actions = _ref6.actions,
        role = _ref6.role,
        notificationType = _ref6.notificationType,
        onCloseButtonClick = _ref6.onCloseButtonClick,
        iconDescription = _ref6.iconDescription,
        statusIconDescription = _ref6.statusIconDescription,
        className = _ref6.className,
        subtitle = _ref6.subtitle,
        title = _ref6.title,
        kind = _ref6.kind,
        lowContrast = _ref6.lowContrast,
        hideCloseButton = _ref6.hideCloseButton,
        children = _ref6.children,
        rest = _objectWithoutProperties(_ref6, ["actions", "role", "notificationType", "onCloseButtonClick", "iconDescription", "statusIconDescription", "className", "subtitle", "title", "kind", "lowContrast", "hideCloseButton", "children"]);

    var _useState3 = React.useState(true),
        _useState4 = _slicedToArray(_useState3, 2),
        isOpen = _useState4[0],
        setIsOpen = _useState4[1];

    var containerClassName = classnames(className, (_cx4 = {}, _defineProperty(_cx4, "".concat(prefix$1c, "--inline-notification"), true), _defineProperty(_cx4, "".concat(prefix$1c, "--inline-notification--low-contrast"), lowContrast), _defineProperty(_cx4, "".concat(prefix$1c, "--inline-notification--").concat(kind), kind), _defineProperty(_cx4, "".concat(prefix$1c, "--inline-notification--hide-close-button"), hideCloseButton), _cx4));

    function handleCloseButtonClick(event) {
      setIsOpen(false);
      onCloseButtonClick(event);
    }

    if (!isOpen) {
      return null;
    }

    return /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
      role: role,
      kind: kind,
      className: containerClassName
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1c, "--inline-notification__details")
    }, /*#__PURE__*/React__default.createElement(NotificationIcon, {
      notificationType: notificationType,
      kind: kind,
      iconDescription: statusIconDescription || "".concat(kind, " icon")
    }), /*#__PURE__*/React__default.createElement(NotificationTextDetails, {
      title: title,
      subtitle: subtitle,
      notificationType: notificationType
    }, children)), actions, !hideCloseButton && /*#__PURE__*/React__default.createElement(NotificationButton, {
      iconDescription: iconDescription,
      notificationType: notificationType,
      onClick: handleCloseButtonClick
    }));
  }
  InlineNotification.propTypes = {
    /**
     * Pass in the action nodes that will be rendered within the InlineNotification
     */
    actions: PropTypes.node,

    /**
     * Pass in the children that will be rendered within the InlineNotification
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the notification box
     */
    className: PropTypes.string,

    /**
     * Specify what state the notification represents
     */
    kind: PropTypes.oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']).isRequired,

    /**
     * Specify whether you are using the low contrast variant of the InlineNotification.
     */
    lowContrast: PropTypes.bool,

    /**
     * Specify the title
     */
    title: PropTypes.string.isRequired,

    /**
     * Specify the sub-title
     */
    subtitle: PropTypes.node,

    /**
     * By default, this value is "alert". You can also provide an alternate
     * role if it makes sense from the accessibility-side
     */
    role: PropTypes.string.isRequired,

    /**
     * Provide a function that is called when menu is closed
     */
    onCloseButtonClick: PropTypes.func,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes.string,

    /**
     * Provide a description for "status" icon that can be read by screen readers
     */
    statusIconDescription: PropTypes.string,

    /**
     * By default, this value is "inline". You can also provide an alternate type
     * if it makes sense for the underlying `<NotificationTextDetails>` and `<NotificationButton>`
     */
    notificationType: PropTypes.string,

    /**
     * Specify the close button should be disabled, or not
     */
    hideCloseButton: PropTypes.bool
  };
  InlineNotification.defaultProps = {
    role: 'alert',
    notificationType: 'inline',
    iconDescription: 'closes notification',
    onCloseButtonClick: function onCloseButtonClick() {},
    hideCloseButton: false
  };

  var prefix$1d = settings_1.prefix;

  var NumberInputSkeleton = function NumberInputSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["hideLabel", "className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$1d, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1d, "--label ").concat(prefix$1d, "--skeleton")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1d, "--number ").concat(prefix$1d, "--skeleton")
    }));
  };

  NumberInputSkeleton.propTypes = {
    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes.string
  };

  var _defaultTranslations$3;
  var prefix$1e = settings_1.prefix;
  var translationIds$2 = {
    'increment.number': 'increment.number',
    'decrement.number': 'decrement.number'
  };
  var defaultTranslations$3 = (_defaultTranslations$3 = {}, _defineProperty(_defaultTranslations$3, translationIds$2['increment.number'], 'Increment number'), _defineProperty(_defaultTranslations$3, translationIds$2['decrement.number'], 'Decrement number'), _defaultTranslations$3);

  var capMin = function capMin(min, value) {
    return isNaN(min) || !min && min !== 0 || isNaN(value) || !value && value !== 0 ? value : Math.max(min, value);
  };

  var capMax = function capMax(max, value) {
    return isNaN(max) || !max && max !== 0 || isNaN(value) || !value && value !== 0 ? value : Math.min(max, value);
  };

  var NumberInput$1 = /*#__PURE__*/function (_Component) {
    _inherits(NumberInput, _Component);

    var _super = _createSuper(NumberInput);

    _createClass(NumberInput, null, [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var min = _ref.min,
            max = _ref.max,
            _ref$value = _ref.value,
            value = _ref$value === void 0 ? 0 : _ref$value;
        var prevValue = state.prevValue;
        // Otherwise, do prop -> state sync with "value capping".


        return  prevValue === value ? null : {
          value: capMax(max, capMin(min, value)),
          prevValue: value
        };
      }
      /**
       * The DOM node reference to the `<input>`.
       * @type {HTMLInputElement}
       */

    }]);

    function NumberInput(props) {
      var _this;

      _classCallCheck(this, NumberInput);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "_inputRef", null);

      _defineProperty(_assertThisInitialized(_this), "handleChange", function (evt) {
        var _this$props = _this.props,
            disabled = _this$props.disabled,
            onChange = _this$props.onChange;

        if (!disabled) {
          evt.persist();
          evt.imaginaryTarget = _this._inputRef;
          var value = evt.target.value;

          _this.setState({
            value: value
          }, function () {
            if (onChange) {
              onChange(evt);
            }
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleArrowClick", function (evt, direction) {
        var value = typeof _this.state.value === 'string' ? Number(_this.state.value) : _this.state.value;
        var _this$props2 = _this.props,
            disabled = _this$props2.disabled,
            min = _this$props2.min,
            max = _this$props2.max,
            step = _this$props2.step,
            onChange = _this$props2.onChange,
            onClick = _this$props2.onClick;
        var conditional = direction === 'down' ? min !== undefined && value > min || min === undefined : max !== undefined && value < max || max === undefined;

        if (!disabled && conditional) {
          value = direction === 'down' ? value - step : value + step;
          value = capMax(max, capMin(min, value));
          evt.persist();
          evt.imaginaryTarget = _this._inputRef;

          _this.setState({
            value: value
          }, function () {
            {
              onClick && onClick(evt, direction);
              onChange && onChange(evt, direction);
            }
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_handleInputRef", function (ref) {
        _this._inputRef = ref;
      });

      _this.isControlled = props.value !== undefined;

      var _value =  props.value;

      _value = _value === undefined ? 0 : _value;

      if (props.min || props.min === 0) {
        _value = Math.max(props.min, _value);
      }

      _this.state = {
        value: _value
      };
      return _this;
    }

    _createClass(NumberInput, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this2 = this;

        var _this$props3 = this.props,
            className = _this$props3.className,
            disabled = _this$props3.disabled,
            iconDescription = _this$props3.iconDescription,
            id = _this$props3.id,
            hideLabel = _this$props3.hideLabel,
            label = _this$props3.label,
            max = _this$props3.max,
            min = _this$props3.min,
            step = _this$props3.step,
            value = _this$props3.value,
            readOnly = _this$props3.readOnly,
            invalid = _this$props3.invalid,
            invalidText = _this$props3.invalidText,
            helperText = _this$props3.helperText,
            ariaLabel = _this$props3.ariaLabel,
            light = _this$props3.light,
            allowEmpty = _this$props3.allowEmpty,
            ref = _this$props3.innerRef,
            t = _this$props3.translateWithId,
            isMobile = _this$props3.isMobile,
            size = _this$props3.size,
            other = _objectWithoutProperties(_this$props3, ["className", "disabled", "iconDescription", "id", "hideLabel", "label", "max", "min", "step", "value", "readOnly", "invalid", "invalidText", "helperText", "ariaLabel", "light", "allowEmpty", "innerRef", "translateWithId", "isMobile", "size"]);

        var numberInputClasses = classnames("".concat(prefix$1e, "--number ").concat(prefix$1e, "--number--helpertext"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1e, "--number--readonly"), readOnly), _defineProperty(_classNames, "".concat(prefix$1e, "--number--light"), light), _defineProperty(_classNames, "".concat(prefix$1e, "--number--nolabel"), hideLabel), _defineProperty(_classNames, "".concat(prefix$1e, "--number--mobile"), isMobile), _defineProperty(_classNames, "".concat(prefix$1e, "--number--").concat(size), size), _classNames));
        var props = {
          disabled: disabled,
          id: id,
          max: max,
          min: min,
          step: step,
          onChange: this.handleChange,
          value:  this.state.value,
          readOnly: readOnly,
          'aria-label': label ? null : ariaLabel
        };
        var buttonProps = {
          disabled: disabled,
          type: 'button'
        };
        var inputWrapperProps = {};
        var errorId = null;
        var error = null;
        var isInputInvalid; // If the user supplied `invalid` through props, we'll defer to the passed in value

        if (invalid) {
          isInputInvalid = true;
        } else {
          // Otherwise, if we don't allow an empty value then we check to see
          // if the value is empty, or if it is out of range
          if (!allowEmpty && this.state.value === '') {
            isInputInvalid = true;
          } else {
            if (this.state.value !== '' && (this.state.value > max || this.state.value < min)) {
              isInputInvalid = true;
            }
          }
        }

        if (isInputInvalid) {
          inputWrapperProps['data-invalid'] = true;
          errorId = "".concat(id, "-error-id");
          error = /*#__PURE__*/React__default.createElement("div", {
            className: "".concat(prefix$1e, "--form-requirement"),
            id: errorId
          }, invalidText);
        }

        var helper = helperText ? /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1e, "--form__helper-text")
        }, helperText) : null;
        var labelClasses = classnames("".concat(prefix$1e, "--label"), _defineProperty({}, "".concat(prefix$1e, "--visually-hidden"), hideLabel));
        var labelText = label ? /*#__PURE__*/React__default.createElement("label", {
          htmlFor: id,
          className: labelClasses
        }, label) : null;
        var _ref2 = [t('increment.number'), t('decrement.number')],
            incrementNumLabel = _ref2[0],
            decrementNumLabel = _ref2[1];
        return /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1e, "--form-item")
        }, /*#__PURE__*/React__default.createElement("div", _extends({
          className: numberInputClasses
        }, inputWrapperProps), function () {
          if (isMobile) {
            return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, labelText, helper, /*#__PURE__*/React__default.createElement("div", {
              className: "".concat(prefix$1e, "--number__input-wrapper")
            }, /*#__PURE__*/React__default.createElement("button", _extends({
              className: "".concat(prefix$1e, "--number__control-btn down-icon")
            }, buttonProps, {
              onClick: function onClick(evt) {
                return _this2.handleArrowClick(evt, 'down');
              },
              title: decrementNumLabel,
              "aria-label": decrementNumLabel || iconDescription,
              "aria-live": "polite",
              "aria-atomic": "true"
            }), /*#__PURE__*/React__default.createElement(CaretDownGlyph, {
              className: "down-icon"
            })), /*#__PURE__*/React__default.createElement("input", _extends({
              type: "number",
              pattern: "[0-9]*"
            }, other, props, {
              ref: mergeRefs(ref, _this2._handleInputRef)
            })), /*#__PURE__*/React__default.createElement("button", _extends({
              className: "".concat(prefix$1e, "--number__control-btn up-icon")
            }, buttonProps, {
              onClick: function onClick(evt) {
                return _this2.handleArrowClick(evt, 'up');
              },
              title: incrementNumLabel,
              "aria-label": incrementNumLabel || iconDescription,
              "aria-live": "polite",
              "aria-atomic": "true"
            }), /*#__PURE__*/React__default.createElement(CaretUpGlyph, {
              className: "up-icon"
            }))));
          }

          return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, labelText, /*#__PURE__*/React__default.createElement("div", {
            className: "".concat(prefix$1e, "--number__input-wrapper")
          }, /*#__PURE__*/React__default.createElement("input", _extends({
            "data-invalid": isInputInvalid,
            "aria-invalid": isInputInvalid,
            "aria-describedby": errorId,
            type: "number",
            pattern: "[0-9]*"
          }, other, props, {
            ref: mergeRefs(ref, _this2._handleInputRef)
          })), isInputInvalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
            className: "".concat(prefix$1e, "--number__invalid")
          }), /*#__PURE__*/React__default.createElement("div", {
            className: "".concat(prefix$1e, "--number__controls")
          }, /*#__PURE__*/React__default.createElement("button", _extends({
            className: "".concat(prefix$1e, "--number__control-btn up-icon")
          }, buttonProps, {
            onClick: function onClick(evt) {
              return _this2.handleArrowClick(evt, 'up');
            },
            title: incrementNumLabel || iconDescription,
            "aria-label": incrementNumLabel || iconDescription,
            "aria-live": "polite",
            "aria-atomic": "true"
          }), /*#__PURE__*/React__default.createElement(CaretUpGlyph, {
            className: "up-icon"
          })), /*#__PURE__*/React__default.createElement("button", _extends({
            className: "".concat(prefix$1e, "--number__control-btn down-icon")
          }, buttonProps, {
            onClick: function onClick(evt) {
              return _this2.handleArrowClick(evt, 'down');
            },
            title: decrementNumLabel || iconDescription,
            "aria-label": decrementNumLabel || iconDescription,
            "aria-live": "polite",
            "aria-atomic": "true"
          }), /*#__PURE__*/React__default.createElement(CaretDownGlyph, {
            className: "down-icon"
          })))), isInputInvalid ? null : helper);
        }(), error));
      }
    }]);

    return NumberInput;
  }(React.Component);

  _defineProperty(NumberInput$1, "propTypes", {
    /**
     * Specify an optional className to be applied to the wrapper node
     */
    className: PropTypes.string,

    /**
     * Specify if the control should be disabled, or not
     */
    disabled: PropTypes.bool,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes.bool,

    /**
     * Provide a description for up/down icons that can be read by screen readers
     */
    iconDescription: PropTypes.string.isRequired,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes.string.isRequired,

    /**
     * Generic `label` that will be used as the textual representation of what
     * this field is for
     */
    label: PropTypes.node,

    /**
     * The maximum value.
     */
    max: PropTypes.number,

    /**
     * The minimum value.
     */
    min: PropTypes.number,

    /**
     * The new value is available in 'imaginaryTarget.value'
     * i.e. to get the value: evt.imaginaryTarget.value
     *
     * * _With_ `useControlledStateWithValue` feature flag, the signature of the event handler will be altered to provide additional context in the second parameter: `onChange(event, { value, direction })` where:
     *   * `event` is the (React) raw event
     *   * `value` is the new value
     *   * `direction` tells you the button you hit is up button or down button
     * * _Without_ this feature flag the event handler has `onChange(event, direction)` signature.
     */
    onChange:  PropTypes.func ,

    /**
     * Provide an optional function to be called when the up/down button is clicked
     */
    onClick: PropTypes.func,

    /**
     * Specify how much the valus should increase/decrease upon clicking on up/down button
     */
    step: PropTypes.number,

    /**
     * Optional starting value for uncontrolled state
     */
    defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Specify the value of the input
     */
    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Specify if the component should be read-only
     */
    readOnly: PropTypes.bool,

    /**
     * Specify if the currently value is invalid.
     */
    invalid: PropTypes.bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes.string,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes.node,

    /**
     * Provide a description that would be used to best describe the use case of the NumberInput component
     */
    ariaLabel: PropTypes.string,

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool,

    /**
     * `true` to allow empty string.
     */
    allowEmpty: PropTypes.bool,

    /**
     * Provide custom text for the component for each translation id
     */
    translateWithId: PropTypes.func.isRequired,

    /**
     * `true` to use the mobile variant.
     */
    isMobile: PropTypes.bool,

    /**
     * Specify the size of the Number Input. Currently supports either `sm` or `xl` as an option.
     */
    size: PropTypes.oneOf(['sm', 'xl'])
  });

  _defineProperty(NumberInput$1, "defaultProps", {
    disabled: false,
    hideLabel: false,
    iconDescription: 'choose a number',
    step: 1,
    invalid: false,
    invalidText: 'Provide invalidText',
    ariaLabel: 'Numeric input field with increment and decrement buttons',
    helperText: '',
    light: false,
    allowEmpty: false,
    translateWithId: function translateWithId(id) {
      return defaultTranslations$3[id];
    }
  });

  var NumberInput$2 = (function () {
    var forwardRef = function forwardRef(props, ref) {
      return /*#__PURE__*/React__default.createElement(NumberInput$1, _extends({}, props, {
        innerRef: ref
      }));
    };

    forwardRef.displayName = 'NumberInput';
    return /*#__PURE__*/React__default.forwardRef(forwardRef);
  })();

  var prefix$1f = settings_1.prefix;

  var OrderedList = function OrderedList(_ref) {
    var children = _ref.children,
        className = _ref.className,
        nested = _ref.nested,
        other = _objectWithoutProperties(_ref, ["children", "className", "nested"]);

    var classNames = classnames("".concat(prefix$1f, "--list--ordered"), className, _defineProperty({}, "".concat(prefix$1f, "--list--nested"), nested));
    return /*#__PURE__*/React__default.createElement("ol", _extends({
      className: classNames
    }, other), children);
  };

  OrderedList.propTypes = {
    /**
     * Provide list items to be rendered in the ordered list
     */
    children: PropTypes.node,

    /**
     * Provide an optional className to be applied to the containing <ol> node
     */
    className: PropTypes.string,

    /**
     * Specify whether this ordered list is nested inside of another nested list
     */
    nested: PropTypes.bool
  };
  OrderedList.defaultProps = {
    nested: false
  };

  var prefix$1g = settings_1.prefix;

  function PaginationSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$1g, "--pagination"), "".concat(prefix$1g, "--skeleton"), className)
    }, rest), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1g, "--pagination__left")
    }, /*#__PURE__*/React__default.createElement(SkeletonText, {
      width: "70px"
    }), /*#__PURE__*/React__default.createElement(SkeletonText, {
      width: "35px"
    }), /*#__PURE__*/React__default.createElement(SkeletonText, {
      width: "105px"
    })), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1g, "--pagination__right ").concat(prefix$1g, "--pagination--inline")
    }, /*#__PURE__*/React__default.createElement(SkeletonText, {
      width: "70px"
    })));
  }

  PaginationSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$1h = settings_1.prefix;

  var SelectSkeleton = function SelectSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["hideLabel", "className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$1h, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1h, "--label ").concat(prefix$1h, "--skeleton")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1h, "--select ").concat(prefix$1h, "--skeleton")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1h, "--select-input")
    })));
  };

  SelectSkeleton.propTypes = {
    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes.string
  };

  var prefix$1i = settings_1.prefix;
  var Select = /*#__PURE__*/React__default.forwardRef(function Select(_ref, ref) {
    var _classNames, _classNames2, _classNames3;

    var className = _ref.className,
        id = _ref.id,
        inline = _ref.inline,
        labelText = _ref.labelText,
        disabled = _ref.disabled,
        children = _ref.children,
        noLabel = _ref.noLabel,
        iconDescription = _ref.iconDescription,
        hideLabel = _ref.hideLabel,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        helperText = _ref.helperText,
        light = _ref.light,
        size = _ref.size,
        other = _objectWithoutProperties(_ref, ["className", "id", "inline", "labelText", "disabled", "children", "noLabel", "iconDescription", "hideLabel", "invalid", "invalidText", "helperText", "light", "size"]);

    var selectClasses = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1i, "--select"), true), _defineProperty(_classNames, "".concat(prefix$1i, "--select--inline"), inline), _defineProperty(_classNames, "".concat(prefix$1i, "--select--light"), light), _defineProperty(_classNames, "".concat(prefix$1i, "--select--invalid"), invalid), _defineProperty(_classNames, "".concat(prefix$1i, "--select--disabled"), disabled), _defineProperty(_classNames, className, className), _classNames));
    var labelClasses = classnames("".concat(prefix$1i, "--label"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$1i, "--visually-hidden"), hideLabel), _defineProperty(_classNames2, "".concat(prefix$1i, "--label--disabled"), disabled), _classNames2));
    var inputClasses = classnames((_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$1i, "--select-input"), true), _defineProperty(_classNames3, "".concat(prefix$1i, "--select-input--").concat(size), size), _classNames3));
    var errorId = "".concat(id, "-error-msg");
    var error = invalid ? /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1i, "--form-requirement"),
      id: errorId
    }, invalidText) : null;
    var helperTextClasses = classnames("".concat(prefix$1i, "--form__helper-text"), _defineProperty({}, "".concat(prefix$1i, "--form__helper-text--disabled"), disabled));
    var helper = helperText ? /*#__PURE__*/React__default.createElement("div", {
      className: helperTextClasses
    }, helperText) : null;
    var ariaProps = {};

    if (invalid) {
      ariaProps['aria-describedby'] = errorId;
    }

    var input = function () {
      return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("select", _extends({}, other, ariaProps, {
        id: id,
        className: inputClasses,
        disabled: disabled || undefined,
        "aria-invalid": invalid || undefined,
        ref: ref
      }), children), /*#__PURE__*/React__default.createElement(ChevronDown16, {
        className: "".concat(prefix$1i, "--select__arrow")
      }), invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
        className: "".concat(prefix$1i, "--select__invalid-icon")
      }));
    }();

    return /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1i, "--form-item")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: selectClasses
    }, !noLabel && /*#__PURE__*/React__default.createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText), inline && /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1i, "--select-input--inline__wrapper")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1i, "--select-input__wrapper"),
      "data-invalid": invalid || null
    }, input), error), !inline && /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1i, "--select-input__wrapper"),
      "data-invalid": invalid || null
    }, input), !inline && error ? error : helper));
  });
  Select.displayName = 'Select';
  Select.propTypes = {
    /**
     * Provide the contents of your Select
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the node containing the label and the select box
     */
    className: PropTypes.string,

    /**
     * Specify a custom `id` for the `<select>`
     */
    id: PropTypes.string.isRequired,

    /**
     * Specify whether you want the inline version of this control
     */
    inline: PropTypes.bool,

    /**
     * Provide label text to be read by screen readers when interacting with the
     * control
     */
    labelText: PropTypes.node,

    /**
     * Provide an optional `onChange` hook that is called each time the value of
     * the underlying <input> changes
     */
    onChange: PropTypes.func,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Optionally provide the default value of the `<select>`
     */
    defaultValue: PropTypes.any,

    /**
     * Provide a description for the twistie icon that can be read by screen readers
     */
    iconDescription: deprecate(PropTypes.string, 'The `iconDescription` prop for `Select` is no longer needed and has ' + 'been deprecated. It will be moved in the next major release.'),

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify if the currently value is invalid.
     */
    invalid: PropTypes.bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes.string,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes.node,

    /**
     * Specify whether you want the light version of this control
     */
    light: PropTypes.bool,

    /**
     * Reserved for use with <Pagination> component. Will not render a label for the
     * select since Pagination renders one for us.
     */
    noLabel: PropTypes.bool,

    /**
     * Specify the size of the Select Input. Currently supports either `sm` or `xl` as an option.
     */
    size: PropTypes.oneOf(['sm', 'xl'])
  };
  Select.defaultProps = {
    disabled: false,
    labelText: 'Select',
    inline: false,
    invalid: false,
    invalidText: '',
    helperText: '',
    light: false
  };

  var prefix$1j = settings_1.prefix;

  var SelectItem = function SelectItem(_ref) {
    var _classNames;

    var className = _ref.className,
        value = _ref.value,
        disabled = _ref.disabled,
        hidden = _ref.hidden,
        text = _ref.text,
        other = _objectWithoutProperties(_ref, ["className", "value", "disabled", "hidden", "text"]);

    var selectItemClasses = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1j, "--select-option"), true), _defineProperty(_classNames, className, className), _classNames));
    return /*#__PURE__*/React__default.createElement("option", _extends({}, other, {
      className: selectItemClasses,
      value: value,
      disabled: disabled,
      hidden: hidden
    }), text);
  };

  SelectItem.propTypes = {
    /**
     * Specify the value of the <SelectItem>
     */
    value: PropTypes.any.isRequired,

    /**
     * Specify an optional className to be applied to the node
     */
    className: PropTypes.string,

    /**
     * Specify whether the <SelectItem> should be disabled
     */
    disabled: PropTypes.bool,

    /**
     * Specify whether the <SelectItem> is hidden
     */
    hidden: PropTypes.bool,

    /**
     * Provide the contents of your <SelectItem>
     */
    text: PropTypes.string.isRequired
  };
  SelectItem.defaultProps = {
    disabled: false,
    hidden: false,
    value: '',
    text: ''
  };

  /**
   * Shallow compare two arrays for equality
   * @param {Array} arr1 the first array
   * @param {Array} arr2 the second array
   * @returns {boolean} true if both arrays have the same contents, otherwise false
   */
  function equals(arr1, arr2) {
    if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length !== arr2.length) {
      return false;
    }

    if (arr1 === arr2) {
      return true;
    }

    for (var i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }

    return true;
  }

  var prefix$1k = settings_1.prefix;
  var instanceId = 0;

  var Pagination$1 = /*#__PURE__*/function (_Component) {
    _inherits(Pagination, _Component);

    var _super = _createSuper(Pagination);

    function Pagination(props) {
      var _this;

      _classCallCheck(this, Pagination);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "handleSizeChange", function (evt) {
        var pageSize = Number(evt.target.value);

        _this.setState({
          pageSize: pageSize,
          page: 1
        });

        _this.props.onChange({
          page: 1,
          pageSize: pageSize
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handlePageChange", function (evt) {
        _this.setState({
          page: evt.target.value
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handlePageInputChange", function (evt) {
        var page = Number(evt.target.value);

        if (page > 0 && page <= Math.max(Math.ceil(_this.props.totalItems / _this.state.pageSize), 1)) {
          _this.setState({
            page: page
          });

          _this.props.onChange({
            page: page,
            pageSize: _this.state.pageSize
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "incrementPage", function () {
        var page = _this.state.page + 1;

        _this.setState({
          page: page
        });

        _this.props.onChange({
          page: page,
          pageSize: _this.state.pageSize
        });
      });

      _defineProperty(_assertThisInitialized(_this), "decrementPage", function () {
        var page = _this.state.page - 1;

        _this.setState({
          page: page
        });

        _this.props.onChange({
          page: page,
          pageSize: _this.state.pageSize
        });
      });

      _defineProperty(_assertThisInitialized(_this), "renderSelectItems", function (total) {
        var counter = 1;
        var itemArr = [];

        while (counter <= total) {
          itemArr.push( /*#__PURE__*/React__default.createElement(SelectItem, {
            key: counter,
            value: counter,
            text: String(counter)
          }));
          counter++;
        }

        return itemArr;
      });

      var _this$props = _this.props,
          pageSizes = _this$props.pageSizes,
          _page = _this$props.page,
          _pageSize = _this$props.pageSize;
      _this.state = {
        page: _page,
        pageSize: _pageSize && pageSizes.includes(_pageSize) ? _pageSize : pageSizes[0],
        prevPageSizes: pageSizes,
        prevPage: _page,
        prevPageSize: _pageSize
      };
      _this.uniqueId = ++instanceId;
      return _this;
    }

    _createClass(Pagination, [{
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            backwardText = _this$props2.backwardText,
            className = _this$props2.className,
            forwardText = _this$props2.forwardText,
            id = _this$props2.id,
            itemsPerPageText = _this$props2.itemsPerPageText,
            itemRangeText = _this$props2.itemRangeText,
            pageRangeText = _this$props2.pageRangeText,
            pageSize = _this$props2.pageSize,
            pageSizes = _this$props2.pageSizes,
            itemText = _this$props2.itemText,
            pageText = _this$props2.pageText,
            pageNumberText = _this$props2.pageNumberText,
            pagesUnknown = _this$props2.pagesUnknown,
            isLastPage = _this$props2.isLastPage,
            disabled = _this$props2.disabled,
            pageInputDisabled = _this$props2.pageInputDisabled,
            totalItems = _this$props2.totalItems,
            onChange = _this$props2.onChange,
            pageNumber = _this$props2.page,
            other = _objectWithoutProperties(_this$props2, ["backwardText", "className", "forwardText", "id", "itemsPerPageText", "itemRangeText", "pageRangeText", "pageSize", "pageSizes", "itemText", "pageText", "pageNumberText", "pagesUnknown", "isLastPage", "disabled", "pageInputDisabled", "totalItems", "onChange", "page"]);

        var classNames = classnames("".concat(prefix$1k, "--pagination"), className);
        var inputId = id || this.uniqueId;
        var _this$state = this.state,
            statePage = _this$state.page,
            statePageSize = _this$state.pageSize;
        var totalPages = Math.max(Math.ceil(totalItems / statePageSize), 1);
        var backButtonDisabled = disabled || statePage === 1;
        var backButtonClasses = classnames("".concat(prefix$1k, "--pagination__button"), "".concat(prefix$1k, "--pagination__button--backward"), _defineProperty({}, "".concat(prefix$1k, "--pagination__button--no-index"), backButtonDisabled));
        var forwardButtonDisabled = disabled || statePage === totalPages;
        var forwardButtonClasses = classnames("".concat(prefix$1k, "--pagination__button"), "".concat(prefix$1k, "--pagination__button--forward"), _defineProperty({}, "".concat(prefix$1k, "--pagination__button--no-index"), forwardButtonDisabled));
        var selectItems = this.renderSelectItems(totalPages);
        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: classNames
        }, other), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1k, "--pagination__left")
        }, /*#__PURE__*/React__default.createElement("label", {
          id: "".concat(prefix$1k, "-pagination-select-").concat(inputId, "-count-label"),
          className: "".concat(prefix$1k, "--pagination__text"),
          htmlFor: "".concat(prefix$1k, "-pagination-select-").concat(inputId)
        }, itemsPerPageText), /*#__PURE__*/React__default.createElement(Select, {
          id: "".concat(prefix$1k, "-pagination-select-").concat(inputId),
          className: "".concat(prefix$1k, "--select__item-count"),
          labelText: "",
          hideLabel: true,
          noLabel: true,
          inline: true,
          onChange: this.handleSizeChange,
          disabled: pageInputDisabled || disabled,
          value: statePageSize
        }, pageSizes.map(function (size) {
          return /*#__PURE__*/React__default.createElement(SelectItem, {
            key: size,
            value: size,
            text: String(size)
          });
        })), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1k, "--pagination__text")
        }, pagesUnknown ? itemText(statePageSize * (statePage - 1) + 1, statePage * statePageSize) : itemRangeText(Math.min(statePageSize * (statePage - 1) + 1, totalItems), Math.min(statePage * statePageSize, totalItems), totalItems))), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1k, "--pagination__right")
        }, /*#__PURE__*/React__default.createElement(Select, {
          id: "".concat(prefix$1k, "-pagination-select-").concat(inputId, "-right"),
          className: "".concat(prefix$1k, "--select__page-number"),
          labelText: "Page number, of ".concat(totalPages, " pages"),
          inline: true,
          hideLabel: true,
          onChange: this.handlePageInputChange,
          value: statePage,
          disabled: pageInputDisabled || disabled
        }, selectItems), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1k, "--pagination__text")
        }, pagesUnknown ? pageText(statePage) : pageRangeText(statePage, totalPages)), /*#__PURE__*/React__default.createElement(Button, {
          kind: "ghost",
          className: backButtonClasses,
          hasIconOnly: true,
          renderIcon: CaretLeft16,
          iconDescription: backwardText,
          tooltipAlignment: "center",
          tooltipPosition: "top",
          onClick: this.decrementPage,
          disabled: backButtonDisabled
        }), /*#__PURE__*/React__default.createElement(Button, {
          kind: "ghost",
          className: forwardButtonClasses,
          hasIconOnly: true,
          renderIcon: CaretRight16,
          iconDescription: forwardText,
          tooltipAlignment: "end",
          tooltipPosition: "top",
          onClick: this.incrementPage,
          disabled: forwardButtonDisabled || isLastPage
        })));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var pageSizes = _ref.pageSizes,
            page = _ref.page,
            pageSize = _ref.pageSize;
        var prevPageSizes = state.prevPageSizes,
            prevPage = state.prevPage,
            prevPageSize = state.prevPageSize,
            currentPage = state.page,
            currentPageSize = state.pageSize;
        var pageSizesChanged = !equals(pageSizes, prevPageSizes);

        if (pageSizesChanged && !pageSizes.includes(pageSize)) {
          pageSize = pageSizes[0];
        }

        var pageChanged = page !== prevPage;
        var pageSizeChanged = pageSize !== prevPageSize;
        return !pageSizesChanged && !pageChanged && !pageSizeChanged ? null : {
          page: pageSizeChanged && 1 || pageChanged && page || currentPage,
          pageSize: pageSizeChanged ? pageSize : currentPageSize,
          prevPageSizes: pageSizes,
          prevPage: page,
          prevPageSize: pageSize
        };
      }
    }]);

    return Pagination;
  }(React.Component);

  _defineProperty(Pagination$1, "propTypes", {
    /**
     * The description for the backward icon.
     */
    backwardText: PropTypes.string,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * The function returning a translatable text showing where the current page is,
     * in a manner of the range of items.
     */
    itemRangeText: PropTypes.func,

    /**
     * The description for the forward icon.
     */
    forwardText: PropTypes.string,

    /**
     * The unique ID of this component instance.
     */
    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * The translatable text indicating the number of items per page.
     */
    itemsPerPageText: PropTypes.string,

    /**
     * A variant of `itemRangeText`, used if the total number of items is unknown.
     */
    itemText: PropTypes.func,

    /**
     * The callback function called when the current page changes.
     */
    onChange: PropTypes.func,
    pageNumberText: PropTypes.string,

    /**
     * A function returning PII showing where the current page is.
     */
    pageRangeText: PropTypes.func,

    /**
     * The translatable text showing the current page.
     */
    pageText: PropTypes.func,

    /**
     * The choices for `pageSize`.
     */
    pageSizes: PropTypes.arrayOf(PropTypes.number).isRequired,

    /**
     * The total number of items.
     */
    totalItems: PropTypes.number,

    /**
     * `true` if the backward/forward buttons, as well as the page select elements,  should be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * The current page.
     */
    page: PropTypes.number,

    /**
     * The number dictating how many items a page contains.
     */
    pageSize: PropTypes.number,

    /**
     * `true` if the total number of items is unknown.
     */
    pagesUnknown: PropTypes.bool,
    // TODO: remove when v9 is deprecated

    /**
     * `true` if the current page should be the last page.
     */
    isLastPage: PropTypes.bool,

    /**
     * Deprecated; `true` if the select box to change the page should be disabled.
     */
    pageInputDisabled: deprecate(PropTypes.bool, "The prop `pageInputDisabled` for Pagination has been deprecated, as the feature of `pageInputDisabled` has been combined with the general `disabled` prop.")
  });

  _defineProperty(Pagination$1, "defaultProps", {
    backwardText: 'Previous page',
    itemRangeText: function itemRangeText(min, max, total) {
      return "".concat(min, "\u2013").concat(max, " of ").concat(total, " items");
    },
    forwardText: 'Next page',
    itemsPerPageText: 'Items per page:',
    pageNumberText: 'Page Number',
    pageRangeText: function pageRangeText(current, total) {
      return "of ".concat(total, " pages");
    },
    disabled: false,
    page: 1,
    pagesUnknown: false,
    isLastPage: false,
    itemText: function itemText(min, max) {
      return "".concat(min, "\u2013").concat(max, " items");
    },
    pageText: function pageText(page) {
      return "page ".concat(page);
    }
  });

  var PrimaryButton = function PrimaryButton(props) {
    return /*#__PURE__*/React__default.createElement(Button, _extends({
      kind: "primary"
    }, props));
  };

  var prefix$1l = settings_1.prefix;
  var step = /*#__PURE__*/React__default.createElement("li", {
    className: "".concat(prefix$1l, "--progress-step ").concat(prefix$1l, "--progress-step--incomplete")
  }, /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(prefix$1l, "--progress-step-button ").concat(prefix$1l, "--progress-step-button--unclickable")
  }, /*#__PURE__*/React__default.createElement("svg", null, /*#__PURE__*/React__default.createElement("path", {
    d: "M 7, 7 m -7, 0 a 7,7 0 1,0 14,0 a 7,7 0 1,0 -14,0"
  })), /*#__PURE__*/React__default.createElement("p", {
    className: "".concat(prefix$1l, "--progress-label")
  }), /*#__PURE__*/React__default.createElement("span", {
    className: "".concat(prefix$1l, "--progress-line")
  })));

  function ProgressIndicatorSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["className"]);

    return /*#__PURE__*/React__default.createElement("ul", _extends({
      className: classnames("".concat(prefix$1l, "--progress"), "".concat(prefix$1l, "--skeleton"), className)
    }, rest), step, step, step, step);
  }

  ProgressIndicatorSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$1m = settings_1.prefix;

  var defaultRenderLabel = function defaultRenderLabel(props) {
    return /*#__PURE__*/React__default.createElement("p", props);
  };

  var defaultTranslations$4 = {
    'carbon.progress-step.complete': 'Complete',
    'carbon.progress-step.incomplete': 'Incomplete',
    'carbon.progress-step.current': 'Current',
    'carbon.progress-step.invalid': 'Invalid'
  };

  function translateWithId$4(messageId) {
    return defaultTranslations$4[messageId];
  }

  function ProgressStep(_ref) {
    var _classnames;

    var label = _ref.label,
        description = _ref.description,
        className = _ref.className,
        current = _ref.current,
        complete = _ref.complete,
        invalid = _ref.invalid,
        secondaryLabel = _ref.secondaryLabel,
        disabled = _ref.disabled,
        onClick = _ref.onClick,
        ProgressStepLabel = _ref.renderLabel,
        t = _ref.translateWithId,
        rest = _objectWithoutProperties(_ref, ["label", "description", "className", "current", "complete", "invalid", "secondaryLabel", "disabled", "onClick", "renderLabel", "translateWithId"]);

    var classes = classnames((_classnames = {}, _defineProperty(_classnames, "".concat(prefix$1m, "--progress-step"), true), _defineProperty(_classnames, "".concat(prefix$1m, "--progress-step--current"), current), _defineProperty(_classnames, "".concat(prefix$1m, "--progress-step--complete"), complete), _defineProperty(_classnames, "".concat(prefix$1m, "--progress-step--incomplete"), !complete && !current), _defineProperty(_classnames, "".concat(prefix$1m, "--progress-step--disabled"), disabled), _defineProperty(_classnames, className, className), _classnames));

    var handleKeyDown = function handleKeyDown(e) {
      if (matches(e, [Enter, Space])) {
        onClick();
      }
    }; // eslint-disable-next-line react/prop-types


    var SVGIcon = function SVGIcon(_ref2) {
      var complete = _ref2.complete,
          current = _ref2.current,
          description = _ref2.description,
          invalid = _ref2.invalid,
          prefix = _ref2.prefix;

      if (invalid) {
        return /*#__PURE__*/React__default.createElement(Warning16, {
          className: "".concat(prefix, "--progress__warning")
        });
      }

      if (current) {
        return /*#__PURE__*/React__default.createElement(CircleFilled16, null, /*#__PURE__*/React__default.createElement("title", null, description));
      }

      if (complete) {
        return /*#__PURE__*/React__default.createElement(CheckmarkOutline16, null, /*#__PURE__*/React__default.createElement("title", null, description));
      }

      return /*#__PURE__*/React__default.createElement(RadioButton16, null, /*#__PURE__*/React__default.createElement("title", null, description));
    };

    var message = t('carbon.progress-step.incomplete');

    if (current) {
      message = t('carbon.progress-step.current');
    }

    if (complete) {
      message = t('carbon.progress-step.complete');
    }

    if (invalid) {
      message = t('carbon.progress-step.invalid');
    }

    return /*#__PURE__*/React__default.createElement("li", {
      className: classes
    }, /*#__PURE__*/React__default.createElement("button", _extends({
      className: classnames("".concat(prefix$1m, "--progress-step-button"), _defineProperty({}, "".concat(prefix$1m, "--progress-step-button--unclickable"), !onClick || current)),
      disabled: disabled,
      "aria-disabled": disabled,
      tabIndex: !current && onClick && !disabled ? 0 : -1,
      onClick: !current ? onClick : undefined,
      onKeyDown: handleKeyDown,
      title: label
    }, rest), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1m, "--assistive-text")
    }, message), /*#__PURE__*/React__default.createElement(SVGIcon, {
      complete: complete,
      current: current,
      description: description,
      invalid: invalid,
      prefix: prefix$1m
    }), /*#__PURE__*/React__default.createElement(ProgressStepLabel, {
      className: "".concat(prefix$1m, "--progress-label")
    }, label), secondaryLabel !== null && secondaryLabel !== undefined ? /*#__PURE__*/React__default.createElement("p", {
      className: "".concat(prefix$1m, "--progress-optional")
    }, secondaryLabel) : null, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1m, "--progress-line")
    })));
  }
  ProgressStep.propTypes = {
    /**
     * Index of the current step within the ProgressIndicator
     */
    index: PropTypes.number,

    /**
     * Provide the label for the <ProgressStep>
     */
    label: PropTypes.node.isRequired,

    /**
     * Provide an optional className to be applied to the containing <li> node
     */
    className: PropTypes.string,

    /**
     * Specify whether the step is the current step
     */
    current: PropTypes.bool,

    /**
     * Specify whether the step has been completed
     */
    complete: PropTypes.bool,

    /**
     * Provide a description for the <ProgressStep>
     */
    description: PropTypes.string,

    /**
     * Specify whether the step is invalid
     */
    invalid: PropTypes.bool,

    /**
     * Provide an optional secondary label
     */
    secondaryLabel: PropTypes.string,

    /*
     * An optional parameter to allow for overflow content to be rendered in a
     * tooltip.
     */
    renderLabel: PropTypes.func,

    /**
     * Provide the props that describe a progress step tooltip
     */
    overflowTooltipProps: PropTypes.object,

    /**
     * Specify whether the step is disabled
     */
    disabled: PropTypes.bool,

    /**
     * The ID of the tooltip content.
     */
    tooltipId: PropTypes.string,

    /**
     * A callback called if the step is clicked or the enter key is pressed
     */
    onClick: PropTypes.func,

    /**
     * Optional method that takes in a message id and returns an
     * internationalized string.
     */
    translateWithId: PropTypes.func
  };
  ProgressStep.defaultProps = {
    renderLabel: defaultRenderLabel,
    translateWithId: translateWithId$4
  };
  var ProgressIndicator$1 = /*#__PURE__*/function (_Component) {
    _inherits(ProgressIndicator, _Component);

    var _super = _createSuper(ProgressIndicator);

    function ProgressIndicator() {
      var _this;

      _classCallCheck(this, ProgressIndicator);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {});

      _defineProperty(_assertThisInitialized(_this), "renderSteps", function () {
        var onChange = _this.props.onChange;
        return React__default.Children.map(_this.props.children, function (child, index) {
          // only setup click handlers if onChange event is passed
          var onClick = onChange ? function () {
            return onChange(index);
          } : undefined;

          if (index === _this.state.currentIndex) {
            return /*#__PURE__*/React__default.cloneElement(child, {
              current: true,
              index: index,
              onClick: onClick
            });
          }

          if (index < _this.state.currentIndex) {
            return /*#__PURE__*/React__default.cloneElement(child, {
              complete: true,
              index: index,
              onClick: onClick
            });
          }

          if (index > _this.state.currentIndex) {
            return /*#__PURE__*/React__default.cloneElement(child, {
              complete: false,
              index: index,
              onClick: onClick
            });
          }

          return null;
        });
      });

      return _this;
    }

    _createClass(ProgressIndicator, [{
      key: "render",
      value: function render() {
        var _classnames3;

        var _this$props = this.props,
            className = _this$props.className,
            currentIndex = _this$props.currentIndex,
            vertical = _this$props.vertical,
            spaceEqually = _this$props.spaceEqually,
            other = _objectWithoutProperties(_this$props, ["className", "currentIndex", "vertical", "spaceEqually"]);

        var classes = classnames((_classnames3 = {}, _defineProperty(_classnames3, "".concat(prefix$1m, "--progress"), true), _defineProperty(_classnames3, "".concat(prefix$1m, "--progress--vertical"), vertical), _defineProperty(_classnames3, "".concat(prefix$1m, "--progress--space-equal"), spaceEqually && !vertical), _defineProperty(_classnames3, className, className), _classnames3));
        return /*#__PURE__*/React__default.createElement("ul", _extends({
          className: classes
        }, other), this.renderSteps());
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, state) {
        var currentIndex = _ref3.currentIndex;
        var prevCurrentIndex = state.prevCurrentIndex;
        return prevCurrentIndex === currentIndex ? null : {
          currentIndex: currentIndex,
          prevCurrentIndex: currentIndex
        };
      }
    }]);

    return ProgressIndicator;
  }(React.Component);

  _defineProperty(ProgressIndicator$1, "propTypes", {
    /**
     * Provide <ProgressStep> components to be rendered in the
     * <ProgressIndicator>
     */
    children: PropTypes.node,

    /**
     * Provide an optional className to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Optionally specify the current step array index
     */
    currentIndex: PropTypes.number,

    /**
     * Optional callback called if a ProgressStep is clicked on.  Returns the index of the step.
     */
    onChange: PropTypes.func,

    /**
     * Determines whether or not the ProgressIndicator should be rendered vertically.
     */
    vertical: PropTypes.bool,

    /**
     * Specify whether the progress steps should be split equally in size in the div
     */
    spaceEqually: PropTypes.bool
  });

  _defineProperty(ProgressIndicator$1, "defaultProps", {
    currentIndex: 0
  });

  var prefix$1n = settings_1.prefix;

  var RadioButtonGroup = /*#__PURE__*/function (_React$Component) {
    _inherits(RadioButtonGroup, _React$Component);

    var _super = _createSuper(RadioButtonGroup);

    function RadioButtonGroup() {
      var _this;

      _classCallCheck(this, RadioButtonGroup);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {
        selected: _this.props.valueSelected || _this.props.defaultSelected
      });

      _defineProperty(_assertThisInitialized(_this), "getRadioButtons", function () {
        var children = React__default.Children.map(_this.props.children, function (radioButton) {
          var _radioButton$props = radioButton.props,
              value = _radioButton$props.value,
              other = _objectWithoutProperties(_radioButton$props, ["value"]);
          /* istanbul ignore if */


          if (typeof radioButton.props.checked !== 'undefined') {
             warning_1(false, "Instead of using the checked property on the RadioButton, set\n            the defaultSelected property or valueSelected property on the RadioButtonGroup.") ;
          }

          return /*#__PURE__*/React__default.createElement(RadioButton$1, _extends({}, other, {
            name: _this.props.name,
            key: value,
            value: value,
            onChange: _this.handleChange,
            checked: value === _this.state.selected
          }));
        });
        return children;
      });

      _defineProperty(_assertThisInitialized(_this), "handleChange", function (newSelection, value, evt) {
        if (newSelection !== _this.state.selected) {
          _this.setState({
            selected: newSelection
          });

          _this.props.onChange(newSelection, _this.props.name, evt);
        }
      });

      return _this;
    }

    _createClass(RadioButtonGroup, [{
      key: "render",
      value: function render() {
        var _classNames;

        var _this$props = this.props,
            disabled = _this$props.disabled,
            className = _this$props.className,
            orientation = _this$props.orientation,
            labelPosition = _this$props.labelPosition;
        var wrapperClasses = classnames("".concat(prefix$1n, "--radio-button-group"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1n, "--radio-button-group--").concat(orientation), orientation === 'vertical'), _defineProperty(_classNames, "".concat(prefix$1n, "--radio-button-group--label-").concat(labelPosition), labelPosition), _classNames));
        return /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1n, "--form-item")
        }, /*#__PURE__*/React__default.createElement("div", {
          className: wrapperClasses,
          disabled: disabled
        }, this.getRadioButtons()));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var valueSelected = _ref.valueSelected,
            defaultSelected = _ref.defaultSelected;
        var prevValueSelected = state.prevValueSelected;
        return prevValueSelected === valueSelected ? null : {
          selected: valueSelected || defaultSelected,
          prevValueSelected: valueSelected
        };
      }
    }]);

    return RadioButtonGroup;
  }(React__default.Component);

  _defineProperty(RadioButtonGroup, "propTypes", {
    /**
     * Provide a collection of <RadioButton> components to render in the group
     */
    children: PropTypes.node,

    /**
     * Provide an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify the <RadioButton> to be selected by default
     */
    defaultSelected: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Provide where radio buttons should be placed
     */
    orientation: PropTypes.oneOf(['horizontal', 'vertical']),

    /**
     * Provide where label text should be placed
     */
    labelPosition: PropTypes.oneOf(['left', 'right']),

    /**
     * Specify the name of the underlying <input> nodes
     */
    name: PropTypes.string.isRequired,

    /**
     * Specify whether the group is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide an optional `onChange` hook that is called whenever the value of
     * the group changes
     */
    onChange: PropTypes.func,

    /**
     * Specify the value that is currently selected in the group
     */
    valueSelected: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  });

  _defineProperty(RadioButtonGroup, "defaultProps", {
    orientation: 'horizontal',
    labelPosition: 'right',
    onChange:
    /* istanbul ignore next */
    function onChange() {}
  });

  var prefix$1o = settings_1.prefix;
  var didWarnAboutDeprecation$1 = false;
  /**
   * The filter button for `<Search>`.
   */

  var SearchFilterButton = function SearchFilterButton(_ref) {
    var labelText = _ref.labelText,
        iconDescription = _ref.iconDescription,
        other = _objectWithoutProperties(_ref, ["labelText", "iconDescription"]);

    {
       warning_1(didWarnAboutDeprecation$1, 'The SearchFilterButton component has been deprecated and will be removed in the next major release of `carbon-components-react`') ;
      didWarnAboutDeprecation$1 = true;
    }

    return /*#__PURE__*/React__default.createElement("button", _extends({
      className: "".concat(prefix$1o, "--search-button"),
      type: "button",
      "aria-label": labelText,
      title: labelText
    }, other), /*#__PURE__*/React__default.createElement(Filter16, {
      className: "".concat(prefix$1o, "--search-filter"),
      "aria-label": iconDescription
    }));
  };

  SearchFilterButton.propTypes = {
    /**
     * The a11y label text.
     */
    labelText: PropTypes.string,

    /**
     * The icon description.
     */
    iconDescription: PropTypes.string
  };
  SearchFilterButton.defaultProps = {
    labelText: 'Search',
    iconDescription: 'filter'
  };

  var prefix$1p = settings_1.prefix;
  var didWarnAboutDeprecation$2 = false;
  /**
   * The layout button for `<Search>`.
   */

  var SearchLayoutButton = /*#__PURE__*/function (_Component) {
    _inherits(SearchLayoutButton, _Component);

    var _super = _createSuper(SearchLayoutButton);

    _createClass(SearchLayoutButton, null, [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var format = _ref.format;
        var prevFormat = state.prevFormat;
        return prevFormat === format ? null : {
          format: format || 'list',
          prevFormat: format
        };
      }
    }]);

    function SearchLayoutButton(props) {
      var _this;

      _classCallCheck(this, SearchLayoutButton);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "state", {
        format: 'list'
      });

      _defineProperty(_assertThisInitialized(_this), "toggleLayout", function () {
        var format = _this.state.format === 'list' ? 'grid' : 'list';

        _this.setState({
          format: format
        }, function () {
          var onChangeFormat = _this.props.onChangeFormat;

          if (typeof onChangeFormat === 'function') {
            onChangeFormat({
              format: format
            });
          }
        });
      });

      {
         warning_1(didWarnAboutDeprecation$2, 'The SearchLayoutButton component has been deprecated and will be removed in the next major release of `carbon-components-react`') ;
        didWarnAboutDeprecation$2 = true;
      }

      return _this;
    }
    /**
     * Toggles the button state upon user-initiated event.
     */


    _createClass(SearchLayoutButton, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            labelText = _this$props.labelText,
            iconDescriptionList = _this$props.iconDescriptionList,
            iconDescriptionGrid = _this$props.iconDescriptionGrid;

        var SearchLayoutButtonIcon = function SearchLayoutButtonIcon() {
          if (_this2.state.format === 'list') {
            return /*#__PURE__*/React__default.createElement(ListBulleted16, {
              className: "".concat(prefix$1p, "--search-view"),
              "aria-label": iconDescriptionList
            });
          }

          return /*#__PURE__*/React__default.createElement(Grid16, {
            className: "".concat(prefix$1p, "--search-view"),
            "aria-label": iconDescriptionGrid
          });
        };

        return /*#__PURE__*/React__default.createElement("button", {
          className: "".concat(prefix$1p, "--search-button"),
          type: "button",
          onClick: this.toggleLayout,
          "aria-label": labelText,
          title: labelText
        }, /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1p, "--search__toggle-layout__container")
        }, /*#__PURE__*/React__default.createElement(SearchLayoutButtonIcon, null)));
      }
    }]);

    return SearchLayoutButton;
  }(React.Component);

  _defineProperty(SearchLayoutButton, "propTypes", {
    /**
     * The layout.
     */
    format: PropTypes.oneOf(['list', 'grid']),

    /**
     * The a11y label text.
     */
    labelText: PropTypes.string,

    /**
     * The description for the "list" icon.
     */
    iconDescriptionList: PropTypes.string,

    /**
     * The description for the "grid" icon.
     */
    iconDescriptionGrid: PropTypes.string,

    /**
     * The callback called when layout switches.
     */
    onChangeFormat: PropTypes.func
  });

  _defineProperty(SearchLayoutButton, "defaultProps", {
    labelText: 'Filter',
    iconDescriptionList: 'list',
    iconDescriptionGrid: 'grid'
  });

  var SecondaryButton = function SecondaryButton(props) {
    return /*#__PURE__*/React__default.createElement(Button, _extends({
      kind: "secondary"
    }, props));
  };

  var prefix$1q = settings_1.prefix;

  var SelectItemGroup = function SelectItemGroup(_ref) {
    var children = _ref.children,
        className = _ref.className,
        disabled = _ref.disabled,
        label = _ref.label,
        other = _objectWithoutProperties(_ref, ["children", "className", "disabled", "label"]);

    var classNames = classnames("".concat(prefix$1q, "--select-optgroup"), className);
    return /*#__PURE__*/React__default.createElement("optgroup", _extends({
      className: classNames,
      label: label,
      disabled: disabled
    }, other), children);
  };

  SelectItemGroup.propTypes = {
    /**
     * Provide the contents of your <SelectItemGroup>
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the node
     */
    className: PropTypes.string,

    /**
     * Specify whether the <SelectItemGroup> should be disabled
     */
    disabled: PropTypes.bool,

    /**
     * Specify the label to be displayed
     */
    label: PropTypes.string.isRequired
  };
  SelectItemGroup.defaultProps = {
    disabled: false,
    label: 'Provide label'
  };

  var prefix$1r = settings_1.prefix;
  var Switch = /*#__PURE__*/React__default.forwardRef(function Switch(props, tabRef) {
    var className = props.className,
        index = props.index,
        name = props.name,
        onClick = props.onClick,
        onKeyDown = props.onKeyDown,
        selected = props.selected,
        text = props.text,
        other = _objectWithoutProperties(props, ["className", "index", "name", "onClick", "onKeyDown", "selected", "text"]);

    var handleClick = function handleClick(e) {
      e.preventDefault();
      onClick({
        index: index,
        name: name,
        text: text
      });
    };

    var handleKeyDown = function handleKeyDown(event) {
      var key = event.key || event.which;
      onKeyDown({
        index: index,
        name: name,
        text: text,
        key: key
      });
    };

    var classes = classnames(className, "".concat(prefix$1r, "--content-switcher-btn"), _defineProperty({}, "".concat(prefix$1r, "--content-switcher--selected"), selected));
    var commonProps = {
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      className: classes
    };
    return /*#__PURE__*/React__default.createElement("button", _extends({
      ref: tabRef,
      role: "tab",
      tabIndex: selected ? '0' : '-1',
      "aria-selected": selected
    }, other, commonProps), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1r, "--content-switcher__label")
    }, text));
  });
  Switch.displayName = 'Switch';
  Switch.propTypes = {
    /**
     * Specify an optional className to be added to your Switch
     */
    className: PropTypes.string,

    /**
     * The index of your Switch in your ContentSwitcher that is used for event handlers.
     * Reserved for usage in ContentSwitcher
     */
    index: PropTypes.number,

    /**
     * Provide the name of your Switch that is used for event handlers
     */
    name: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * A handler that is invoked when a user clicks on the control.
     * Reserved for usage in ContentSwitcher
     */
    onClick: PropTypes.func,

    /**
     * A handler that is invoked on the key down event for the control.
     * Reserved for usage in ContentSwitcher
     */
    onKeyDown: PropTypes.func,

    /**
     * Whether your Switch is selected. Reserved for usage in ContentSwitcher
     */
    selected: PropTypes.bool,

    /**
     * Provide the contents of your Switch
     */
    text: PropTypes.string.isRequired
  };
  Switch.defaultProps = {
    selected: false,
    text: 'Provide text',
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {}
  };

  var prefix$1s = settings_1.prefix;

  var SliderSkeleton = function SliderSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["hideLabel", "className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$1s, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1s, "--label ").concat(prefix$1s, "--skeleton")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1s, "--slider-container ").concat(prefix$1s, "--skeleton")
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1s, "--slider__range-label")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1s, "--slider")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1s, "--slider__track")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1s, "--slider__filled-track")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1s, "--slider__thumb")
    })), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1s, "--slider__range-label")
    })));
  };

  SliderSkeleton.propTypes = {
    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes.string
  };

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the `TypeError` message for "Functions" methods. */

  var FUNC_ERROR_TEXT$1 = 'Expected a function';
  /** Used as references for various `Number` constants. */

  var NAN$1 = 0 / 0;
  /** `Object#toString` result references. */

  var symbolTag$2 = '[object Symbol]';
  /** Used to match leading and trailing whitespace. */

  var reTrim$1 = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary$1 = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal$1 = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt$1 = parseInt;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal$2 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf$2 = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root$2 = freeGlobal$2 || freeSelf$2 || Function('return this')();
  /** Used for built-in method references. */

  var objectProto$2 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString$2 = objectProto$2.toString;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax$2 = Math.max,
      nativeMin$1 = Math.min;
  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */

  var now$1 = function now() {
    return root$2.Date.now();
  };
  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */


  function debounce$2(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }

    wait = toNumber$1(wait) || 0;

    if (isObject$2(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax$2(toNumber$1(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time; // Start the timer for the trailing edge.

      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          result = wait - timeSinceLastCall;
      return maxing ? nativeMin$1(result, maxWait - timeSinceLastInvoke) : result;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now$1();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now$1());
    }

    function debounced() {
      var time = now$1(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */


  function throttle$1(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }

    if (isObject$2(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    return debounce$2(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject$2(value) {
    var type = _typeof(value);

    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike$2(value) {
    return !!value && _typeof(value) == 'object';
  }
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */


  function isSymbol$2(value) {
    return _typeof(value) == 'symbol' || isObjectLike$2(value) && objectToString$2.call(value) == symbolTag$2;
  }
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */


  function toNumber$1(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol$2(value)) {
      return NAN$1;
    }

    if (isObject$2(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject$2(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim$1, '');
    var isBinary = reIsBinary$1.test(value);
    return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
  }

  var lodash_throttle = throttle$1;

  var prefix$1t = settings_1.prefix;

  var defaultFormatLabel = function defaultFormatLabel(value, label) {
    return typeof label === 'function' ? label(value) : "".concat(value).concat(label);
  };
  /**
   * Minimum time between processed "drag" events.
   */


  var EVENT_THROTTLE = 16; // ms

  /**
   * Event types that trigger "drags".
   */

  var DRAG_EVENT_TYPES = new Set(['mousemove', 'touchmove']);
  /**
   * Event types that trigger a "drag" to stop.
   */

  var DRAG_STOP_EVENT_TYPES = new Set(['mouseup', 'touchend', 'touchcancel']);

  var Slider$1 = /*#__PURE__*/function (_PureComponent) {
    _inherits(Slider, _PureComponent);

    var _super = _createSuper(Slider);

    function Slider() {
      var _this;

      _classCallCheck(this, Slider);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {
        value: _this.props.value,
        left: 0,
        needsOnRelease: false
      });

      _defineProperty(_assertThisInitialized(_this), "onDragStart", function (evt) {
        // Do nothing if component is disabled
        if (_this.props.disabled) {
          return;
        } // Register drag stop handlers


        DRAG_STOP_EVENT_TYPES.forEach(function (element) {
          _this.element.ownerDocument.addEventListener(element, _this.onDragStop);
        }); // Register drag handlers

        DRAG_EVENT_TYPES.forEach(function (element) {
          _this.element.ownerDocument.addEventListener(element, _this.onDrag);
        }); // Perform first recalculation since we probably didn't click exactly in the
        // middle of the thumb

        _this.onDrag(evt);
      });

      _defineProperty(_assertThisInitialized(_this), "onDragStop", function () {
        // Do nothing if component is disabled
        if (_this.props.disabled) {
          return;
        } // Remove drag stop handlers


        DRAG_STOP_EVENT_TYPES.forEach(function (element) {
          _this.element.ownerDocument.removeEventListener(element, _this.onDragStop);
        }); // Remove drag handlers

        DRAG_EVENT_TYPES.forEach(function (element) {
          _this.element.ownerDocument.removeEventListener(element, _this.onDrag);
        }); // Set needsOnRelease flag so event fires on next update

        _this.setState({
          needsOnRelease: true
        });
      });

      _defineProperty(_assertThisInitialized(_this), "_onDrag", function (evt) {
        // Do nothing if component is disabled or we have no event
        if (_this.props.disabled || !evt) {
          return;
        }

        var clientX;

        if ('clientX' in evt) {
          clientX = evt.clientX;
        } else if ('touches' in evt && 0 in evt.touches && 'clientX' in evt.touches[0]) {
          clientX = evt.touches[0].clientX;
        } else {
          // Do nothing if we have no valid clientX
          return;
        }

        var _this$calcValue = _this.calcValue({
          clientX: clientX
        }),
            value = _this$calcValue.value,
            left = _this$calcValue.left;

        _this.setState({
          value: value,
          left: left
        });
      });

      _defineProperty(_assertThisInitialized(_this), "onDrag", lodash_throttle(_this._onDrag, EVENT_THROTTLE, {
        leading: true,
        trailing: false
      }));

      _defineProperty(_assertThisInitialized(_this), "onKeyDown", function (evt) {
        // Do nothing if component is disabled or we don't have a valid event
        if (_this.props.disabled || !('which' in evt)) {
          return;
        }

        var which = Number.parseInt(evt.which);
        var delta = 0;

        if (matches(which, [ArrowDown, ArrowLeft])) {
          delta = -_this.props.step;
        } else if (matches(which, [ArrowUp, ArrowRight])) {
          delta = _this.props.step;
        } else {
          // Ignore keys we don't want to handle
          return;
        } // If shift was held, account for the stepMultiplier


        if (evt.shiftKey) {
          var stepMultiplier = _this.props.stepMultiplier || _this.props.stepMuliplier;
          delta *= stepMultiplier;
        }

        Math.floor(_this.state.value / _this.props.step) * _this.props.step;

        var _this$calcValue2 = _this.calcValue({
          // Ensures custom value from `<input>` won't cause skipping next stepping point with right arrow key,
          // e.g. Typing 51 in `<input>`, moving focus onto the thumb and the hitting right arrow key should yield 52 instead of 54
          value: (delta > 0 ? Math.floor(_this.state.value / _this.props.step) * _this.props.step : _this.state.value) + delta
        }),
            value = _this$calcValue2.value,
            left = _this$calcValue2.left;

        _this.setState({
          value: value,
          left: left
        });
      });

      _defineProperty(_assertThisInitialized(_this), "onChange", function (evt) {
        // Do nothing if component is disabled
        if (_this.props.disabled) {
          return;
        } // Do nothing if we have no valid event, target, or value


        if (!evt || !('target' in evt) || typeof evt.target.value !== 'string') {
          return;
        }

        var targetValue = Number.parseFloat(evt.target.value); // Avoid calling calcValue for invaid numbers, but still update the state

        if (isNaN(targetValue)) {
          _this.setState({
            value: evt.target.value
          });
        } else {
          // Recalculate the state's value and update the Slider
          var _this$calcValue3 = _this.calcValue({
            value: targetValue,
            useRawValue: true
          }),
              value = _this$calcValue3.value,
              left = _this$calcValue3.left;

          _this.setState({
            value: value,
            left: left,
            needsOnRelease: true
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "calcValue", function (_ref) {
        var _ref$clientX = _ref.clientX,
            clientX = _ref$clientX === void 0 ? null : _ref$clientX,
            _ref$value = _ref.value,
            value = _ref$value === void 0 ? null : _ref$value,
            _ref$useRawValue = _ref.useRawValue,
            useRawValue = _ref$useRawValue === void 0 ? false : _ref$useRawValue;
        var range = _this.props.max - _this.props.min;

        var boundingRect = _this.element.getBoundingClientRect();

        var totalSteps = range / _this.props.step;
        var width = boundingRect.right - boundingRect.left; // Enforce a minimum width of at least 1 for calculations

        if (width <= 0) {
          width = 1;
        } // If a clientX is specified, use it to calculate the leftPercent. If not,
        // use the provided value or state's value to calculate it instead.


        var leftPercent;

        if (clientX != null) {
          var leftOffset = clientX - boundingRect.left;
          leftPercent = leftOffset / width;
        } else {
          if (value == null) {
            value = _this.state.value;
          }

          leftPercent = (value - _this.props.min) / range;
        }

        if (useRawValue) {
          // Adjusts only for min/max of thumb position
          return {
            value: value,
            left: Math.min(1, Math.max(0, leftPercent)) * 100
          };
        }

        var steppedValue = Math.round(leftPercent * totalSteps) * _this.props.step;

        var steppedPercent = _this.clamp(steppedValue / range, 0, 1);

        steppedValue = _this.clamp(steppedValue + _this.props.min, _this.props.min, _this.props.max);
        return {
          value: steppedValue,
          left: steppedPercent * 100
        };
      });

      return _this;
    }

    _createClass(Slider, [{
      key: "componentDidMount",

      /**
       * Sets up initial slider position and value in response to component mount.
       */
      value: function componentDidMount() {
        if (this.element) {
          var _this$calcValue4 = this.calcValue({
            useRawValue: true
          }),
              value = _this$calcValue4.value,
              left = _this$calcValue4.left;

          this.setState({
            value: value,
            left: left
          });
        }
      }
      /**
       * Handles firing of `onChange` and `onRelease` callbacks to parent in
       * response to state changes.
       *
       * @param {*} prevProps prevProps
       * @param {*} prevState The previous Slider state, used to see if callbacks
       * should be called.
       */

    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        // Fire onChange event handler if present, if there's a usable value, and
        // if the value is different from the last one
        if (this.state.value !== '' && prevState.value !== this.state.value && typeof this.props.onChange === 'function') {
          // TODO: pass event object as first param (breaking change/feat for v11)
          this.props.onChange({
            value: this.state.value
          });
        } // Fire onRelease event handler if present and if needed


        if (this.state.needsOnRelease && typeof this.props.onRelease === 'function') {
          // TODO: pass event object as first param (breaking change/feat for v11)
          this.props.onRelease({
            value: this.state.value
          }); // Reset the flag

          this.setState({
            needsOnRelease: false
          });
        } // If value from props does not change, do nothing here.
        // Otherwise, do prop -> state sync without "value capping".


        if (prevProps.value === this.props.value) {
          return;
        }

        this.setState(this.calcValue({
          value: this.props.value,
          useRawValue: true
        }));
      }
      /**
       * Synonymous to ECMA2017+ `Math.clamp`.
       *
       * @param {number} val
       * @param {number} min
       * @param {number} max
       *
       * @returns `val` if `max>=val>=min`; `min` if `val<min`; `max` if `val>max`.
       */

    }, {
      key: "clamp",
      value: function clamp(val, min, max) {
        return Math.max(min, Math.min(val, max));
      }
      /**
       * Sets up "drag" event handlers and calls `this.onDrag` in case dragging
       * started on somewhere other than the thumb without a corresponding "move"
       * event.
       *
       * @param {Event} evt The event.
       */

    }, {
      key: "render",
      value: function render() {
        var _classNames3,
            _this2 = this;

        var _this$props = this.props,
            ariaLabelInput = _this$props.ariaLabelInput,
            className = _this$props.className,
            hideTextInput = _this$props.hideTextInput,
            _this$props$id = _this$props.id,
            id = _this$props$id === void 0 ? this.inputId = this.inputId || "__carbon-slider_".concat(Math.random().toString(36).substr(2)) : _this$props$id,
            min = _this$props.min,
            minLabel = _this$props.minLabel,
            max = _this$props.max,
            maxLabel = _this$props.maxLabel,
            _this$props$formatLab = _this$props.formatLabel,
            formatLabel = _this$props$formatLab === void 0 ? defaultFormatLabel : _this$props$formatLab,
            labelText = _this$props.labelText,
            step = _this$props.step,
            stepMuliplier = _this$props.stepMuliplier,
            stepMultiplier = _this$props.stepMultiplier,
            inputType = _this$props.inputType,
            required = _this$props.required,
            disabled = _this$props.disabled,
            name = _this$props.name,
            light = _this$props.light,
            other = _objectWithoutProperties(_this$props, ["ariaLabelInput", "className", "hideTextInput", "id", "min", "minLabel", "max", "maxLabel", "formatLabel", "labelText", "step", "stepMuliplier", "stepMultiplier", "inputType", "required", "disabled", "name", "light"]);

        delete other.onRelease;
        var _this$state = this.state,
            value = _this$state.value,
            left = _this$state.left;
        var labelClasses = classnames("".concat(prefix$1t, "--label"), _defineProperty({}, "".concat(prefix$1t, "--label--disabled"), disabled));
        var sliderClasses = classnames("".concat(prefix$1t, "--slider"), _defineProperty({}, "".concat(prefix$1t, "--slider--disabled"), disabled), className);
        var inputClasses = classnames("".concat(prefix$1t, "--text-input"), "".concat(prefix$1t, "--slider-text-input"), (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$1t, "--text-input--light"), light), _defineProperty(_classNames3, "".concat(prefix$1t, "--text-input--invalid"), this.props.invalid), _classNames3));
        var filledTrackStyle = {
          transform: "translate(0%, -50%) scaleX(".concat(left / 100, ")")
        };
        var thumbStyle = {
          left: "".concat(left, "%")
        };
        var hiddenInputStyle = {
          display: 'none'
        };
        return /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1t, "--form-item")
        }, /*#__PURE__*/React__default.createElement("label", {
          htmlFor: id,
          className: labelClasses
        }, labelText), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1t, "--slider-container")
        }, /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1t, "--slider__range-label")
        }, formatLabel(min, minLabel)), /*#__PURE__*/React__default.createElement("div", _extends({
          className: sliderClasses,
          ref: function ref(node) {
            _this2.element = node;
          },
          onMouseDown: this.onDragStart,
          onTouchStart: this.onDragStart,
          onKeyDown: this.onKeyDown,
          role: "presentation",
          tabIndex: -1
        }, other), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1t, "--slider__thumb"),
          role: "slider",
          id: id,
          tabIndex: 0,
          "aria-valuemax": max,
          "aria-valuemin": min,
          "aria-valuenow": value,
          style: thumbStyle
        }), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1t, "--slider__track"),
          ref: function ref(node) {
            _this2.track = node;
          }
        }), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1t, "--slider__filled-track"),
          style: filledTrackStyle
        })), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1t, "--slider__range-label")
        }, formatLabel(max, maxLabel)), /*#__PURE__*/React__default.createElement("input", {
          type: hideTextInput ? 'hidden' : inputType,
          style: hideTextInput ? hiddenInputStyle : null,
          id: "".concat(id, "-input-for-slider"),
          name: name,
          className: inputClasses,
          value: value,
          "aria-label": ariaLabelInput,
          disabled: disabled,
          required: required,
          min: min,
          max: max,
          step: step,
          onChange: this.onChange
        })));
      }
    }]);

    return Slider;
  }(React.PureComponent);

  _defineProperty(Slider$1, "propTypes", {
    /**
     * The CSS class name for the slider.
     */
    className: PropTypes.string,

    /**
     * `true` to hide the number input box.
     */
    hideTextInput: PropTypes.bool,

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes.string,

    /**
     * The callback to get notified of change in value.
     */
    onChange: PropTypes.func,

    /**
     * The callback to get notified of value on handle release.
     */
    onRelease: PropTypes.func,

    /**
     * The value.
     */
    value: PropTypes.number.isRequired,

    /**
     * The minimum value.
     */
    min: PropTypes.number.isRequired,

    /**
     * The label associated with the minimum value.
     */
    minLabel: PropTypes.string,

    /**
     * The maximum value.
     */
    max: PropTypes.number.isRequired,

    /**
     * The label associated with the maximum value.
     */
    maxLabel: PropTypes.string,

    /**
     * The callback to format the label associated with the minimum/maximum value.
     */
    formatLabel: PropTypes.func,

    /**
     * The label for the slider.
     */
    labelText: PropTypes.node,

    /**
     * A value determining how much the value should increase/decrease by moving the thumb by mouse.
     */
    step: PropTypes.number,

    /**
     * A value determining how much the value should increase/decrease by Shift+arrow keys,
     * which will be `(max - min) / stepMuliplier`.
     */
    stepMuliplier: deprecate(PropTypes.number, ' The `stepMuliplier` prop has been deprecated in favor of `stepMultiplier`. It will be removed in the next major release.'),

    /**
     * A value determining how much the value should increase/decrease by Shift+arrow keys,
     * which will be `(max - min) / stepMultiplier`.
     */
    stepMultiplier: PropTypes.number,

    /**
     * The child nodes.
     */
    children: PropTypes.node,

    /**
     * `true` to disable this slider.
     */
    disabled: PropTypes.bool,

    /**
     * The `name` attribute of the `<input>`.
     */
    name: PropTypes.string,

    /**
     * The `type` attribute of the `<input>`.
     */
    inputType: PropTypes.string,

    /**
     * The `ariaLabel` for the `<input>`.
     */
    ariaLabelInput: PropTypes.string,

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool,

    /**
     * `true` to specify if the control is required.
     */
    required: PropTypes.bool,

    /**
     * `true` to specify if the control is invalid.
     */
    invalid: PropTypes.bool
  });

  _defineProperty(Slider$1, "defaultProps", {
    hideTextInput: false,
    step: 1,
    stepMultiplier: 4,
    disabled: false,
    minLabel: '',
    maxLabel: '',
    inputType: 'number',
    ariaLabelInput: 'Slider number input',
    light: false
  });

  var prefix$1u = settings_1.prefix;

  var StructuredListSkeleton = function StructuredListSkeleton(_ref) {
    var _cx;

    var rowCount = _ref.rowCount,
        border = _ref.border,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["rowCount", "border", "className"]);

    var StructuredListSkeletonClasses = classnames(className, (_cx = {}, _defineProperty(_cx, "".concat(prefix$1u, "--skeleton"), true), _defineProperty(_cx, "".concat(prefix$1u, "--structured-list"), true), _defineProperty(_cx, "".concat(prefix$1u, "--structured-list--border"), border), _cx));
    var rows = [];

    for (var i = 0; i < rowCount; i++) {
      rows.push( /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$1u, "--structured-list-row"),
        key: i
      }, /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$1u, "--structured-list-td")
      }), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$1u, "--structured-list-td")
      }), /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(prefix$1u, "--structured-list-td")
      })));
    }

    return /*#__PURE__*/React__default.createElement("section", _extends({
      className: StructuredListSkeletonClasses
    }, rest), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1u, "--structured-list-thead")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1u, "--structured-list-row ").concat(prefix$1u, "--structured-list-row--header-row")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1u, "--structured-list-th")
    }, /*#__PURE__*/React__default.createElement("span", null)), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1u, "--structured-list-th")
    }, /*#__PURE__*/React__default.createElement("span", null)), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1u, "--structured-list-th")
    }, /*#__PURE__*/React__default.createElement("span", null)))), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1u, "--structured-list-tbody")
    }, rows));
  };

  StructuredListSkeleton.propTypes = {
    /**
     * number of table rows
     */
    rowCount: PropTypes.number,

    /**
     * Specify whether a border should be added to your StructuredListSkeleton
     */
    border: PropTypes.bool,

    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };
  StructuredListSkeleton.defaultProps = {
    rowCount: 5,
    border: false
  };

  var prefix$1v = settings_1.prefix;
  var StructuredListWrapper = /*#__PURE__*/function (_Component) {
    _inherits(StructuredListWrapper, _Component);

    var _super = _createSuper(StructuredListWrapper);

    function StructuredListWrapper() {
      _classCallCheck(this, StructuredListWrapper);

      return _super.apply(this, arguments);
    }

    _createClass(StructuredListWrapper, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            children = _this$props.children,
            selection = _this$props.selection,
            className = _this$props.className,
            ariaLabel = _this$props.ariaLabel,
            _border = _this$props.border,
            other = _objectWithoutProperties(_this$props, ["children", "selection", "className", "ariaLabel", "border"]);

        var classes = classnames("".concat(prefix$1v, "--structured-list"), className, _defineProperty({}, "".concat(prefix$1v, "--structured-list--selection"), selection));
        return /*#__PURE__*/React__default.createElement("section", _extends({
          className: classes
        }, other, {
          "aria-label": ariaLabel
        }), children);
      }
    }]);

    return StructuredListWrapper;
  }(React.Component);

  _defineProperty(StructuredListWrapper, "propTypes", {
    /**
     * Provide the contents of your StructuredListWrapper
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify whether a border should be added to your StructuredListWrapper
     */
    border: deprecate(PropTypes.bool, "\nThe prop `border` will be removed in the next major version of Carbon."),

    /**
     * Specify whether your StructuredListWrapper should have selections
     */
    selection: PropTypes.bool,

    /**
     * Specify a label to be read by screen readers on the container node
     */
    ariaLabel: PropTypes.string
  });

  _defineProperty(StructuredListWrapper, "defaultProps", {
    selection: false,
    ariaLabel: 'Structured list section'
  });

  var StructuredListHead = /*#__PURE__*/function (_Component2) {
    _inherits(StructuredListHead, _Component2);

    var _super2 = _createSuper(StructuredListHead);

    function StructuredListHead() {
      _classCallCheck(this, StructuredListHead);

      return _super2.apply(this, arguments);
    }

    _createClass(StructuredListHead, [{
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            children = _this$props2.children,
            className = _this$props2.className,
            other = _objectWithoutProperties(_this$props2, ["children", "className"]);

        var classes = classnames("".concat(prefix$1v, "--structured-list-thead"), className);
        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: classes
        }, other), children);
      }
    }]);

    return StructuredListHead;
  }(React.Component);

  _defineProperty(StructuredListHead, "propTypes", {
    /**
     * Provide the contents of your StructuredListHead
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the node
     */
    className: PropTypes.string
  });

  var getInstanceId$7 = setupGetInstanceId();
  var StructuredListInput = /*#__PURE__*/function (_Component3) {
    _inherits(StructuredListInput, _Component3);

    var _super3 = _createSuper(StructuredListInput);

    function StructuredListInput(props) {
      var _this;

      _classCallCheck(this, StructuredListInput);

      _this = _super3.call(this, props);
      _this.uid = _this.props.id || getInstanceId$7();
      return _this;
    }

    _createClass(StructuredListInput, [{
      key: "render",
      value: function render() {
        var _this$props3 = this.props,
            className = _this$props3.className,
            value = _this$props3.value,
            name = _this$props3.name,
            title = _this$props3.title,
            other = _objectWithoutProperties(_this$props3, ["className", "value", "name", "title"]);

        var classes = classnames("".concat(prefix$1v, "--structured-list-input"), className);
        return /*#__PURE__*/React__default.createElement("input", _extends({}, other, {
          type: "radio",
          tabIndex: -1,
          id: this.uid,
          className: classes,
          value: value,
          name: name,
          title: title
        }));
      }
    }]);

    return StructuredListInput;
  }(React.Component);

  _defineProperty(StructuredListInput, "propTypes", {
    /**
     * Specify an optional className to be applied to the input
     */
    className: PropTypes.string,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes.string,

    /**
     * Specify the value of the input
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,

    /**
     * Provide a `name` for the input
     */
    name: PropTypes.string,

    /**
     * Provide a `title` for the input
     */
    title: PropTypes.string,

    /**
     * Specify whether the underlying input should be checked by default
     */
    defaultChecked: PropTypes.bool,

    /**
     * Provide an optional hook that is called each time the input is updated
     */
    onChange: PropTypes.func
  });

  _defineProperty(StructuredListInput, "defaultProps", {
    onChange: function onChange() {},
    value: 'value',
    title: 'title'
  });

  var StructuredListRow = /*#__PURE__*/function (_Component4) {
    _inherits(StructuredListRow, _Component4);

    var _super4 = _createSuper(StructuredListRow);

    function StructuredListRow() {
      _classCallCheck(this, StructuredListRow);

      return _super4.apply(this, arguments);
    }

    _createClass(StructuredListRow, [{
      key: "render",
      value: function render() {
        var _this$props4 = this.props,
            onKeyDown = _this$props4.onKeyDown,
            tabIndex = _this$props4.tabIndex,
            children = _this$props4.children,
            className = _this$props4.className,
            head = _this$props4.head,
            label = _this$props4.label,
            other = _objectWithoutProperties(_this$props4, ["onKeyDown", "tabIndex", "children", "className", "head", "label"]);

        var classes = classnames("".concat(prefix$1v, "--structured-list-row"), className, _defineProperty({}, "".concat(prefix$1v, "--structured-list-row--header-row"), head));
        return label ?
        /*#__PURE__*/
        // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
        React__default.createElement("label", _extends({}, other, {
          tabIndex: tabIndex,
          className: classes,
          onKeyDown: onKeyDown
        }), children) : /*#__PURE__*/React__default.createElement("div", _extends({}, other, {
          className: classes
        }), children);
      }
    }]);

    return StructuredListRow;
  }(React.Component);

  _defineProperty(StructuredListRow, "propTypes", {
    /**
     * Provide the contents of your StructuredListRow
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify whether your StructuredListRow should be used as a header row
     */
    head: PropTypes.bool,

    /**
     * Specify whether a `<label>` should be used
     */
    label: PropTypes.bool,

    /**
     * Specify the tab index of the container node, if `<label>` is in use
     */
    tabIndex: PropTypes.number,

    /**
     * Provide a handler that is invoked on the key down event for the control,
     * if `<label>` is in use
     */
    onKeyDown: PropTypes.func
  });

  _defineProperty(StructuredListRow, "defaultProps", {
    head: false,
    label: false,
    tabIndex: 0,
    onKeyDown: function onKeyDown() {}
  });

  var StructuredListBody = /*#__PURE__*/function (_Component5) {
    _inherits(StructuredListBody, _Component5);

    var _super5 = _createSuper(StructuredListBody);

    function StructuredListBody() {
      var _this2;

      _classCallCheck(this, StructuredListBody);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this2 = _super5.call.apply(_super5, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this2), "state", {
        labelRows: null,
        rowSelected: 0
      });

      return _this2;
    }

    _createClass(StructuredListBody, [{
      key: "render",
      value: function render() {
        var _this$props5 = this.props,
            children = _this$props5.children,
            className = _this$props5.className,
            other = _objectWithoutProperties(_this$props5, ["children", "className"]);

        var classes = classnames("".concat(prefix$1v, "--structured-list-tbody"), className);
        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: classes
        }, other), children);
      }
    }]);

    return StructuredListBody;
  }(React.Component);

  _defineProperty(StructuredListBody, "propTypes", {
    /**
     * Provide the contents of your StructuredListBody
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,
    head: PropTypes.bool,

    /**
     * Provide a handler that is invoked on the key down event for the control
     */
    onKeyDown: PropTypes.func
  });

  _defineProperty(StructuredListBody, "defaultProps", {
    onKeyDown: function onKeyDown() {}
  });

  var StructuredListCell = /*#__PURE__*/function (_Component6) {
    _inherits(StructuredListCell, _Component6);

    var _super6 = _createSuper(StructuredListCell);

    function StructuredListCell() {
      _classCallCheck(this, StructuredListCell);

      return _super6.apply(this, arguments);
    }

    _createClass(StructuredListCell, [{
      key: "render",
      value: function render() {
        var _classNames3;

        var _this$props6 = this.props,
            children = _this$props6.children,
            className = _this$props6.className,
            head = _this$props6.head,
            noWrap = _this$props6.noWrap,
            other = _objectWithoutProperties(_this$props6, ["children", "className", "head", "noWrap"]);

        var classes = classnames(className, (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$1v, "--structured-list-th"), head), _defineProperty(_classNames3, "".concat(prefix$1v, "--structured-list-td"), !head), _defineProperty(_classNames3, "".concat(prefix$1v, "--structured-list-content--nowrap"), noWrap), _classNames3));
        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: classes
        }, other), children);
      }
    }]);

    return StructuredListCell;
  }(React.Component);

  _defineProperty(StructuredListCell, "propTypes", {
    /**
     * Provide the contents of your StructuredListCell
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify whether your StructuredListCell should be used as a header cell
     */
    head: PropTypes.bool,

    /**
     * Specify whether your StructuredListCell should have text wrapping
     */
    noWrap: PropTypes.bool
  });

  _defineProperty(StructuredListCell, "defaultProps", {
    head: false,
    noWrap: false
  });

  var prefix$1w = settings_1.prefix;

  var TabContent = function TabContent(props) {
    var className = props.className,
        selected = props.selected,
        children = props.children,
        other = _objectWithoutProperties(props, ["className", "selected", "children"]);

    var tabContentClasses = classnames("".concat(prefix$1w, "--tab-content"), _defineProperty({}, className, className));
    return /*#__PURE__*/React__default.createElement("div", _extends({
      role: "tabpanel"
    }, other, {
      className: tabContentClasses,
      selected: selected,
      hidden: !selected
    }), children);
  };

  TabContent.propTypes = {
    /**
     * Provide a className for the tab content container
     */
    className: PropTypes.string,

    /**
     * Specify whether the TabContent is selected
     */
    selected: PropTypes.bool,

    /**
     * Pass in content to render inside of the TabContent
     */
    children: PropTypes.node
  };
  TabContent.defaultProps = {
    selected: false
  };

  var prefix$1x = settings_1.prefix;

  var Tab = /*#__PURE__*/function (_React$Component) {
    _inherits(Tab, _React$Component);

    var _super = _createSuper(Tab);

    function Tab() {
      _classCallCheck(this, Tab);

      return _super.apply(this, arguments);
    }

    _createClass(Tab, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this = this;

        var _this$props = this.props,
            id = _this$props.id,
            className = _this$props.className,
            handleTabClick = _this$props.handleTabClick,
            handleTabKeyDown = _this$props.handleTabKeyDown,
            disabled = _this$props.disabled,
            href = _this$props.href,
            index = _this$props.index,
            label = _this$props.label,
            selected = _this$props.selected,
            tabIndex = _this$props.tabIndex,
            _onClick = _this$props.onClick,
            _onKeyDown = _this$props.onKeyDown,
            renderAnchor = _this$props.renderAnchor,
            renderContent = _this$props.renderContent,
            other = _objectWithoutProperties(_this$props, ["id", "className", "handleTabClick", "handleTabKeyDown", "disabled", "href", "index", "label", "selected", "tabIndex", "onClick", "onKeyDown", "renderAnchor", "renderContent"]);

        var classes = classnames(className, "".concat(prefix$1x, "--tabs__nav-item"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1x, "--tabs__nav-item--disabled"), disabled), _defineProperty(_classNames, "".concat(prefix$1x, "--tabs__nav-item--selected"), selected), _classNames));
        var anchorProps = {
          id: id,
          className: "".concat(prefix$1x, "--tabs__nav-link"),
          href: href,
          tabIndex: !disabled ? tabIndex : -1,
          ref: function ref(e) {
            _this.tabAnchor = e;
          }
        };
        return /*#__PURE__*/React__default.createElement("li", _extends({}, other, {
          tabIndex: -1,
          className: classes,
          onClick: function onClick(evt) {
            if (disabled) {
              return;
            }

            handleTabClick(index, evt);

            _onClick(evt);
          },
          onKeyDown: function onKeyDown(evt) {
            if (disabled) {
              return;
            }

            handleTabKeyDown(index, evt);

            _onKeyDown(evt);
          },
          role: "tab",
          "aria-selected": selected,
          "aria-disabled": disabled,
          "aria-controls": "".concat(id, "__panel")
        }), renderAnchor ? renderAnchor(anchorProps) : /*#__PURE__*/React__default.createElement("a", anchorProps, label));
      }
    }]);

    return Tab;
  }(React__default.Component);

  _defineProperty(Tab, "propTypes", {
    /**
     * The element ID for the top-level element.
     */
    id: PropTypes.string,

    /**
     * Specify an optional className to be added to your Tab
     */
    className: PropTypes.string,

    /**
     * A handler that is invoked when a user clicks on the control.
     * Reserved for usage in Tabs
     */
    handleTabClick: PropTypes.func,

    /**
     * A handler that is invoked on the key down event for the control.
     * Reserved for usage in Tabs
     */
    handleTabKeyDown: PropTypes.func,

    /**
     * Whether your Tab is disabled.
     */
    disabled: PropTypes.bool,

    /**
     * Provide a string that represents the `href` of the Tab
     */
    href: PropTypes.string.isRequired,

    /**
     * The index of your Tab in your Tabs. Reserved for usage in Tabs
     */
    index: PropTypes.number,

    /**
     * Provide the contents of your Tab
     */
    label: PropTypes.node,

    /**
     * Provide an accessibility role for your Tab
     */
    role: PropTypes.string.isRequired,

    /**
     * Provide a handler that is invoked when a user clicks on the control
     */
    onClick: PropTypes.func.isRequired,

    /**
     * Provide a handler that is invoked on the key down event for the control
     */
    onKeyDown: PropTypes.func.isRequired,

    /**
     * Whether your Tab is selected.
     * Reserved for usage in Tabs
     */
    selected: PropTypes.bool.isRequired,

    /**
     * Specify the tab index of the <a> node
     */
    tabIndex: PropTypes.number.isRequired,

    /*
     * An optional parameter to allow overriding the anchor rendering.
     * Useful for using Tab along with react-router or other client
     * side router libraries.
     **/
    renderAnchor: PropTypes.func,

    /*
     * An optional parameter to allow overriding the content rendering.
     **/
    renderContent: PropTypes.func
  });

  _defineProperty(Tab, "defaultProps", {
    role: 'presentation',
    label: 'provide a label',
    tabIndex: 0,
    href: '#',
    selected: false,
    renderContent: TabContent,
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {}
  });

  var prefix$1y = settings_1.prefix;
  var tab = /*#__PURE__*/React__default.createElement("li", {
    className: "".concat(prefix$1y, "--tabs__nav-item")
  }, /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(prefix$1y, "--tabs__nav-link")
  }, "\xA0"));

  function TabsSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$1y, "--tabs"), "".concat(prefix$1y, "--skeleton"), className)
    }, rest), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1y, "--tabs-trigger")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1y, "--tabs-trigger-text")
    }, "\xA0"), /*#__PURE__*/React__default.createElement("svg", {
      width: "10",
      height: "5",
      viewBox: "0 0 10 5",
      fillRule: "evenodd"
    }, /*#__PURE__*/React__default.createElement("path", {
      d: "M10 0L5 5 0 0z"
    }))), /*#__PURE__*/React__default.createElement("ul", {
      className: "".concat(prefix$1y, "--tabs__nav ").concat(prefix$1y, "--tabs__nav--hidden")
    }, tab, tab, tab, tab));
  }

  TabsSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$1z = settings_1.prefix;

  var Tabs = /*#__PURE__*/function (_React$Component) {
    _inherits(Tabs, _React$Component);

    var _super = _createSuper(Tabs);

    function Tabs() {
      var _this;

      _classCallCheck(this, Tabs);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {
        dropdownHidden: true
      });

      _defineProperty(_assertThisInitialized(_this), "getEnabledTabs", function () {
        return React__default.Children.toArray(_this.props.children).reduce(function (acc, tab, index) {
          return !tab.props.disabled ? acc.concat(index) : acc;
        }, []);
      });

      _defineProperty(_assertThisInitialized(_this), "getTabAt", function (index, useFresh) {
        return !useFresh && _this["tab".concat(index)] || React__default.Children.toArray(_this.props.children)[index];
      });

      _defineProperty(_assertThisInitialized(_this), "setTabAt", function (index, tabRef) {
        _this["tab".concat(index)] = tabRef;
      });

      _defineProperty(_assertThisInitialized(_this), "handleTabClick", function (onSelectionChange) {
        return function (index, evt) {
          evt.preventDefault();

          _this.selectTabAt(index, onSelectionChange);

          _this.setState({
            dropdownHidden: true
          });
        };
      });

      _defineProperty(_assertThisInitialized(_this), "getDirection", function (evt) {
        if (match(evt, ArrowLeft)) {
          return -1;
        }

        if (match(evt, ArrowRight)) {
          return 1;
        }

        return 0;
      });

      _defineProperty(_assertThisInitialized(_this), "getNextIndex", function (index, direction) {
        var enabledTabs = _this.getEnabledTabs();

        var nextIndex = Math.max(enabledTabs.indexOf(index) + direction, -1
        /* For `tab` not found in `enabledTabs` */
        );
        var nextIndexLooped = nextIndex >= 0 && nextIndex < enabledTabs.length ? nextIndex : nextIndex - Math.sign(nextIndex) * enabledTabs.length;
        return enabledTabs[nextIndexLooped];
      });

      _defineProperty(_assertThisInitialized(_this), "handleTabKeyDown", function (onSelectionChange) {
        return function (index, evt) {
          if (matches(evt, [Enter, Space])) {
            _this.selectTabAt(index, onSelectionChange);

            _this.setState({
              dropdownHidden: true
            });
          }

          if (window.matchMedia('(min-width: 42rem)').matches) {
            var nextIndex = _this.getNextIndex(index, _this.getDirection(evt));

            var tab = _this.getTabAt(nextIndex);

            if (tab && matches(evt, [ArrowLeft, ArrowRight])) {
              evt.preventDefault();

              if (_this.props.selectionMode !== 'manual') {
                _this.selectTabAt(nextIndex, onSelectionChange);
              }

              if (tab.tabAnchor) {
                tab.tabAnchor.focus();
              }
            }
          }
        };
      });

      _defineProperty(_assertThisInitialized(_this), "handleDropdownClick", function () {
        _this.setState({
          dropdownHidden: !_this.state.dropdownHidden
        });
      });

      _defineProperty(_assertThisInitialized(_this), "selectTabAt", function (index, onSelectionChange) {
        if (_this.state.selected !== index) {
          _this.setState({
            selected: index
          });

          if (typeof onSelectionChange === 'function') {
            onSelectionChange(index);
          }
        }
      });

      return _this;
    }

    _createClass(Tabs, [{
      key: "getTabs",
      value: function getTabs() {
        return React__default.Children.map(this.props.children, function (tab) {
          return tab;
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            ariaLabel = _this$props.ariaLabel,
            iconDescription = _this$props.iconDescription,
            className = _this$props.className,
            triggerHref = _this$props.triggerHref,
            role = _this$props.role,
            type = _this$props.type,
            onSelectionChange = _this$props.onSelectionChange,
            selectionMode = _this$props.selectionMode,
            tabContentClassName = _this$props.tabContentClassName,
            other = _objectWithoutProperties(_this$props, ["ariaLabel", "iconDescription", "className", "triggerHref", "role", "type", "onSelectionChange", "selectionMode", "tabContentClassName"]);
        /**
         * The tab panel acts like a tab panel when the screen is wider, but acts
         * like a select list when the screen is narrow.  In the wide case we want
         * to allow the user to use the tab key to set the focus in the tab panel
         * and then use the left and right arrow keys to navigate the tabs.  In the
         * narrow case we want to use the tab key to select different options in
         * the list.
         *
         * We set the tab index based on the different states so the browser will treat
         * the whole tab panel as a single focus component when it looks like a tab
         * panel and separate components when it looks like a select list.
         */


        var tabsWithProps = this.getTabs().map(function (tab, index) {
          var tabPanelIndex = index === _this2.state.selected ? 0 : -1;
          var tabIndex = !_this2.state.dropdownHidden ? 0 : tabPanelIndex;
          var newTab = /*#__PURE__*/React__default.cloneElement(tab, {
            index: index,
            selected: index === _this2.state.selected,
            handleTabClick: _this2.handleTabClick(onSelectionChange),
            tabIndex: tabIndex,
            ref: function ref(e) {
              _this2.setTabAt(index, e);
            },
            handleTabKeyDown: _this2.handleTabKeyDown(onSelectionChange)
          });
          return newTab;
        });
        var tabContentWithProps = React__default.Children.map(tabsWithProps, function (tab) {
          var _tab$props = tab.props,
              tabId = _tab$props.id,
              children = _tab$props.children,
              selected = _tab$props.selected,
              TabContent = _tab$props.renderContent;
          return /*#__PURE__*/React__default.createElement(TabContent, {
            id: tabId && "".concat(tabId, "__panel"),
            className: tabContentClassName,
            "aria-hidden": !selected,
            hidden: !selected,
            selected: selected,
            "aria-labelledby": tabId
          }, children);
        });
        var classes = {
          tabs: classnames("".concat(prefix$1z, "--tabs"), className, _defineProperty({}, "".concat(prefix$1z, "--tabs--container"), type === 'container')),
          tablist: classnames("".concat(prefix$1z, "--tabs__nav"), _defineProperty({}, "".concat(prefix$1z, "--tabs__nav--hidden"), this.state.dropdownHidden))
        };
        var selectedTab = this.getTabAt(this.state.selected, true);
        var selectedLabel = selectedTab ? selectedTab.props.label : '';
        return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", _extends({}, other, {
          className: classes.tabs,
          role: role
        }), /*#__PURE__*/React__default.createElement("div", {
          role: "listbox",
          "aria-label": ariaLabel,
          tabIndex: 0,
          className: "".concat(prefix$1z, "--tabs-trigger"),
          onClick: this.handleDropdownClick,
          onKeyPress: this.handleDropdownClick
        }, /*#__PURE__*/React__default.createElement("a", {
          tabIndex: -1,
          className: "".concat(prefix$1z, "--tabs-trigger-text"),
          href: triggerHref,
          onClick: this.handleDropdownClick
        }, selectedLabel), /*#__PURE__*/React__default.createElement(ChevronDown16, {
          "aria-hidden": "true"
        }, iconDescription && /*#__PURE__*/React__default.createElement("title", null, iconDescription))), /*#__PURE__*/React__default.createElement("ul", {
          role: "tablist",
          className: classes.tablist
        }, tabsWithProps)), tabContentWithProps);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var selected = _ref.selected;
        var prevSelected = state.prevSelected;
        return prevSelected === selected ? null : {
          selected: selected,
          prevSelected: selected
        };
      }
    }]);

    return Tabs;
  }(React__default.Component);

  _defineProperty(Tabs, "propTypes", {
    /**
     * Specify the text to be read by screen-readers when visiting the <Tabs>
     * component
     */
    ariaLabel: PropTypes.string,

    /**
     * Pass in a collection of <Tab> children to be rendered depending on the
     * currently selected tab
     */
    children: PropTypes.node,

    /**
     * Provide a className that is applied to the root <nav> component for the
     * <Tabs>
     */
    className: PropTypes.string,

    /**
     * Specify whether the Tab content is hidden
     */
    hidden: PropTypes.bool,

    /**
     * By default, this value is "navigation". You can also provide an alternate
     * role if it makes sense from the accessibility-side
     */
    role: PropTypes.string.isRequired,

    /**
     * Provide the type of Tab
     */
    type: PropTypes.oneOf(['default', 'container']),

    /**
     * Optionally provide an `onClick` handler that is invoked when a <Tab> is
     * clicked
     */
    onClick: PropTypes.func,

    /**
     * Optionally provide an `onKeyDown` handler that is invoked when keyed
     * navigation is triggered
     */
    onKeyDown: PropTypes.func,

    /**
     * Provide an optional handler that is called whenever the selection
     * changes. This method is called with the index of the tab that was
     * selected
     */
    onSelectionChange: PropTypes.func,

    /**
     * Provide a string that represents the `href` for the triggered <Tab>
     */
    triggerHref: PropTypes.string.isRequired,

    /**
     * Optionally provide an index for the currently selected <Tab>
     */
    selected: PropTypes.number,

    /**
     * Provide a description that is read out when a user visits the caret icon
     * for the dropdown menu of items
     */
    iconDescription: PropTypes.string.isRequired,

    /**
     * Provide a className that is applied to the <TabContent> components
     */
    tabContentClassName: PropTypes.string,

    /**
     * Choose whether or not to automatically change selection on focus
     */
    selectionMode: PropTypes.oneOf(['automatic', 'manual'])
  });

  _defineProperty(Tabs, "defaultProps", {
    iconDescription: 'show menu options',
    role: 'navigation',
    type: 'default',
    triggerHref: '#',
    selected: 0,
    ariaLabel: 'listbox',
    selectionMode: 'automatic'
  });

  var prefix$1A = settings_1.prefix;

  function TagSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["className"]);

    return /*#__PURE__*/React__default.createElement("span", _extends({
      className: classnames("".concat(prefix$1A, "--tag"), "".concat(prefix$1A, "--skeleton"), className)
    }, rest));
  }

  TagSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string
  };

  var prefix$1B = settings_1.prefix;
  var getInstanceId$8 = setupGetInstanceId();
  var TYPES = {
    red: 'Red',
    magenta: 'Magenta',
    purple: 'Purple',
    blue: 'Blue',
    cyan: 'Cyan',
    teal: 'Teal',
    green: 'Green',
    gray: 'Gray',
    'cool-gray': 'Cool-Gray',
    'warm-gray': 'Warm-Gray',
    'high-contrast': 'High-Contrast'
  };

  var Tag = function Tag(_ref) {
    var _classNames;

    var children = _ref.children,
        className = _ref.className,
        id = _ref.id,
        type = _ref.type,
        filter = _ref.filter,
        title = _ref.title,
        disabled = _ref.disabled,
        onClose = _ref.onClose,
        other = _objectWithoutProperties(_ref, ["children", "className", "id", "type", "filter", "title", "disabled", "onClose"]);

    var tagId = id || "tag-".concat(getInstanceId$8());
    var tagClasses = classnames("".concat(prefix$1B, "--tag"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1B, "--tag--disabled"), disabled), _defineProperty(_classNames, "".concat(prefix$1B, "--tag--filter"), filter), _defineProperty(_classNames, "".concat(prefix$1B, "--tag--").concat(type), type), _classNames));

    var handleClose = function handleClose(event) {
      if (onClose) {
        event.stopPropagation();
        onClose(event);
      }
    };

    return filter ? /*#__PURE__*/React__default.createElement("div", _extends({
      className: tagClasses,
      "aria-label": title !== undefined ? "".concat(title, " ").concat(children) : "Clear filter ".concat(children),
      id: tagId
    }, other), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1B, "--tag__label"),
      title: typeof children === 'string' ? children : null
    }, children !== null && children !== undefined ? children : TYPES[type]), /*#__PURE__*/React__default.createElement("button", {
      className: "".concat(prefix$1B, "--tag__close-icon"),
      onClick: handleClose,
      disabled: disabled,
      "aria-labelledby": tagId,
      title: title
    }, /*#__PURE__*/React__default.createElement(Close16, null))) : /*#__PURE__*/React__default.createElement("span", _extends({
      className: tagClasses,
      title: typeof children === 'string' ? children : null
    }, other), children !== null && children !== undefined ? children : TYPES[type]);
  };

  Tag.propTypes = {
    /**
     * Provide content to be rendered inside of a <Tag>
     */
    children: PropTypes.node,

    /**
     * Provide a custom className that is applied to the containing <span>
     */
    className: PropTypes.string,

    /**
     * Specify the type of the <Tag>
     */
    type: PropTypes.oneOf(Object.keys(TYPES)),

    /**
     * Specify if the <Tag> is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Determine if <Tag> is a filter/chip
     */
    filter: PropTypes.bool,

    /**
     * Text to show on clear filters
     */
    title: PropTypes.string,

    /**
     * Click handler for filter tag close button.
     */
    onClose: PropTypes.func,

    /**
     * Specify the id for the tag.
     */
    id: PropTypes.string
  };

  var prefix$1C = settings_1.prefix;

  var TextAreaSkeleton = function TextAreaSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["hideLabel", "className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$1C, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1C, "--label ").concat(prefix$1C, "--skeleton")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1C, "--skeleton ").concat(prefix$1C, "--text-area")
    }));
  };

  TextAreaSkeleton.propTypes = {
    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes.string
  };

  var prefix$1D = settings_1.prefix;
  var TextArea = /*#__PURE__*/React__default.forwardRef(function TextArea(_ref, ref) {
    var _classNames, _classNames3;

    var className = _ref.className,
        id = _ref.id,
        labelText = _ref.labelText,
        hideLabel = _ref.hideLabel,
        _onChange = _ref.onChange,
        _onClick = _ref.onClick,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        helperText = _ref.helperText,
        light = _ref.light,
        other = _objectWithoutProperties(_ref, ["className", "id", "labelText", "hideLabel", "onChange", "onClick", "invalid", "invalidText", "helperText", "light"]);

    var textareaProps = {
      id: id,
      onChange: function onChange(evt) {
        if (!other.disabled) {
          _onChange(evt);
        }
      },
      onClick: function onClick(evt) {
        if (!other.disabled) {
          _onClick(evt);
        }
      },
      ref: ref
    };
    var labelClasses = classnames("".concat(prefix$1D, "--label"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1D, "--visually-hidden"), hideLabel), _defineProperty(_classNames, "".concat(prefix$1D, "--label--disabled"), other.disabled), _classNames));
    var label = labelText ? /*#__PURE__*/React__default.createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var helperTextClasses = classnames("".concat(prefix$1D, "--form__helper-text"), _defineProperty({}, "".concat(prefix$1D, "--form__helper-text--disabled"), other.disabled));
    var helper = helperText ? /*#__PURE__*/React__default.createElement("div", {
      className: helperTextClasses
    }, helperText) : null;
    var errorId = id + '-error-msg';
    var error = invalid ? /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1D, "--form-requirement"),
      id: errorId
    }, invalidText) : null;
    var textareaClasses = classnames("".concat(prefix$1D, "--text-area"), className, (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$1D, "--text-area--light"), light), _defineProperty(_classNames3, "".concat(prefix$1D, "--text-area--invalid"), invalid), _classNames3));
    var input = /*#__PURE__*/React__default.createElement("textarea", _extends({}, other, textareaProps, {
      className: textareaClasses,
      "aria-invalid": invalid || null,
      "aria-describedby": invalid ? errorId : null,
      disabled: other.disabled
    }));
    return /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1D, "--form-item")
    }, label, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1D, "--text-area__wrapper"),
      "data-invalid": invalid || null
    }, invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
      className: "".concat(prefix$1D, "--text-area__invalid-icon")
    }), input), invalid ? error : helper);
  });
  TextArea.displayName = 'TextArea';
  TextArea.propTypes = {
    /**
     * Provide a custom className that is applied directly to the underlying
     * <textarea> node
     */
    className: PropTypes.string,

    /**
     * Specify the `cols` attribute for the underlying <textarea> node
     */
    cols: PropTypes.number,

    /**
     * Optionally provide the default value of the <textarea>
     */
    defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide a unique identifier for the control
     */
    id: PropTypes.string,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes.node.isRequired,

    /**
     * Optionally provide an `onChange` handler that is called whenever <textarea>
     * is updated
     */
    onChange: PropTypes.func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * <textarea> is clicked
     */
    onClick: PropTypes.func,

    /**
     * Specify the placeholder attribute for the <textarea>
     */
    placeholder: PropTypes.string,

    /**
     * Specify the rows attribute for the <textarea>
     */
    rows: PropTypes.number,

    /**
     * Provide the current value of the <textarea>
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes.bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes.string,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes.node,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify whether you want the light version of this control
     */
    light: PropTypes.bool
  };
  TextArea.defaultProps = {
    disabled: false,
    onChange: function onChange() {},
    onClick: function onClick() {},
    placeholder: '',
    rows: 4,
    cols: 50,
    invalid: false,
    invalidText: '',
    helperText: '',
    light: false
  };

  var prefix$1E = settings_1.prefix;

  var TextInputSkeleton = function TextInputSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["hideLabel", "className"]);

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: classnames("".concat(prefix$1E, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1E, "--label ").concat(prefix$1E, "--skeleton")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1E, "--skeleton ").concat(prefix$1E, "--text-input")
    }));
  };

  TextInputSkeleton.propTypes = {
    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes.string
  };

  var invalidProps = function invalidProps(_ref) {
    var invalid = _ref.invalid,
        errorId = _ref.errorId;
    return {
      'data-invalid': invalid,
      'aria-invalid': invalid,
      'aria-describedby': errorId
    };
  };

  var textInputProps = function textInputProps(_ref2) {
    var invalid = _ref2.invalid,
        sharedTextInputProps = _ref2.sharedTextInputProps,
        errorId = _ref2.errorId;
    return _objectSpread2(_objectSpread2({}, sharedTextInputProps), invalid ? invalidProps({
      invalid: invalid,
      errorId: errorId
    }) : {});
  };

  var prefix$1F = settings_1.prefix;
  var ControlledPasswordInput = /*#__PURE__*/React__default.forwardRef(function ControlledPasswordInput(_ref, ref) {
    var _classNames, _classNames2, _classNames4;

    var labelText = _ref.labelText,
        className = _ref.className,
        id = _ref.id,
        placeholder = _ref.placeholder,
        _onChange = _ref.onChange,
        _onClick = _ref.onClick,
        hideLabel = _ref.hideLabel,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        helperText = _ref.helperText,
        light = _ref.light,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'password' : _ref$type,
        togglePasswordVisibility = _ref.togglePasswordVisibility,
        _ref$tooltipPosition = _ref.tooltipPosition,
        tooltipPosition = _ref$tooltipPosition === void 0 ? 'bottom' : _ref$tooltipPosition,
        _ref$tooltipAlignment = _ref.tooltipAlignment,
        tooltipAlignment = _ref$tooltipAlignment === void 0 ? 'center' : _ref$tooltipAlignment,
        size = _ref.size,
        other = _objectWithoutProperties(_ref, ["labelText", "className", "id", "placeholder", "onChange", "onClick", "hideLabel", "invalid", "invalidText", "helperText", "light", "type", "togglePasswordVisibility", "tooltipPosition", "tooltipAlignment", "size"]);

    var errorId = id + '-error-msg';
    var textInputClasses = classnames("".concat(prefix$1F, "--text-input"), "".concat(prefix$1F, "--password-input"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1F, "--text-input--light"), light), _defineProperty(_classNames, "".concat(prefix$1F, "--text-input--invalid"), invalid), _defineProperty(_classNames, "".concat(prefix$1F, "--text-input--").concat(size), size), _classNames));

    var sharedTextInputProps = _objectSpread2({
      id: id,
      onChange: function onChange(evt) {
        if (!other.disabled) {
          _onChange(evt);
        }
      },
      onClick: function onClick(evt) {
        if (!other.disabled) {
          _onClick(evt);
        }
      },
      placeholder: placeholder,
      type: type,
      ref: ref,
      className: textInputClasses
    }, other);

    var labelClasses = classnames("".concat(prefix$1F, "--label"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$1F, "--visually-hidden"), hideLabel), _defineProperty(_classNames2, "".concat(prefix$1F, "--label--disabled"), other.disabled), _classNames2));
    var helperTextClasses = classnames("".concat(prefix$1F, "--form__helper-text"), _defineProperty({}, "".concat(prefix$1F, "--form__helper-text--disabled"), other.disabled));
    var label = labelText ? /*#__PURE__*/React__default.createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var error = invalid ? /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1F, "--form-requirement"),
      id: errorId
    }, invalidText) : null;
    var passwordIsVisible = type === 'text';
    var passwordVisibilityIcon = passwordIsVisible ? /*#__PURE__*/React__default.createElement(ViewOff16, {
      className: "".concat(prefix$1F, "--icon-visibility-off")
    }) : /*#__PURE__*/React__default.createElement(View16, {
      className: "".concat(prefix$1F, "--icon-visibility-on")
    });
    var passwordVisibilityToggleClasses = classnames("".concat(prefix$1F, "--text-input--password__visibility__toggle"), "".concat(prefix$1F, "--btn--icon-only"), "".concat(prefix$1F, "--tooltip__trigger"), "".concat(prefix$1F, "--tooltip--a11y"), (_classNames4 = {}, _defineProperty(_classNames4, "".concat(prefix$1F, "--tooltip--").concat(tooltipPosition), tooltipPosition), _defineProperty(_classNames4, "".concat(prefix$1F, "--tooltip--align-").concat(tooltipAlignment), tooltipAlignment), _classNames4));
    var input = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("input", _extends({}, textInputProps({
      invalid: invalid,
      sharedTextInputProps: sharedTextInputProps,
      errorId: errorId
    }), {
      "data-toggle-password-visibility": type === 'password'
    })), /*#__PURE__*/React__default.createElement("button", {
      type: "button",
      className: passwordVisibilityToggleClasses,
      onClick: togglePasswordVisibility
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1F, "--assistive-text")
    }, "".concat(passwordIsVisible ? 'Hide' : 'Show', " password")), passwordVisibilityIcon));
    var helper = helperText ? /*#__PURE__*/React__default.createElement("div", {
      className: helperTextClasses
    }, helperText) : null;
    return /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1F, "--form-item ").concat(prefix$1F, "--text-input-wrapper ").concat(prefix$1F, "--password-input-wrapper")
    }, label, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1F, "--text-input__field-wrapper"),
      "data-invalid": invalid || null
    }, invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
      className: "".concat(prefix$1F, "--text-input__invalid-icon")
    }), input), error ? error : helper);
  });
  ControlledPasswordInput.propTypes = {
    /**
     * Provide a custom className that is applied directly to the underlying
     * <input> node
     */
    className: PropTypes.string,

    /**
     * Optionally provide the default value of the <input>
     */
    defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide a unique identifier for the input field
     */
    id: PropTypes.string.isRequired,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes.node.isRequired,

    /**
     * Optionally provide an `onChange` handler that is called whenever <input>
     * is updated
     */
    onChange: PropTypes.func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * <input> is clicked
     */
    onClick: PropTypes.func,

    /**
     * Specify the placeholder attribute for the <input>
     */
    placeholder: PropTypes.string,

    /**
     * Provide the current value of the <input>
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify whether or not the underlying label is visually hidden
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes.bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes.string,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes.node,

    /**
     * Specify light version or default version of this control
     */
    light: PropTypes.bool,

    /**
     * Specify the direction of the tooltip for icon-only buttons.
     * Can be either top, right, bottom, or left.
     */
    tooltipPosition: PropTypes.oneOf(['top', 'right', 'bottom', 'left']),

    /**
     * Specify the alignment of the tooltip to the icon-only button.
     * Can be one of: start, center, or end.
     */
    tooltipAlignment: PropTypes.oneOf(['start', 'center', 'end']),

    /**
     * Specify the size of the Text Input. Currently supports either `small` or `large` as an option. If omitted, defaults to standard size
     */
    size: PropTypes.string
  };
  ControlledPasswordInput.defaultProps = {
    className: '${prefix}--text__input',
    disabled: false,
    onChange: function onChange() {},
    onClick: function onClick() {},
    invalid: false,
    invalidText: '',
    helperText: '',
    light: false,
    size: ''
  };

  var prefix$1G = settings_1.prefix;
  var PasswordInput = /*#__PURE__*/React__default.forwardRef(function PasswordInput(_ref, ref) {
    var _classNames, _classNames2, _classNames4;

    var labelText = _ref.labelText,
        className = _ref.className,
        id = _ref.id,
        placeholder = _ref.placeholder,
        _onChange = _ref.onChange,
        _onClick = _ref.onClick,
        hideLabel = _ref.hideLabel,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        helperText = _ref.helperText,
        light = _ref.light,
        _ref$tooltipPosition = _ref.tooltipPosition,
        tooltipPosition = _ref$tooltipPosition === void 0 ? 'bottom' : _ref$tooltipPosition,
        _ref$tooltipAlignment = _ref.tooltipAlignment,
        tooltipAlignment = _ref$tooltipAlignment === void 0 ? 'center' : _ref$tooltipAlignment,
        _ref$hidePasswordLabe = _ref.hidePasswordLabel,
        hidePasswordLabel = _ref$hidePasswordLabe === void 0 ? 'Hide password' : _ref$hidePasswordLabe,
        _ref$showPasswordLabe = _ref.showPasswordLabel,
        showPasswordLabel = _ref$showPasswordLabe === void 0 ? 'Show password' : _ref$showPasswordLabe,
        size = _ref.size,
        other = _objectWithoutProperties(_ref, ["labelText", "className", "id", "placeholder", "onChange", "onClick", "hideLabel", "invalid", "invalidText", "helperText", "light", "tooltipPosition", "tooltipAlignment", "hidePasswordLabel", "showPasswordLabel", "size"]);

    var _useState = React.useState('password'),
        _useState2 = _slicedToArray(_useState, 2),
        inputType = _useState2[0],
        setInputType = _useState2[1];

    var togglePasswordVisibility = function togglePasswordVisibility() {
      return setInputType(inputType === 'password' ? 'text' : 'password');
    };

    var errorId = id + '-error-msg';
    var textInputClasses = classnames("".concat(prefix$1G, "--text-input"), "".concat(prefix$1G, "--password-input"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1G, "--text-input--light"), light), _defineProperty(_classNames, "".concat(prefix$1G, "--text-input--invalid"), invalid), _defineProperty(_classNames, "".concat(prefix$1G, "--text-input--").concat(size), size), _classNames));

    var sharedTextInputProps = _objectSpread2({
      id: id,
      onChange: function onChange(evt) {
        if (!other.disabled) {
          _onChange(evt);
        }
      },
      onClick: function onClick(evt) {
        if (!other.disabled) {
          _onClick(evt);
        }
      },
      placeholder: placeholder,
      type: inputType,
      className: textInputClasses,
      ref: ref
    }, other);

    var labelClasses = classnames("".concat(prefix$1G, "--label"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$1G, "--visually-hidden"), hideLabel), _defineProperty(_classNames2, "".concat(prefix$1G, "--label--disabled"), other.disabled), _classNames2));
    var helperTextClasses = classnames("".concat(prefix$1G, "--form__helper-text"), _defineProperty({}, "".concat(prefix$1G, "--form__helper-text--disabled"), other.disabled));
    var label = labelText ? /*#__PURE__*/React__default.createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var error = invalid ? /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1G, "--form-requirement"),
      id: errorId
    }, invalidText) : null;
    var passwordIsVisible = inputType === 'text';
    var passwordVisibilityIcon = passwordIsVisible ? /*#__PURE__*/React__default.createElement(ViewOff16, {
      className: "".concat(prefix$1G, "--icon-visibility-off")
    }) : /*#__PURE__*/React__default.createElement(View16, {
      className: "".concat(prefix$1G, "--icon-visibility-on")
    });
    var passwordVisibilityToggleClasses = classnames("".concat(prefix$1G, "--text-input--password__visibility__toggle"), "".concat(prefix$1G, "--btn--icon-only"), "".concat(prefix$1G, "--tooltip__trigger"), "".concat(prefix$1G, "--tooltip--a11y"), (_classNames4 = {}, _defineProperty(_classNames4, "".concat(prefix$1G, "--tooltip--").concat(tooltipPosition), tooltipPosition), _defineProperty(_classNames4, "".concat(prefix$1G, "--tooltip--align-").concat(tooltipAlignment), tooltipAlignment), _classNames4));
    var input = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("input", _extends({}, textInputProps({
      invalid: invalid,
      sharedTextInputProps: sharedTextInputProps,
      errorId: errorId
    }), {
      "data-toggle-password-visibility": inputType === 'password'
    })), /*#__PURE__*/React__default.createElement("button", {
      type: "button",
      className: passwordVisibilityToggleClasses,
      onClick: togglePasswordVisibility
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1G, "--assistive-text")
    }, passwordIsVisible ? hidePasswordLabel : showPasswordLabel), passwordVisibilityIcon));
    var helper = helperText ? /*#__PURE__*/React__default.createElement("div", {
      className: helperTextClasses
    }, helperText) : null;
    return /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1G, "--form-item ").concat(prefix$1G, "--text-input-wrapper ").concat(prefix$1G, "--password-input-wrapper")
    }, label, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1G, "--text-input__field-wrapper"),
      "data-invalid": invalid || null
    }, invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
      className: "".concat(prefix$1G, "--text-input__invalid-icon")
    }), input), error ? error : helper);
  });
  PasswordInput.propTypes = {
    /**
     * Provide a custom className that is applied directly to the underlying
     * <input> node
     */
    className: PropTypes.string,

    /**
     * Optionally provide the default value of the <input>
     */
    defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide a unique identifier for the input field
     */
    id: PropTypes.string.isRequired,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes.node.isRequired,

    /**
     * Optionally provide an `onChange` handler that is called whenever <input>
     * is updated
     */
    onChange: PropTypes.func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * <input> is clicked
     */
    onClick: PropTypes.func,

    /**
     * Specify the placeholder attribute for the <input>
     */
    placeholder: PropTypes.string,

    /**
     * Provide the current value of the <input>
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify whether or not the underlying label is visually hidden
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes.bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes.string,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes.node,

    /**
     * Specify light version or default version of this control
     */
    light: PropTypes.bool,

    /**
     * Specify the direction of the tooltip for icon-only buttons.
     * Can be either top, right, bottom, or left.
     */
    tooltipPosition: PropTypes.oneOf(['top', 'right', 'bottom', 'left']),

    /**
     * Specify the alignment of the tooltip to the icon-only button.
     * Can be one of: start, center, or end.
     */
    tooltipAlignment: PropTypes.oneOf(['start', 'center', 'end']),

    /**
     * "Hide password" tooltip text on password visibility toggle
     */
    hidePasswordLabel: PropTypes.string,

    /**
     * "Show password" tooltip text on password visibility toggle
     */
    showPasswordLabel: PropTypes.string,

    /**
     * Specify the size of the Text Input. Currently supports either `small` or `large` as an option. If omitted, defaults to standard size
     */
    size: PropTypes.string
  };
  PasswordInput.defaultProps = {
    className: '${prefix}--text__input',
    disabled: false,
    onChange: function onChange() {},
    onClick: function onClick() {},
    invalid: false,
    invalidText: '',
    helperText: '',
    light: false,
    size: ''
  };

  var prefix$1H = settings_1.prefix;
  var TextInput$1 = /*#__PURE__*/React__default.forwardRef(function TextInput(_ref, ref) {
    var _classNames, _classNames2, _classNames3, _classNames4;

    var labelText = _ref.labelText,
        _ref$className = _ref.className,
        className = _ref$className === void 0 ? "".concat(prefix$1H, "--text__input") : _ref$className,
        id = _ref.id,
        placeholder = _ref.placeholder,
        type = _ref.type,
        _onChange = _ref.onChange,
        _onClick = _ref.onClick,
        hideLabel = _ref.hideLabel,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        helperText = _ref.helperText,
        light = _ref.light,
        size = _ref.size,
        inline = _ref.inline,
        other = _objectWithoutProperties(_ref, ["labelText", "className", "id", "placeholder", "type", "onChange", "onClick", "hideLabel", "invalid", "invalidText", "helperText", "light", "size", "inline"]);

    var errorId = id + '-error-msg';
    var textInputClasses = classnames("".concat(prefix$1H, "--text-input"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1H, "--text-input--light"), light), _defineProperty(_classNames, "".concat(prefix$1H, "--text-input--invalid"), invalid), _defineProperty(_classNames, "".concat(prefix$1H, "--text-input--").concat(size), size), _classNames));

    var sharedTextInputProps = _objectSpread2({
      id: id,
      onChange: function onChange(evt) {
        if (!other.disabled) {
          _onChange(evt);
        }
      },
      onClick: function onClick(evt) {
        if (!other.disabled) {
          _onClick(evt);
        }
      },
      placeholder: placeholder,
      type: type,
      ref: ref,
      className: textInputClasses,
      title: placeholder
    }, other);

    var inputWrapperClasses = classnames("".concat(prefix$1H, "--form-item"), "".concat(prefix$1H, "--text-input-wrapper"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$1H, "--text-input-wrapper--light"), light), _defineProperty(_classNames2, "".concat(prefix$1H, "--text-input-wrapper--inline"), inline), _classNames2));
    var labelClasses = classnames("".concat(prefix$1H, "--label"), (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$1H, "--visually-hidden"), hideLabel), _defineProperty(_classNames3, "".concat(prefix$1H, "--label--disabled"), other.disabled), _defineProperty(_classNames3, "".concat(prefix$1H, "--label--inline"), inline), _defineProperty(_classNames3, "".concat(prefix$1H, "--label--inline--").concat(size), inline && !!size), _classNames3));
    var helperTextClasses = classnames("".concat(prefix$1H, "--form__helper-text"), (_classNames4 = {}, _defineProperty(_classNames4, "".concat(prefix$1H, "--form__helper-text--disabled"), other.disabled), _defineProperty(_classNames4, "".concat(prefix$1H, "--form__helper-text--inline"), inline), _classNames4));
    var fieldOuterWrapperClasses = classnames("".concat(prefix$1H, "--text-input__field-outer-wrapper"), _defineProperty({}, "".concat(prefix$1H, "--text-input__field-outer-wrapper--inline"), inline));
    var label = labelText ? /*#__PURE__*/React__default.createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var error = invalid ? /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1H, "--form-requirement"),
      id: errorId
    }, invalidText) : null;
    var input = /*#__PURE__*/React__default.createElement("input", textInputProps({
      invalid: invalid,
      sharedTextInputProps: sharedTextInputProps,
      errorId: errorId
    }));
    var helper = helperText ? /*#__PURE__*/React__default.createElement("div", {
      className: helperTextClasses
    }, helperText) : null;

    var _useContext = React.useContext(FormContext),
        isFluid = _useContext.isFluid;

    return /*#__PURE__*/React__default.createElement("div", {
      className: inputWrapperClasses
    }, !inline ? label : /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1H, "--text-input__label-helper-wrapper")
    }, label, !isFluid && helper), /*#__PURE__*/React__default.createElement("div", {
      className: fieldOuterWrapperClasses
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1H, "--text-input__field-wrapper"),
      "data-invalid": invalid || null
    }, invalid && /*#__PURE__*/React__default.createElement(WarningFilled16, {
      className: "".concat(prefix$1H, "--text-input__invalid-icon")
    }), input, isFluid && /*#__PURE__*/React__default.createElement("hr", {
      className: "".concat(prefix$1H, "--text-input__divider")
    }), isFluid && !inline && error), !isFluid && error, !invalid && !isFluid && !inline && helper));
  });
  TextInput$1.PasswordInput = PasswordInput;
  TextInput$1.ControlledPasswordInput = ControlledPasswordInput;
  TextInput$1.propTypes = {
    /**
     * Specify an optional className to be applied to the <input> node
     */
    className: PropTypes.string,

    /**
     * Optionally provide the default value of the <input>
     */
    defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify whether the <input> should be disabled
     */
    disabled: PropTypes.bool,

    /**
     * Specify a custom `id` for the <input>
     */
    id: PropTypes.string.isRequired,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes.node.isRequired,

    /**
     * Optionally provide an `onChange` handler that is called whenever <input>
     * is updated
     */
    onChange: PropTypes.func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * <input> is clicked
     */
    onClick: PropTypes.func,

    /**
     * Specify the placeholder attribute for the <input>
     */
    placeholder: PropTypes.string,

    /**
     * Specify the size of the Text Input. Currently supports either `sm` or `xl` as an option.
     */
    size: PropTypes.oneOf(['sm', 'xl']),

    /**
     * Specify the type of the <input>
     */
    type: PropTypes.string,

    /**
     * Specify the value of the <input>
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes.bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes.string,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes.node,

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool,

    /**
     * `true` to use the inline version.
     */
    inline: PropTypes.bool
  };
  TextInput$1.defaultProps = {
    disabled: false,
    type: 'text',
    onChange: function onChange() {},
    onClick: function onClick() {},
    invalid: false,
    invalidText: '',
    helperText: '',
    light: false,
    inline: false
  };

  var prefix$1I = settings_1.prefix;
  var Tile$1 = /*#__PURE__*/function (_Component) {
    _inherits(Tile, _Component);

    var _super = _createSuper(Tile);

    function Tile() {
      _classCallCheck(this, Tile);

      return _super.apply(this, arguments);
    }

    _createClass(Tile, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            children = _this$props.children,
            className = _this$props.className,
            light = _this$props.light,
            other = _objectWithoutProperties(_this$props, ["children", "className", "light"]);

        var tileClasses = classnames("".concat(prefix$1I, "--tile"), _defineProperty({}, "".concat(prefix$1I, "--tile--light"), light), className);
        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: tileClasses
        }, other), children);
      }
    }]);

    return Tile;
  }(React.Component);

  _defineProperty(Tile$1, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes.node,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes.bool
  });

  _defineProperty(Tile$1, "defaultProps", {
    light: false
  });

  var ClickableTile = /*#__PURE__*/function (_Component2) {
    _inherits(ClickableTile, _Component2);

    var _super2 = _createSuper(ClickableTile);

    function ClickableTile() {
      var _this;

      _classCallCheck(this, ClickableTile);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super2.call.apply(_super2, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {});

      _defineProperty(_assertThisInitialized(_this), "handleClick", function (evt) {
        evt.persist();

        _this.setState({
          clicked: !_this.state.clicked
        }, function () {
          _this.props.handleClick(evt);
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleKeyDown", function (evt) {
        evt.persist();

        if (matches(evt, [Enter, Space])) {
          _this.setState({
            clicked: !_this.state.clicked
          }, function () {
            _this.props.handleKeyDown(evt);
          });
        } else {
          _this.props.handleKeyDown(evt);
        }
      });

      return _this;
    }

    _createClass(ClickableTile, [{
      key: "render",
      value: function render() {
        var _classNames2;

        var _this$props2 = this.props,
            children = _this$props2.children,
            href = _this$props2.href,
            className = _this$props2.className,
            handleClick = _this$props2.handleClick,
            handleKeyDown = _this$props2.handleKeyDown,
            clicked = _this$props2.clicked,
            light = _this$props2.light,
            other = _objectWithoutProperties(_this$props2, ["children", "href", "className", "handleClick", "handleKeyDown", "clicked", "light"]);

        var classes = classnames("".concat(prefix$1I, "--tile"), "".concat(prefix$1I, "--tile--clickable"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$1I, "--tile--is-clicked"), this.state.clicked), _defineProperty(_classNames2, "".concat(prefix$1I, "--tile--light"), light), _classNames2), className);
        return /*#__PURE__*/React__default.createElement("a", _extends({
          href: href,
          className: classes
        }, other, {
          onClick: this.handleClick,
          onKeyDown: this.handleKeyDown
        }), children);
      }
    }], [{
      key: "getDerivedStateFromProps",
      // eslint-disable-next-line react/prop-types
      value: function getDerivedStateFromProps(_ref, state) {
        var clicked = _ref.clicked;
        var prevClicked = state.prevClicked;
        return prevClicked === clicked ? null : {
          clicked: clicked,
          prevClicked: clicked
        };
      }
    }]);

    return ClickableTile;
  }(React.Component);

  _defineProperty(ClickableTile, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes.node,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * The href for the link.
     */
    href: PropTypes.string,

    /**
     * The rel property for the link.
     */
    rel: PropTypes.string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes.bool,

    /**
     * Specify the function to run when the ClickableTile is clicked
     */
    handleClick: PropTypes.func,

    /**
     * Specify the function to run when the ClickableTile is interacted with via a keyboard
     */
    handleKeyDown: PropTypes.func
  });

  _defineProperty(ClickableTile, "defaultProps", {
    clicked: false,
    handleClick: function handleClick() {},
    handleKeyDown: function handleKeyDown() {},
    light: false
  });

  var SelectableTile = /*#__PURE__*/function (_Component3) {
    _inherits(SelectableTile, _Component3);

    var _super3 = _createSuper(SelectableTile);

    function SelectableTile() {
      var _this2;

      _classCallCheck(this, SelectableTile);

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this2 = _super3.call.apply(_super3, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this2), "state", {
        selected: _this2.props.selected
      });

      _defineProperty(_assertThisInitialized(_this2), "handleClick", function (evt) {
        evt.preventDefault();
        evt.persist();

        _this2.setState({
          selected: !_this2.state.selected
        }, function () {
          _this2.props.handleClick(evt);

          _this2.props.onChange(evt);
        });
      });

      _defineProperty(_assertThisInitialized(_this2), "handleKeyDown", function (evt) {
        evt.persist();

        if (matches(evt, [Enter, Space])) {
          evt.preventDefault();

          _this2.setState({
            selected: !_this2.state.selected
          }, function () {
            _this2.props.handleKeyDown(evt);

            _this2.props.onChange(evt);
          });
        } else {
          _this2.props.handleKeyDown(evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this2), "handleOnChange", function (event) {
        _this2.setState({
          selected: event.target.checked
        });

        _this2.props.onChange(event);
      });

      return _this2;
    }

    _createClass(SelectableTile, [{
      key: "render",
      value: function render() {
        var _classNames3,
            _this3 = this;

        var _this$props3 = this.props,
            children = _this$props3.children,
            id = _this$props3.id,
            tabIndex = _this$props3.tabIndex,
            value = _this$props3.value,
            name = _this$props3.name,
            title = _this$props3.title,
            iconDescription = _this$props3.iconDescription,
            className = _this$props3.className,
            handleClick = _this$props3.handleClick,
            handleKeyDown = _this$props3.handleKeyDown,
            onChange = _this$props3.onChange,
            light = _this$props3.light,
            other = _objectWithoutProperties(_this$props3, ["children", "id", "tabIndex", "value", "name", "title", "iconDescription", "className", "handleClick", "handleKeyDown", "onChange", "light"]);

        var classes = classnames("".concat(prefix$1I, "--tile"), "".concat(prefix$1I, "--tile--selectable"), (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$1I, "--tile--is-selected"), this.state.selected), _defineProperty(_classNames3, "".concat(prefix$1I, "--tile--light"), light), _classNames3), className);
        return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("input", {
          ref: function ref(input) {
            _this3.input = input;
          },
          tabIndex: -1,
          id: id,
          className: "".concat(prefix$1I, "--tile-input"),
          value: value,
          onChange: this.handleOnChange,
          type: "checkbox",
          name: name,
          title: title,
          checked: this.state.selected
        }), /*#__PURE__*/React__default.createElement("label", _extends({
          htmlFor: id,
          className: classes,
          tabIndex: tabIndex
        }, other, {
          onClick: this.handleClick,
          onKeyDown: this.handleKeyDown
        }), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1I, "--tile__checkmark")
        }, /*#__PURE__*/React__default.createElement(CheckmarkFilled16, null)), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1I, "--tile-content")
        }, children)));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, state) {
        var selected = _ref2.selected;
        var prevSelected = state.prevSelected;
        return prevSelected === selected ? null : {
          selected: selected,
          prevSelected: selected
        };
      }
    }]);

    return SelectableTile;
  }(React.Component);

  _defineProperty(SelectableTile, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes.node,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * `true` to select this tile.
     */
    selected: PropTypes.bool,

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes.string,

    /**
     * The value of the `<input>`.
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,

    /**
     * The `name` of the `<input>`.
     */
    name: PropTypes.string,

    /**
     * The `title` of the `<input>`.
     */
    title: PropTypes.string,

    /**
     * The empty handler of the `<input>`.
     */
    onChange: PropTypes.func,

    /**
     * The description of the checkmark icon.
     */
    iconDescription: deprecate(PropTypes.string, 'The `iconDescription` prop for `RadioTile` is no longer needed and has ' + 'been deprecated. It will be moved in the next major release.'),

    /**
     * Specify the tab index of the wrapper element
     */
    tabIndex: PropTypes.number,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes.bool,

    /**
     * Specify the function to run when the SelectableTile is clicked
     */
    handleClick: PropTypes.func,

    /**
     * Specify the function to run when the SelectableTile is interacted with via a keyboard
     */
    handleKeyDown: PropTypes.func
  });

  _defineProperty(SelectableTile, "defaultProps", {
    value: 'value',
    title: 'title',
    selected: false,
    handleClick: function handleClick() {},
    handleKeyDown: function handleKeyDown() {},
    onChange: function onChange() {},
    tabIndex: 0,
    light: false
  });

  var ExpandableTile = /*#__PURE__*/function (_Component4) {
    _inherits(ExpandableTile, _Component4);

    var _super4 = _createSuper(ExpandableTile);

    function ExpandableTile() {
      var _this4;

      _classCallCheck(this, ExpandableTile);

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      _this4 = _super4.call.apply(_super4, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this4), "state", {});

      _defineProperty(_assertThisInitialized(_this4), "componentDidMount", function () {
        if (_this4.tile) {
          var getStyle = window.getComputedStyle(_this4.tile, null);

          if (_this4.aboveTheFold) {
            _this4.setState({
              tileMaxHeight: _this4.aboveTheFold.getBoundingClientRect().height,
              tilePadding: parseInt(getStyle.getPropertyValue('padding-top'), 10) + parseInt(getStyle.getPropertyValue('padding-bottom'), 10)
            });
          }
        }
      });

      _defineProperty(_assertThisInitialized(_this4), "componentDidUpdate", function (prevProps) {
        if (prevProps.expanded !== _this4.props.expanded) _this4.setMaxHeight();
      });

      _defineProperty(_assertThisInitialized(_this4), "setMaxHeight", function () {
        if (_this4.state.expanded ? _this4.tileContent : _this4.aboveTheFold) {
          _this4.setState({
            tileMaxHeight: _this4.state.expanded ? _this4.tileContent.getBoundingClientRect().height : _this4.aboveTheFold.getBoundingClientRect().height
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this4), "handleClick", function (evt) {
        if (!_this4.props.onBeforeClick(evt)) return;
        evt.persist();

        _this4.setState({
          expanded: !_this4.state.expanded
        }, function () {
          _this4.setMaxHeight();

          _this4.props.handleClick(evt);
        });
      });

      _defineProperty(_assertThisInitialized(_this4), "handleKeyDown", function (evt) {
        if (matches(evt, [Enter, Space])) {
          evt.persist();

          _this4.setState({
            expanded: !_this4.state.expanded
          }, function () {
            _this4.setMaxHeight();

            _this4.props.handleClick(evt);
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this4), "getChildren", function () {
        return React__default.Children.toArray(_this4.props.children);
      });

      return _this4;
    }

    _createClass(ExpandableTile, [{
      key: "render",
      value: function render() {
        var _classNames4,
            _this5 = this;

        var _this$props4 = this.props,
            tabIndex = _this$props4.tabIndex,
            className = _this$props4.className,
            expanded = _this$props4.expanded,
            tileMaxHeight = _this$props4.tileMaxHeight,
            tilePadding = _this$props4.tilePadding,
            handleClick = _this$props4.handleClick,
            tileCollapsedIconText = _this$props4.tileCollapsedIconText,
            tileExpandedIconText = _this$props4.tileExpandedIconText,
            onBeforeClick = _this$props4.onBeforeClick,
            light = _this$props4.light,
            other = _objectWithoutProperties(_this$props4, ["tabIndex", "className", "expanded", "tileMaxHeight", "tilePadding", "handleClick", "tileCollapsedIconText", "tileExpandedIconText", "onBeforeClick", "light"]);

        var isExpanded = this.state.expanded;
        var classes = classnames("".concat(prefix$1I, "--tile"), "".concat(prefix$1I, "--tile--expandable"), (_classNames4 = {}, _defineProperty(_classNames4, "".concat(prefix$1I, "--tile--is-expanded"), isExpanded), _defineProperty(_classNames4, "".concat(prefix$1I, "--tile--light"), light), _classNames4), className);
        var tileStyle = {
          maxHeight: isExpanded ? null : this.state.tileMaxHeight + this.state.tilePadding
        };
        var childrenAsArray = this.getChildren();
        return (
          /*#__PURE__*/
          // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
          React__default.createElement("button", _extends({
            ref: function ref(tile) {
              _this5.tile = tile;
            },
            style: tileStyle,
            className: classes,
            "aria-expanded": isExpanded,
            title: isExpanded ? tileExpandedIconText : tileCollapsedIconText
          }, other, {
            onClick: this.handleClick,
            tabIndex: tabIndex
          }), /*#__PURE__*/React__default.createElement("div", {
            ref: function ref(tileContent) {
              _this5.tileContent = tileContent;
            }
          }, /*#__PURE__*/React__default.createElement("div", {
            ref: function ref(aboveTheFold) {
              _this5.aboveTheFold = aboveTheFold;
            },
            className: "".concat(prefix$1I, "--tile-content")
          }, childrenAsArray[0]), /*#__PURE__*/React__default.createElement("div", {
            className: "".concat(prefix$1I, "--tile__chevron")
          }, /*#__PURE__*/React__default.createElement(ChevronDown16, null)), /*#__PURE__*/React__default.createElement("div", {
            className: "".concat(prefix$1I, "--tile-content")
          }, childrenAsArray[1])))
        );
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps( // eslint-disable-next-line react/prop-types
      _ref3, state) {
        var expanded = _ref3.expanded,
            tileMaxHeight = _ref3.tileMaxHeight,
            tilePadding = _ref3.tilePadding;
        var prevExpanded = state.prevExpanded,
            prevTileMaxHeight = state.prevTileMaxHeight,
            prevTilePadding = state.prevTilePadding,
            currentExpanded = state.expanded,
            currentTileMaxHeight = state.tileMaxHeight,
            currentTilePadding = state.tilePadding;
        var expandedChanged = prevExpanded !== expanded;
        var tileMaxHeightChanged = prevTileMaxHeight !== tileMaxHeight;
        var tilePaddingChanged = prevTilePadding !== tilePadding;
        return !expandedChanged && !tileMaxHeightChanged && !tilePaddingChanged ? null : {
          expanded: !expandedChanged ? currentExpanded : expanded,
          tileMaxHeight: !tileMaxHeightChanged ? currentTileMaxHeight : tileMaxHeight,
          tilePadding: !tilePaddingChanged ? currentTilePadding : tilePadding,
          prevExpanded: expanded,
          prevTileMaxHeight: tileMaxHeight,
          prevTilePadding: tilePadding
        };
      }
    }]);

    return ExpandableTile;
  }(React.Component);

  _defineProperty(ExpandableTile, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes.node,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * `true` if the tile is expanded.
     */
    expanded: PropTypes.bool,

    /**
     * optional handler to decide whether to ignore a click. returns false if click should be ignored
     */
    onBeforeClick: PropTypes.func,

    /**
     * The `tabindex` attribute.
     */
    tabIndex: PropTypes.number,

    /**
     * The description of the "collapsed" icon that can be read by screen readers.
     */
    tileCollapsedIconText: PropTypes.string,

    /**
     * The description of the "expanded" icon that can be read by screen readers.
     */
    tileExpandedIconText: PropTypes.string,

    /**
     * An ID that can be provided to aria-labelledby
     */
    id: PropTypes.string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes.bool,

    /**
     * Specify the function to run when the ExpandableTile is clicked
     */
    handleClick: PropTypes.func
  });

  _defineProperty(ExpandableTile, "defaultProps", {
    tabIndex: 0,
    expanded: false,
    tileMaxHeight: 0,
    tilePadding: 0,
    onBeforeClick: function onBeforeClick() {
      return true;
    },
    handleClick: function handleClick() {},
    tileCollapsedIconText: 'Interact to expand Tile',
    tileExpandedIconText: 'Interact to collapse Tile',
    light: false
  });

  var TileAboveTheFoldContent = /*#__PURE__*/function (_Component5) {
    _inherits(TileAboveTheFoldContent, _Component5);

    var _super5 = _createSuper(TileAboveTheFoldContent);

    function TileAboveTheFoldContent() {
      _classCallCheck(this, TileAboveTheFoldContent);

      return _super5.apply(this, arguments);
    }

    _createClass(TileAboveTheFoldContent, [{
      key: "render",
      value: function render() {
        var children = this.props.children;
        return /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1I, "--tile-content__above-the-fold")
        }, children);
      }
    }]);

    return TileAboveTheFoldContent;
  }(React.Component);

  _defineProperty(TileAboveTheFoldContent, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes.node
  });

  var TileBelowTheFoldContent = /*#__PURE__*/function (_Component6) {
    _inherits(TileBelowTheFoldContent, _Component6);

    var _super6 = _createSuper(TileBelowTheFoldContent);

    function TileBelowTheFoldContent() {
      _classCallCheck(this, TileBelowTheFoldContent);

      return _super6.apply(this, arguments);
    }

    _createClass(TileBelowTheFoldContent, [{
      key: "render",
      value: function render() {
        var children = this.props.children;
        return /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1I, "--tile-content__below-the-fold")
        }, children);
      }
    }]);

    return TileBelowTheFoldContent;
  }(React.Component);

  _defineProperty(TileBelowTheFoldContent, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes.node
  });

  var prefix$1J = settings_1.prefix;

  function RadioTile(_ref) {
    var _classNames;

    var children = _ref.children,
        className = _ref.className,
        iconDescription = _ref.iconDescription,
        light = _ref.light,
        checked = _ref.checked,
        name = _ref.name,
        value = _ref.value,
        id = _ref.id,
        onChange = _ref.onChange,
        tabIndex = _ref.tabIndex,
        other = _objectWithoutProperties(_ref, ["children", "className", "iconDescription", "light", "checked", "name", "value", "id", "onChange", "tabIndex"]);

    var _useRef = React.useRef(id || uid()),
        inputId = _useRef.current;

    var classes = classnames(className, "".concat(prefix$1J, "--tile"), "".concat(prefix$1J, "--tile--selectable"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1J, "--tile--is-selected"), checked), _defineProperty(_classNames, "".concat(prefix$1J, "--tile--light"), light), _classNames));

    function handleOnChange(evt) {
      onChange(value, name, evt);
    }

    function handleOnKeyDown(evt) {
      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
        onChange(value, name, evt);
      }
    }

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("input", _extends({}, other, {
      type: "radio",
      checked: checked,
      name: name,
      value: value,
      className: "".concat(prefix$1J, "--tile-input"),
      onChange: handleOnChange,
      id: inputId
    })), /*#__PURE__*/React__default.createElement("label", {
      htmlFor: inputId,
      className: classes,
      tabIndex: tabIndex,
      onKeyDown: handleOnKeyDown
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1J, "--tile__checkmark")
    }, /*#__PURE__*/React__default.createElement(CheckmarkFilled16, null)), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1J, "--tile-content")
    }, children)));
  }

  RadioTile.propTypes = {
    /**
     * `true` if this tile should be selected.
     */
    checked: PropTypes.bool,

    /**
     * The tile content.
     */
    children: PropTypes.node,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * `true` if the `<input>` should be checked at initialization.
     */
    defaultChecked: PropTypes.bool,

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes.string,

    /**
     * The `name` of the `<input>`.
     */
    name: PropTypes.string,

    /**
     * The description of the tile checkmark icon.
     */
    iconDescription: deprecate(PropTypes.string, 'The `iconDescription` prop for `RadioTile` is no longer needed and has ' + 'been deprecated. It will be moved in the next major release.'),

    /**
     * The handler of the massaged `change` event on the `<input>`.
     */
    onChange: PropTypes.func,

    /**
     * The `value` of the `<input>`.
     */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,

    /**
     * Specify the tab index of the wrapper element
     */
    tabIndex: PropTypes.number,

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool
  };
  RadioTile.defaultProps = {
    onChange: function onChange() {},
    tabIndex: 0,
    light: false
  };

  var prefix$1K = settings_1.prefix;

  var TileGroup = /*#__PURE__*/function (_React$Component) {
    _inherits(TileGroup, _React$Component);

    var _super = _createSuper(TileGroup);

    function TileGroup() {
      var _this;

      _classCallCheck(this, TileGroup);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {
        selected: _this.props.valueSelected || _this.props.defaultSelected || null,
        prevValueSelected: _this.props.valueSelected
      });

      _defineProperty(_assertThisInitialized(_this), "getRadioTiles", function () {
        var childrenArray = React__default.Children.toArray(_this.props.children);
        var children = childrenArray.map(function (tileRadio) {
          var _tileRadio$props = tileRadio.props,
              value = _tileRadio$props.value,
              other = _objectWithoutProperties(_tileRadio$props, ["value"]);
          /* istanbul ignore if */


          if (typeof tileRadio.props.checked !== 'undefined') {
             warning_1(false, "Instead of using the checked property on the RadioTile, set\n            the defaultSelected property or valueSelected property on the TileGroup.") ;
          }

          return /*#__PURE__*/React__default.createElement(RadioTile, _extends({}, other, {
            name: _this.props.name,
            key: value,
            value: value,
            onChange: _this.handleChange,
            checked: value === _this.state.selected
          }));
        });
        return children;
      });

      _defineProperty(_assertThisInitialized(_this), "handleChange", function (newSelection, value, evt) {
        if (newSelection !== _this.state.selected) {
          _this.setState({
            selected: newSelection
          });

          _this.props.onChange(newSelection, _this.props.name, evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "renderLegend", function (legend) {
        if (legend) {
          return /*#__PURE__*/React__default.createElement("legend", null, legend);
        }
      });

      return _this;
    }

    _createClass(TileGroup, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            disabled = _this$props.disabled,
            _this$props$className = _this$props.className,
            className = _this$props$className === void 0 ? "".concat(prefix$1K, "--tile-group") : _this$props$className,
            legend = _this$props.legend;
        return /*#__PURE__*/React__default.createElement("fieldset", {
          className: className,
          disabled: disabled
        }, this.renderLegend(legend), /*#__PURE__*/React__default.createElement("div", null, this.getRadioTiles()));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var valueSelected = _ref.valueSelected,
            defaultSelected = _ref.defaultSelected;
        var prevValueSelected = state.prevValueSelected;
        return prevValueSelected === valueSelected ? null : {
          selected: valueSelected || defaultSelected || null,
          prevValueSelected: valueSelected
        };
      }
    }]);

    return TileGroup;
  }(React__default.Component);

  _defineProperty(TileGroup, "propTypes", {
    /**
     * Provide a collection of <RadioTile> components to render in the group
     */
    children: PropTypes.node,

    /**
     * Provide an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify the the value of <RadioTile> to be selected by default
     */
    defaultSelected: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * Specify the name of the underlying <input> nodes
     */
    name: PropTypes.string.isRequired,

    /**
     * Specify whether the group is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Provide an optional `onChange` hook that is called whenever the value of
     * the group changes
     */
    onChange: PropTypes.func,

    /**
     * Provide an optional legend for this group
     */
    legend: PropTypes.string,

    /**
     * Specify the value that is currently selected in the group
     */
    valueSelected: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  });

  _defineProperty(TileGroup, "defaultProps", {
    onChange:
    /* istanbul ignore next */
    function onChange() {}
  });

  var prefix$1L = settings_1.prefix;

  var TimePicker = /*#__PURE__*/function (_Component) {
    _inherits(TimePicker, _Component);

    var _super = _createSuper(TimePicker);

    function TimePicker() {
      var _this;

      _classCallCheck(this, TimePicker);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty(_assertThisInitialized(_this), "state", {});

      return _this;
    }

    _createClass(TimePicker, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this2 = this,
            _classNames2,
            _classNames3;

        var _this$props = this.props,
            children = _this$props.children,
            className = _this$props.className,
            id = _this$props.id,
            labelText = _this$props.labelText,
            type = _this$props.type,
            pattern = _this$props.pattern,
            _onChange = _this$props.onChange,
            _onClick = _this$props.onClick,
            _onBlur = _this$props.onBlur,
            placeholder = _this$props.placeholder,
            maxLength = _this$props.maxLength,
            invalidText = _this$props.invalidText,
            invalid = _this$props.invalid,
            hideLabel = _this$props.hideLabel,
            light = _this$props.light,
            other = _objectWithoutProperties(_this$props, ["children", "className", "id", "labelText", "type", "pattern", "onChange", "onClick", "onBlur", "placeholder", "maxLength", "invalidText", "invalid", "hideLabel", "light"]);

        var timePickerInputProps = {
          className: classnames("".concat(prefix$1L, "--time-picker__input-field"), "".concat(prefix$1L, "--text-input"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1L, "--text-input--light"), light), _defineProperty(_classNames, "".concat(prefix$1L, "--text-input--invalid"), invalid), _classNames)),
          onChange: function onChange(evt) {
            if (!other.disabled) {
              _this2.setState({
                value: evt.target.value
              });

              _onChange(evt);
            }
          },
          onClick: function onClick(evt) {
            if (!other.disabled) {
              _this2.setState({
                value: evt.target.value
              });

              _onClick(evt);
            }
          },
          onBlur: function onBlur(evt) {
            if (!other.disabled) {
              _this2.setState({
                value: evt.target.value
              });

              _onBlur(evt);
            }
          },
          pattern: pattern,
          placeholder: placeholder,
          maxLength: maxLength,
          id: id,
          type: type,
          value: this.state.value
        };
        var timePickerClasses = classnames((_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix$1L, "--time-picker"), true), _defineProperty(_classNames2, "".concat(prefix$1L, "--time-picker--light"), light), _defineProperty(_classNames2, className, className), _classNames2));
        var labelClasses = classnames("".concat(prefix$1L, "--label"), (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix$1L, "--visually-hidden"), hideLabel), _defineProperty(_classNames3, "".concat(prefix$1L, "--label--disabled"), other.disabled), _classNames3));
        var label = labelText ? /*#__PURE__*/React__default.createElement("label", {
          htmlFor: id,
          className: labelClasses
        }, labelText) : null;
        var error = invalid ? /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1L, "--form-requirement")
        }, invalidText) : null;
        return /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1L, "--form-item")
        }, label, /*#__PURE__*/React__default.createElement("div", {
          className: timePickerClasses
        }, /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1L, "--time-picker__input")
        }, /*#__PURE__*/React__default.createElement("input", _extends({}, other, timePickerInputProps, {
          "data-invalid": invalid ? invalid : undefined
        }))), children), error);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var value = _ref.value;
        var prevValue = state.prevValue;
        return prevValue === value ? null : {
          value: value,
          prevValue: value
        };
      }
    }]);

    return TimePicker;
  }(React.Component);

  _defineProperty(TimePicker, "propTypes", {
    /**
     * Pass in the children that will be rendered next to the form control
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * Specify a custom `id` for the <input>
     */
    id: PropTypes.string.isRequired,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes.node,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * <input> is clicked
     */
    onClick: PropTypes.func,

    /**
     * Optionally provide an `onChange` handler that is called whenever <input>
     * is updated
     */
    onChange: PropTypes.func,

    /**
     * Optionally provide an `onBlur` handler that is called whenever the
     * <input> loses focus
     */
    onBlur: PropTypes.func,

    /**
     * Specify the type of the <input>
     */
    type: PropTypes.string,

    /**
     * Specify the regular expression working as the pattern of the time string in <input>
     */
    pattern: PropTypes.string,

    /**
     * Specify the placeholder attribute for the <input>
     */
    placeholder: PropTypes.string,

    /**
     * Specify the maximum length of the time string in <input>
     */
    maxLength: PropTypes.number,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes.bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes.string,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes.bool,

    /**
     * Specify whether the <input> should be disabled
     */
    disabled: PropTypes.bool,

    /**
     * Specify the value of the <input>
     */
    value: PropTypes.string,

    /**
     * `true` to use the light version.
     */
    light: PropTypes.bool
  });

  _defineProperty(TimePicker, "defaultProps", {
    type: 'text',
    pattern: '(1[012]|[1-9]):[0-5][0-9](\\s)?',
    placeholder: 'hh:mm',
    maxLength: 5,
    invalidText: 'Invalid time format.',
    invalid: false,
    disabled: false,
    onChange: function onChange() {},
    onClick: function onClick() {},
    onBlur: function onBlur() {},
    light: false
  });

  var prefix$1M = settings_1.prefix;

  var TimePickerSelect = /*#__PURE__*/function (_Component) {
    _inherits(TimePickerSelect, _Component);

    var _super = _createSuper(TimePickerSelect);

    function TimePickerSelect() {
      _classCallCheck(this, TimePickerSelect);

      return _super.apply(this, arguments);
    }

    _createClass(TimePickerSelect, [{
      key: "render",
      value: function render() {
        var _classNames;

        var _this$props = this.props,
            id = _this$props.id,
            disabled = _this$props.disabled,
            children = _this$props.children,
            iconDescription = _this$props.iconDescription,
            className = _this$props.className,
            hideLabel = _this$props.hideLabel,
            labelText = _this$props.labelText,
            inline = _this$props.inline,
            other = _objectWithoutProperties(_this$props, ["id", "disabled", "children", "iconDescription", "className", "hideLabel", "labelText", "inline"]);

        var selectClasses = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1M, "--select"), true), _defineProperty(_classNames, "".concat(prefix$1M, "--time-picker__select"), true), _defineProperty(_classNames, className, className), _classNames));
        var labelClasses = classnames("".concat(prefix$1M, "--label"), _defineProperty({}, "".concat(prefix$1M, "--visually-hidden"), hideLabel));
        var label = labelText ? /*#__PURE__*/React__default.createElement("label", {
          htmlFor: id,
          className: labelClasses
        }, labelText) : null;
        return /*#__PURE__*/React__default.createElement("div", {
          className: selectClasses
        }, label, /*#__PURE__*/React__default.createElement("select", _extends({}, other, {
          id: id,
          className: "".concat(prefix$1M, "--select-input"),
          disabled: disabled
        }), children), /*#__PURE__*/React__default.createElement(ChevronDown16, {
          className: "".concat(prefix$1M, "--select__arrow"),
          "aria-label": iconDescription
        }, iconDescription && /*#__PURE__*/React__default.createElement("title", null, iconDescription)));
      }
    }]);

    return TimePickerSelect;
  }(React.Component);

  _defineProperty(TimePickerSelect, "propTypes", {
    /**
     * Provide the contents of your TimePickerSelect
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the node containing the label and the select box
     */
    className: PropTypes.string,

    /**
     * Specify a custom `id` for the `<select>`
     */
    id: PropTypes.string.isRequired,

    /**
     * Specify whether you want the inline version of this control
     */
    inline: PropTypes.bool,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes.bool,

    /**
     * Optionally provide the default value of the `<select>`
     */
    defaultValue: PropTypes.any,

    /**
     * Provide a description for the twistie icon that can be read by screen readers
     */
    iconDescription: PropTypes.string.isRequired,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: deprecate(PropTypes.bool, 'The `hideLabel` prop for `TimePickerSelect` is no longer needed and has ' + 'been deprecated. It will be removed in the next major release.'),

    /**
     * Provide label text to be read by screen readers when interacting with the
     * control
     */
    labelText: PropTypes.node.isRequired
  });

  _defineProperty(TimePickerSelect, "defaultProps", {
    disabled: false,
    inline: true,
    iconDescription: 'open list of options',
    hideLabel: true
  });

  var _defineProperty2;
  var prefix$1N = settings_1.prefix;

  var ToggleSkeleton = /*#__PURE__*/function (_React$Component) {
    _inherits(ToggleSkeleton, _React$Component);

    var _super = _createSuper(ToggleSkeleton);

    function ToggleSkeleton() {
      _classCallCheck(this, ToggleSkeleton);

      return _super.apply(this, arguments);
    }

    _createClass(ToggleSkeleton, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            id = _this$props.id,
            labelText = _this$props.labelText,
            className = _this$props.className,
            rest = _objectWithoutProperties(_this$props, ["id", "labelText", "className"]);

        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: classnames("".concat(prefix$1N, "--form-item"), className)
        }, rest), /*#__PURE__*/React__default.createElement("input", {
          type: "checkbox",
          id: id,
          className: "".concat(prefix$1N, "--toggle ").concat(prefix$1N, "--skeleton")
        }), /*#__PURE__*/React__default.createElement("label", {
          "aria-label": labelText ? null : this.props['aria-label'],
          className: "".concat(prefix$1N, "--toggle__label ").concat(prefix$1N, "--skeleton"),
          htmlFor: id
        }, labelText && /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1N, "--toggle__label-text")
        }, labelText), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1N, "--toggle__text--left")
        }), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1N, "--toggle__appearance")
        }), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1N, "--toggle__text--right")
        })));
      }
    }]);

    return ToggleSkeleton;
  }(React__default.Component);

  _defineProperty(ToggleSkeleton, "propTypes", (_defineProperty2 = {
    /**
     * Provide an id that unique represents the underlying <input>
     */
    id: PropTypes.string,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     * `aria-label` is always required but will be null if `labelText` is also
     * provided
     */
    labelText: PropTypes.string
  }, _defineProperty(_defineProperty2, 'aria-label', PropTypes.string.isRequired), _defineProperty(_defineProperty2, "className", PropTypes.string), _defineProperty2));

  _defineProperty(ToggleSkeleton, "defaultProps", _defineProperty({}, 'aria-label', 'Toggle is loading'));

  var _defineProperty2$1, _defineProperty3;
  var prefix$1O = settings_1.prefix;
  var getInstanceId$9 = setupGetInstanceId();

  var Toggle = /*#__PURE__*/function (_React$Component) {
    _inherits(Toggle, _React$Component);

    var _super = _createSuper(Toggle);

    function Toggle() {
      _classCallCheck(this, Toggle);

      return _super.apply(this, arguments);
    }

    _createClass(Toggle, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            className = _this$props.className,
            defaultToggled = _this$props.defaultToggled,
            toggled = _this$props.toggled,
            _onChange = _this$props.onChange,
            onToggle = _this$props.onToggle,
            _this$props$id = _this$props.id,
            id = _this$props$id === void 0 ? this.inputId = this.inputId || "__carbon-toggle_".concat(getInstanceId$9()) : _this$props$id,
            labelText = _this$props.labelText,
            labelA = _this$props.labelA,
            labelB = _this$props.labelB,
            other = _objectWithoutProperties(_this$props, ["className", "defaultToggled", "toggled", "onChange", "onToggle", "id", "labelText", "labelA", "labelB"]);

        var input;
        var wrapperClasses = classnames("".concat(prefix$1O, "--form-item"), _defineProperty({}, className, className));
        var checkedProps = {};

        if (typeof toggled !== 'undefined') {
          checkedProps.checked = toggled;
        } else {
          checkedProps.defaultChecked = defaultToggled;
        }

        return /*#__PURE__*/React__default.createElement("div", {
          className: wrapperClasses
        }, /*#__PURE__*/React__default.createElement("input", _extends({}, other, checkedProps, {
          "aria-label": null,
          type: "checkbox",
          id: id,
          className: "".concat(prefix$1O, "--toggle-input"),
          onChange: function onChange(evt) {
            _onChange && _onChange(evt);
            onToggle(input.checked, id, evt);
          },
          ref: function ref(el) {
            input = el;
          },
          onKeyUp: function onKeyUp(evt) {
            if (match(evt, Enter)) {
              input.checked = !input.checked;
              _onChange && _onChange(evt);
              onToggle(input.checked, id, evt);
            }
          }
        })), /*#__PURE__*/React__default.createElement("label", {
          className: "".concat(prefix$1O, "--toggle-input__label"),
          htmlFor: id,
          "aria-label": labelText ? null : this.props['aria-label']
        }, labelText, /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1O, "--toggle__switch")
        }, /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1O, "--toggle__text--off"),
          "aria-hidden": "true"
        }, labelA), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1O, "--toggle__text--on"),
          "aria-hidden": "true"
        }, labelB))));
      }
    }]);

    return Toggle;
  }(React__default.Component);

  _defineProperty(Toggle, "propTypes", (_defineProperty2$1 = {
    /**
     * Specify a custom className to apply to the form-item node
     */
    className: PropTypes.string,

    /**
     * Specify whether the toggle should be on by default
     */
    defaultToggled: PropTypes.bool,

    /**
     * Provide an optional hook that is called when the control is toggled
     */
    onToggle: PropTypes.func,

    /**
     * Provide an optional hook that is called when the control is changed
     */
    onChange: PropTypes.func,

    /**
     * Provide an id that unique represents the underlying <input>
     */
    id: PropTypes.string.isRequired,

    /**
     * Specify whether the control is toggled
     */
    toggled: PropTypes.bool,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     * `aria-label` is always required but will be null if `labelText` is also
     * provided
     */
    labelText: PropTypes.string
  }, _defineProperty(_defineProperty2$1, 'aria-label', PropTypes.string.isRequired), _defineProperty(_defineProperty2$1, "labelA", PropTypes.string.isRequired), _defineProperty(_defineProperty2$1, "labelB", PropTypes.string.isRequired), _defineProperty2$1));

  _defineProperty(Toggle, "defaultProps", (_defineProperty3 = {
    defaultToggled: false
  }, _defineProperty(_defineProperty3, 'aria-label', 'Toggle'), _defineProperty(_defineProperty3, "labelA", 'Off'), _defineProperty(_defineProperty3, "labelB", 'On'), _defineProperty(_defineProperty3, "onToggle", function onToggle() {}), _defineProperty3));

  var _defineProperty2$2;
  var prefix$1P = settings_1.prefix;

  var ToggleSmallSkeleton = /*#__PURE__*/function (_React$Component) {
    _inherits(ToggleSmallSkeleton, _React$Component);

    var _super = _createSuper(ToggleSmallSkeleton);

    function ToggleSmallSkeleton() {
      _classCallCheck(this, ToggleSmallSkeleton);

      return _super.apply(this, arguments);
    }

    _createClass(ToggleSmallSkeleton, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            id = _this$props.id,
            labelText = _this$props.labelText,
            className = _this$props.className,
            rest = _objectWithoutProperties(_this$props, ["id", "labelText", "className"]);

        return /*#__PURE__*/React__default.createElement("div", _extends({
          className: classnames("".concat(prefix$1P, "--form-item"), className)
        }, rest), /*#__PURE__*/React__default.createElement("input", {
          type: "checkbox",
          id: id,
          className: "".concat(prefix$1P, "--toggle ").concat(prefix$1P, "--toggle--small ").concat(prefix$1P, "--skeleton")
        }), /*#__PURE__*/React__default.createElement("label", {
          className: "".concat(prefix$1P, "--toggle__label ").concat(prefix$1P, "--skeleton"),
          htmlFor: id
        }, labelText && /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1P, "--toggle__label-text")
        }, labelText), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1P, "--toggle__appearance")
        }, /*#__PURE__*/React__default.createElement("svg", {
          className: "".concat(prefix$1P, "--toggle__check"),
          width: "6px",
          height: "5px",
          viewBox: "0 0 6 5"
        }, /*#__PURE__*/React__default.createElement("path", {
          d: "M2.2403 2.7299L4.9245 0 6 1.1117 2.2384 5 0 2.6863 1.0612 1.511z"
        })))));
      }
    }]);

    return ToggleSmallSkeleton;
  }(React__default.Component);

  _defineProperty(ToggleSmallSkeleton, "propTypes", (_defineProperty2$2 = {
    /**
     * Provide an id that unique represents the underlying <input>
     */
    id: PropTypes.string,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     * `aria-label` is always required but will be null if `labelText` is also
     * provided
     */
    labelText: PropTypes.string
  }, _defineProperty(_defineProperty2$2, 'aria-label', PropTypes.string.isRequired), _defineProperty(_defineProperty2$2, "className", PropTypes.string), _defineProperty2$2));

  _defineProperty(ToggleSmallSkeleton, "defaultProps", _defineProperty({}, 'aria-label', 'Toggle is loading'));

  var _ToggleSmall$propType;
  var prefix$1Q = settings_1.prefix;

  var ToggleSmall = function ToggleSmall(_ref) {
    var className = _ref.className,
        defaultToggled = _ref.defaultToggled,
        toggled = _ref.toggled,
        _onChange = _ref.onChange,
        onToggle = _ref.onToggle,
        id = _ref.id,
        labelText = _ref.labelText,
        labelA = _ref.labelA,
        labelB = _ref.labelB,
        other = _objectWithoutProperties(_ref, ["className", "defaultToggled", "toggled", "onChange", "onToggle", "id", "labelText", "labelA", "labelB"]);

    var input;
    var wrapperClasses = classnames("".concat(prefix$1Q, "--form-item"), _defineProperty({}, className, className));
    var checkedProps = {};

    if (typeof toggled !== 'undefined') {
      checkedProps.checked = toggled;
    } else {
      checkedProps.defaultChecked = defaultToggled;
    }

    var ariaLabel = labelText || other['aria-label'] || other.ariaLabel || null;
    return /*#__PURE__*/React__default.createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default.createElement("input", _extends({}, other, checkedProps, {
      "aria-label": null,
      type: "checkbox",
      id: id,
      className: "".concat(prefix$1Q, "--toggle-input ").concat(prefix$1Q, "--toggle-input--small"),
      onChange: function onChange(evt) {
        _onChange && _onChange(evt);
        onToggle(input.checked, id, evt);
      },
      ref: function ref(el) {
        input = el;
      },
      onKeyUp: function onKeyUp(evt) {
        if (match(evt, Enter)) {
          input.checked = !input.checked;
          _onChange && _onChange(evt);
          onToggle(input.checked, id, evt);
        }
      }
    })), /*#__PURE__*/React__default.createElement("label", {
      className: "".concat(prefix$1Q, "--toggle-input__label"),
      htmlFor: id,
      "aria-label": ariaLabel
    }, labelText, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1Q, "--toggle__switch")
    }, /*#__PURE__*/React__default.createElement("svg", {
      className: "".concat(prefix$1Q, "--toggle__check"),
      width: "6px",
      height: "5px",
      viewBox: "0 0 6 5"
    }, /*#__PURE__*/React__default.createElement("path", {
      d: "M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z"
    })), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1Q, "--toggle__text--off"),
      "aria-hidden": "true"
    }, labelA), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1Q, "--toggle__text--on"),
      "aria-hidden": "true"
    }, labelB))));
  };

  ToggleSmall.propTypes = (_ToggleSmall$propType = {
    /**
     * The CSS class for the toggle
     */
    className: PropTypes.string,

    /**
     * `true` to make it toggled on by default.
     */
    defaultToggled: PropTypes.bool,

    /**
     * The event handler for the `onChange` event.
     */
    onToggle: PropTypes.func,

    /**
     * Provide an optional hook that is called when the control is changed
     */
    onChange: PropTypes.func,

    /**
     * The `id` attribute for the toggle
     */
    id: PropTypes.string.isRequired,

    /**
     * `true` to make it toggled on
     */
    toggled: PropTypes.bool,

    /**
     * The `aria-label` attribute for the toggle
     */
    labelText: PropTypes.string
  }, _defineProperty(_ToggleSmall$propType, 'aria-label', PropTypes.string.isRequired), _defineProperty(_ToggleSmall$propType, "labelA", PropTypes.string.isRequired), _defineProperty(_ToggleSmall$propType, "labelB", PropTypes.string.isRequired), _ToggleSmall$propType);
  ToggleSmall.defaultProps = {
    defaultToggled: false,
    onToggle: function onToggle() {},
    labelA: 'Off',
    labelB: 'On'
  };

  var prefix$1R = settings_1.prefix;
  var didWarnAboutDeprecation$3 = false;

  var ToolbarSearch = /*#__PURE__*/function (_Component) {
    _inherits(ToolbarSearch, _Component);

    var _super = _createSuper(ToolbarSearch);

    function ToolbarSearch(props) {
      var _this;

      _classCallCheck(this, ToolbarSearch);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "state", {
        expanded: false
      });

      _defineProperty(_assertThisInitialized(_this), "expandSearch", function () {
        _this.setState({
          expanded: !_this.state.expanded
        });

        _this.input.focus();
      });

      _defineProperty(_assertThisInitialized(_this), "handleClickOutside", function () {
        _this.setState({
          expanded: false
        });
      });

      {
         warning_1(didWarnAboutDeprecation$3, 'The ToolbarSearch component has been deprecated and will be removed in the next major release of `carbon-components-react`') ;
        didWarnAboutDeprecation$3 = true;
      }

      return _this;
    }

    _createClass(ToolbarSearch, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this2 = this;

        var _this$props = this.props,
            className = _this$props.className,
            type = _this$props.type,
            id = _this$props.id,
            placeHolderText = _this$props.placeHolderText,
            labelText = _this$props.labelText,
            role = _this$props.role,
            labelId = _this$props.labelId,
            other = _objectWithoutProperties(_this$props, ["className", "type", "id", "placeHolderText", "labelText", "role", "labelId"]);

        var searchClasses = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1R, "--search ").concat(prefix$1R, "--search--sm ").concat(prefix$1R, "--toolbar-search"), true), _defineProperty(_classNames, "".concat(prefix$1R, "--toolbar-search--active"), this.state.expanded), _defineProperty(_classNames, className, className), _classNames));
        return /*#__PURE__*/React__default.createElement(ClickListener, {
          onClickOutside: this.handleClickOutside
        }, /*#__PURE__*/React__default.createElement("div", {
          className: searchClasses,
          role: role
        }, /*#__PURE__*/React__default.createElement("label", {
          htmlFor: id,
          className: "".concat(prefix$1R, "--label"),
          id: labelId
        }, labelText), /*#__PURE__*/React__default.createElement("input", _extends({}, other, {
          type: type,
          className: "".concat(prefix$1R, "--search-input"),
          id: id,
          "aria-labelledby": labelId,
          placeholder: placeHolderText,
          ref: function ref(input) {
            _this2.input = input;
          }
        })), /*#__PURE__*/React__default.createElement("button", {
          className: "".concat(prefix$1R, "--toolbar-search__btn"),
          title: labelText,
          onClick: this.expandSearch
        }, /*#__PURE__*/React__default.createElement(Search16, {
          className: "".concat(prefix$1R, "--search-magnifier"),
          "aria-label": labelText
        }))));
      }
    }]);

    return ToolbarSearch;
  }(React.Component);

  _defineProperty(ToolbarSearch, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes.node,

    /**
     * The CSS class names.
     */
    className: PropTypes.string,

    /**
     * The `type` of the `<input>`.
     */
    type: PropTypes.string,

    /**
     * `true` to use the small version of the UI.
     */
    small: PropTypes.bool,

    /**
     * The placeholder text of the `<input>`.
     */
    placeHolderText: PropTypes.string,

    /**
     * The text in the `<label>`.
     */
    labelText: PropTypes.node,

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes.string,

    /**
     * Optional prop to specify the role of the ToolbarSearch
     */
    role: PropTypes.string,

    /**
     * The ID of the `<label>`.
     */
    labelId: PropTypes.string
  });

  _defineProperty(ToolbarSearch, "defaultProps", {
    type: 'search',
    id: 'search__input',
    labelText: '',
    placeHolderText: '',
    role: 'search',
    labelId: 'search__label'
  });

  var prefix$1S = settings_1.prefix;
  var didWarnAboutDeprecation$4 = false;

  var Toolbar$1 = function Toolbar(_ref) {
    var children = _ref.children,
        className = _ref.className,
        other = _objectWithoutProperties(_ref, ["children", "className"]);

    var wrapperClasses = classnames("".concat(prefix$1S, "--toolbar"), className);

    {
       warning_1(didWarnAboutDeprecation$4, 'The Toolbar component has been deprecated and will be removed in the next major release of `carbon-components-react`') ;
      didWarnAboutDeprecation$4 = true;
    }

    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: wrapperClasses
    }, other), children);
  };

  Toolbar$1.propTypes = {
    /**
     * Specify a collection of ToolbarItem's that should render in the Toolbar
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the containing Toolbar node
     */
    className: PropTypes.string
  };
  var ToolbarItem = function ToolbarItem(_ref2) {
    var children = _ref2.children,
        type = _ref2.type,
        placeHolderText = _ref2.placeHolderText;
    var toolbarItem = type === 'search' ? /*#__PURE__*/React__default.createElement(ToolbarSearch, {
      placeHolderText: placeHolderText
    }) : children;
    return toolbarItem;
  };
  ToolbarItem.propTypes = {
    /**
     * Specify the contents of the ToolbarItem
     */
    children: PropTypes.node,

    /**
     * Specify the type of the ToolbarItem. The `search` type will render a
     * `ToolbarSearch` component
     */
    type: PropTypes.string,

    /**
     * Specify the placeholder text for the ToolbarSearch component. Useful if
     * `type` is set to 'search'
     */
    placeHolderText: PropTypes.string
  };
  ToolbarItem.defaultProps = {
    placeHolderText: 'Provide placeHolderText'
  }; // eslint-disable-next-line react/display-name

  var ToolbarTitle = /*#__PURE__*/React__default.forwardRef(function (_ref3, ref) {
    var title = _ref3.title;
    return /*#__PURE__*/React__default.createElement("li", {
      ref: ref,
      className: "".concat(prefix$1S, "--toolbar-menu__title")
    }, title);
  });
  ToolbarTitle.propTypes = {
    /**
     * Specify the title of the Toolbar
     */
    title: PropTypes.string
  }; // eslint-disable-next-line react/display-name

  var ToolbarOption = /*#__PURE__*/React__default.forwardRef(function (_ref4, ref) {
    var children = _ref4.children;
    return /*#__PURE__*/React__default.createElement("li", {
      ref: ref,
      className: "".concat(prefix$1S, "--toolbar-menu__option")
    }, children);
  });
  ToolbarOption.propTypes = {
    /**
     * Specify the contents of the ToolbarOption
     */
    children: PropTypes.node
  }; // eslint-disable-next-line react/display-name

  var ToolbarDivider = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
    return /*#__PURE__*/React__default.createElement("hr", {
      ref: ref,
      className: "".concat(prefix$1S, "--toolbar-menu__divider")
    });
  });

  var prefix$1T = settings_1.prefix;
  /**
   * @param {Element} menuBody The menu body with the menu arrow.
   * @param {string} menuDirection Where the floating menu menu should be placed relative to the trigger button.
   * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
   * @private
   */

  var getMenuOffset$3 = function getMenuOffset(menuBody, menuDirection) {
    var _DIRECTION_LEFT$DIREC, _DIRECTION_LEFT$DIREC2;

    var arrowStyle = menuBody.ownerDocument.defaultView.getComputedStyle(menuBody, ':before');
    var arrowPositionProp = (_DIRECTION_LEFT$DIREC = {}, _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_LEFT$1, 'right'), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_TOP$1, 'bottom'), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_RIGHT$1, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_BOTTOM$1, 'top'), _DIRECTION_LEFT$DIREC)[menuDirection];
    var menuPositionAdjustmentProp = (_DIRECTION_LEFT$DIREC2 = {}, _defineProperty(_DIRECTION_LEFT$DIREC2, DIRECTION_LEFT$1, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC2, DIRECTION_TOP$1, 'top'), _defineProperty(_DIRECTION_LEFT$DIREC2, DIRECTION_RIGHT$1, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC2, DIRECTION_BOTTOM$1, 'top'), _DIRECTION_LEFT$DIREC2)[menuDirection];
    var values = [arrowPositionProp, 'border-bottom-width'].reduce(function (o, name) {
      return _objectSpread2(_objectSpread2({}, o), {}, _defineProperty({}, name, Number((/^([\d-]+)px$/.exec(arrowStyle.getPropertyValue(name)) || [])[1])));
    }, {});
    values[arrowPositionProp] = values[arrowPositionProp] || -6; // IE, etc.

    if (Object.keys(values).every(function (name) {
      return !isNaN(values[name]);
    })) {
      var arrowPosition = values[arrowPositionProp],
          borderBottomWidth = values['border-bottom-width'];
      return _defineProperty({
        left: 0,
        top: 0
      }, menuPositionAdjustmentProp, Math.sqrt(Math.pow(borderBottomWidth, 2) * 2) - arrowPosition);
    }
  };

  var Tooltip$1 = /*#__PURE__*/function (_Component) {
    _inherits(Tooltip, _Component);

    var _super = _createSuper(Tooltip);

    function Tooltip(props) {
      var _this;

      _classCallCheck(this, Tooltip);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "_tooltipEl", null);

      _defineProperty(_assertThisInitialized(_this), "_triggerRef", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "_handleUserInputOpenClose", function (event, _ref2) {
        var open = _ref2.open;

        _this.setState({
          open: open
        }, function () {
          if (_this.props.onChange) {
            _this.props.onChange(event, {
              open: open
            });
          }
        });
      });

      _defineProperty(_assertThisInitialized(_this), "_handleFocus", function (state, evt) {
        var relatedTarget = evt.relatedTarget;

        if (state === 'over') {
          _this._handleUserInputOpenClose(evt, {
            open: true
          });
        } else {
          // Note: SVGElement in IE11 does not have `.contains()`
          var triggerEl = _this._triggerRef.current;

          var shouldPreventClose = relatedTarget && (triggerEl && triggerEl.contains && triggerEl.contains(relatedTarget) || _this._tooltipEl && _this._tooltipEl.contains(relatedTarget));

          if (!shouldPreventClose) {
            _this._handleUserInputOpenClose(evt, {
              open: false
            });
          }
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_debouncedHandleFocus", null);

      _defineProperty(_assertThisInitialized(_this), "_getTarget", function () {
        var triggerEl = _this._triggerRef.current;
        return triggerEl && triggerEl.closest('[data-floating-menu-container]') || document.body;
      });

      _defineProperty(_assertThisInitialized(_this), "handleMouse", function (evt) {
        evt.persist();
        var state = {
          focus: 'over',
          blur: 'out',
          click: 'click'
        }[evt.type];
        var hadContextMenu = _this._hasContextMenu;
        _this._hasContextMenu = evt.type === 'contextmenu';

        if (state === 'click') {
          evt.stopPropagation();
          evt.preventDefault();
          var shouldOpen = _this.isControlled ? !_this.props.open : !_this.state.open;

          _this._handleUserInputOpenClose(evt, {
            open: shouldOpen
          });
        } else if (state && (state !== 'out' || !hadContextMenu) && _this._debouncedHandleFocus) {
          _this._debouncedHandleFocus(state, evt);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleClickOutside", function (evt) {
        var shouldPreventClose = evt && evt.target && _this._tooltipEl && _this._tooltipEl.contains(evt.target);

        if (!shouldPreventClose && _this.state.open) {
          _this._handleUserInputOpenClose(evt, {
            open: false
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleKeyPress", function (event) {
        if (matches(event, [Escape])) {
          event.stopPropagation();

          _this._handleUserInputOpenClose(event, {
            open: false
          });
        }

        if (matches(event, [Enter, Space])) {
          event.stopPropagation();
          event.preventDefault();
          var shouldOpen = _this.isControlled ? !_this.props.open : !_this.state.open;

          _this._handleUserInputOpenClose(event, {
            open: shouldOpen
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleEscKeyPress", function (event) {
        var _ref3 = _this.isControlled ? _this.props : _this.state,
            open = _ref3.open;

        if (open && matches(event, [Escape])) {
          return _this._handleUserInputOpenClose(event, {
            open: false
          });
        }
      });

      _this.isControlled = props.open !== undefined;

      var _open =  props.open;

      _this.state = {
        open: _open
      };
      return _this;
    }

    _createClass(Tooltip, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (!this._debouncedHandleFocus) {
          this._debouncedHandleFocus = lodash_debounce(this._handleFocus, 200);
        }

        document.addEventListener('keydown', this.handleEscKeyPress, false);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._debouncedHandleFocus) {
          this._debouncedHandleFocus.cancel();

          this._debouncedHandleFocus = null;
        }

        document.removeEventListener('keydown', this.handleEscKeyPress, false);
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            _this$props$triggerId = _this$props.triggerId,
            triggerId = _this$props$triggerId === void 0 ? this.triggerId = this.triggerId || "__carbon-tooltip-trigger_".concat(Math.random().toString(36).substr(2)) : _this$props$triggerId,
            _this$props$tooltipId = _this$props.tooltipId,
            tooltipId = _this$props$tooltipId === void 0 ? this.tooltipId = this.tooltipId || "__carbon-tooltip_".concat(Math.random().toString(36).substr(2)) : _this$props$tooltipId,
            tooltipBodyId = _this$props.tooltipBodyId,
            children = _this$props.children,
            className = _this$props.className,
            triggerClassName = _this$props.triggerClassName,
            direction = _this$props.direction,
            triggerText = _this$props.triggerText,
            showIcon = _this$props.showIcon,
            iconName = _this$props.iconName,
            iconDescription = _this$props.iconDescription,
            IconCustomElement = _this$props.renderIcon,
            menuOffset = _this$props.menuOffset,
            _this$props$tabIndex = _this$props.tabIndex,
            tabIndex = _this$props$tabIndex === void 0 ? 0 : _this$props$tabIndex,
            ref = _this$props.innerRef,
            selectorPrimaryFocus = _this$props.selectorPrimaryFocus,
            other = _objectWithoutProperties(_this$props, ["triggerId", "tooltipId", "tooltipBodyId", "children", "className", "triggerClassName", "direction", "triggerText", "showIcon", "iconName", "iconDescription", "renderIcon", "menuOffset", "tabIndex", "innerRef", "selectorPrimaryFocus"]);

        var _ref4 = this.isControlled ? this.props : this.state,
            open = _ref4.open;

        var tooltipClasses = classnames("".concat(prefix$1T, "--tooltip"), _defineProperty({}, "".concat(prefix$1T, "--tooltip--shown"), open), className);
        var triggerClasses = classnames("".concat(prefix$1T, "--tooltip__label"), triggerClassName);
        var refProp = mergeRefs(this._triggerRef, ref);
        var iconProperties = {
          name: iconName,
          role: null,
          description: null
        };

        var properties = _objectSpread2({
          role: 'button',
          tabIndex: tabIndex,
          onClick: this.handleMouse,
          onKeyDown: this.handleKeyPress,
          onMouseOver: this.handleMouse,
          onMouseOut: this.handleMouse,
          onFocus: this.handleMouse,
          onBlur: this.handleMouse,
          'aria-controls': !open ? undefined : tooltipId,
          'aria-expanded': open,
          'aria-describedby': open ? tooltipId : null
        }, triggerText ? {
          'aria-labelledby': triggerId
        } : {
          'aria-label': iconDescription
        });

        return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(ClickListener, {
          onClickOutside: this.handleClickOutside
        }, showIcon ? /*#__PURE__*/React__default.createElement("div", {
          id: triggerId,
          className: triggerClasses
        }, triggerText, /*#__PURE__*/React__default.createElement("div", _extends({
          className: "".concat(prefix$1T, "--tooltip__trigger")
        }, properties), /*#__PURE__*/React__default.createElement(IconCustomElement, _extends({
          ref: refProp
        }, iconProperties)))) : /*#__PURE__*/React__default.createElement("div", _extends({
          id: triggerId,
          className: triggerClasses,
          ref: refProp
        }, properties), triggerText)), open && /*#__PURE__*/React__default.createElement(FloatingMenu$1, {
          selectorPrimaryFocus: this.props.selectorPrimaryFocus,
          target: this._getTarget,
          triggerRef: this._triggerRef,
          menuDirection: direction,
          menuOffset: menuOffset,
          menuRef: function menuRef(node) {
            _this2._tooltipEl = node;
          }
        }, /*#__PURE__*/React__default.createElement("div", _extends({
          id: tooltipId,
          className: tooltipClasses
        }, other, {
          "data-floating-menu-direction": direction,
          onMouseOver: this.handleMouse,
          onMouseOut: this.handleMouse,
          onFocus: this.handleMouse,
          onBlur: this.handleMouse,
          onContextMenu: this.handleMouse,
          role: "tooltip"
        }), /*#__PURE__*/React__default.createElement("span", {
          className: "".concat(prefix$1T, "--tooltip__caret")
        }), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(prefix$1T, "--tooltip__content"),
          tabIndex: "-1",
          role: "dialog",
          "aria-describedby": tooltipBodyId,
          "aria-labelledby": triggerId
        }, children))));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref5, state) {
        var open = _ref5.open;

        /**
         * so that tooltip can be controlled programmatically through this `open` prop
         */
        var prevOpen = state.prevOpen;
        return prevOpen === open ? null : {
          open: open,
          prevOpen: open
        };
      }
    }]);

    return Tooltip;
  }(React.Component);

  _defineProperty(Tooltip$1, "propTypes", _objectSpread2(_objectSpread2({
    /**
     * The ID of the trigger button.
     */
    triggerId: PropTypes.string,

    /**
     * The ID of the tooltip content.
     */
    tooltipId: PropTypes.string,

    /**
     * The ID of the tooltip body content.
     */
    tooltipBodyId: PropTypes.string,

    /**
     * Optional starting value for uncontrolled state
     */
    defaultOpen: PropTypes.bool,

    /**
     * Open/closed state.
     */
    open: PropTypes.bool,

    /**
     * Contents to put into the tooltip.
     */
    children: PropTypes.node,

    /**
     * The CSS class names of the tooltip.
     */
    className: PropTypes.string,

    /**
     * The CSS class names of the trigger UI.
     */
    triggerClassName: PropTypes.string,

    /**
     * Where to put the tooltip, relative to the trigger UI.
     */
    direction: PropTypes.oneOf(['bottom', 'top', 'left', 'right']),

    /**
     * Specify a CSS selector that matches the DOM element that should
     * be focused when the Tooltip opens
     */
    selectorPrimaryFocus: PropTypes.string,

    /**
     * The adjustment of the tooltip position.
     */
    menuOffset: PropTypes.oneOfType([PropTypes.shape({
      top: PropTypes.number,
      left: PropTypes.number
    }), PropTypes.func]),

    /**
     * The callback function to optionally render the icon element.
     * It should be a component with React.forwardRef().
     */
    renderIcon: function renderIcon(props, propName, componentName) {
      if (props[propName] == undefined) {
        return;
      }

      var RefForwardingComponent = props[propName];
      if (!reactIs_1( /*#__PURE__*/React__default.createElement(RefForwardingComponent, null))) return new Error("Invalid value of prop '".concat(propName, "' supplied to '").concat(componentName, "',\n                          it should be created/wrapped with React.forwardRef() to have a ref and access the proper\n                          DOM node of the element to calculate its position in the viewport."));
    },

    /**
     * `true` to show the default tooltip icon.
     */
    showIcon: PropTypes.bool,

    /**
     * The name of the default tooltip icon.
     */
    iconName: PropTypes.string
  }, isRequiredOneOf({
    /**
     * The content to put into the trigger UI, except the (default) tooltip icon.
     */
    triggerText: PropTypes.node,

    /**
     * The description of the default tooltip icon, to be put in its SVG 'aria-label' and 'alt' .
     */
    iconDescription: PropTypes.string
  })), {}, {
    /**
     * Optional prop to specify the tabIndex of the Tooltip
     */
    tabIndex: PropTypes.number,

    /**
     * * the signature of the event handler will be:
     * * `onChange(event, { open })` where:
     *   * `event` is the (React) raw event
     *   * `open` is the new value
     */
    onChange:  PropTypes.func 
  }));

  _defineProperty(Tooltip$1, "defaultProps", {
    direction: DIRECTION_BOTTOM$1,
    renderIcon: Information16,
    showIcon: true,
    triggerText: null,
    menuOffset: getMenuOffset$3,
    selectorPrimaryFocus: '[data-tooltip-primary-focus]'
  });

  var Tooltip$2 = (function () {
    var forwardRef = function forwardRef(props, ref) {
      return /*#__PURE__*/React__default.createElement(Tooltip$1, _extends({}, props, {
        innerRef: ref
      }));
    };

    forwardRef.displayName = 'Tooltip';
    return /*#__PURE__*/React__default.forwardRef(forwardRef);
  })();

  var prefix$1U = settings_1.prefix;
  var getInstanceId$a = setupGetInstanceId();

  var TooltipDefinition = function TooltipDefinition(_ref) {
    var _cx;

    var id = _ref.id,
        className = _ref.className,
        triggerClassName = _ref.triggerClassName,
        children = _ref.children,
        direction = _ref.direction,
        align = _ref.align,
        onFocus = _ref.onFocus,
        onMouseEnter = _ref.onMouseEnter,
        onMouseLeave = _ref.onMouseLeave,
        tooltipText = _ref.tooltipText,
        rest = _objectWithoutProperties(_ref, ["id", "className", "triggerClassName", "children", "direction", "align", "onFocus", "onMouseEnter", "onMouseLeave", "tooltipText"]);

    var _useState = React.useState(true),
        _useState2 = _slicedToArray(_useState, 2),
        allowTooltipVisibility = _useState2[0],
        setAllowTooltipVisibility = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray(_useState3, 2),
        tooltipVisible = _useState4[0],
        setTooltipVisible = _useState4[1];

    var tooltipId = id || "definition-tooltip-".concat(getInstanceId$a());
    var tooltipClassName = classnames("".concat(prefix$1U, "--tooltip--definition"), "".concat(prefix$1U, "--tooltip--a11y"), className);
    var tooltipTriggerClasses = classnames("".concat(prefix$1U, "--tooltip__trigger"), "".concat(prefix$1U, "--tooltip--a11y"), "".concat(prefix$1U, "--tooltip__trigger--definition"), triggerClassName, (_cx = {}, _defineProperty(_cx, "".concat(prefix$1U, "--tooltip--").concat(direction), direction), _defineProperty(_cx, "".concat(prefix$1U, "--tooltip--align-").concat(align), align), _defineProperty(_cx, "".concat(prefix$1U, "--tooltip--hidden"), !allowTooltipVisibility), _defineProperty(_cx, "".concat(prefix$1U, "--tooltip--visible"), tooltipVisible), _cx));
    var debounceTooltipVisible = lodash_debounce(function () {
      return setTooltipVisible(false);
    }, 100);

    var handleFocus = function handleFocus() {
      return setAllowTooltipVisibility(true);
    };

    var handleMouseEnter = function handleMouseEnter() {
      debounceTooltipVisible.cancel();
      setAllowTooltipVisibility(true);
      setTooltipVisible(true);
    };

    var handleMouseLeave = debounceTooltipVisible;
    React.useEffect(function () {
      var handleEscKeyDown = function handleEscKeyDown(event) {
        if (matches(event, [Escape])) {
          setAllowTooltipVisibility(false);
        }
      };

      document.addEventListener('keydown', handleEscKeyDown);
      return function () {
        return document.removeEventListener('keydown', handleEscKeyDown);
      };
    }, []);
    return /*#__PURE__*/React__default.createElement("div", _extends({}, rest, {
      className: tooltipClassName,
      onMouseEnter: composeEventHandlers([onMouseEnter, handleMouseEnter]),
      onMouseLeave: composeEventHandlers([onMouseLeave, handleMouseLeave])
    }), /*#__PURE__*/React__default.createElement("button", {
      className: tooltipTriggerClasses,
      "aria-describedby": tooltipId,
      onFocus: composeEventHandlers([onFocus, handleFocus])
    }, children), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1U, "--assistive-text"),
      id: tooltipId,
      role: "tooltip"
    }, tooltipText));
  };

  TooltipDefinition.propTypes = {
    /**
     * Specify the tooltip trigger text that is rendered to the UI for the user to
     * interact with in order to display the tooltip.
     */
    children: PropTypes.string.isRequired,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes.string,

    /**
     * The CSS class name of the trigger element
     */
    triggerClassName: PropTypes.string,

    /**
     * Specify the direction of the tooltip. Can be either top or bottom.
     */
    direction: PropTypes.oneOf(['top', 'bottom']),

    /**
     * Specify the alignment (to the trigger button) of the tooltip.
     * Can be one of: start, center, or end.
     */
    align: PropTypes.oneOf(['start', 'center', 'end']),

    /**
     * Optionally specify a custom id for the tooltip. If one is not provided, we
     * generate a unique id for you.
     */
    id: PropTypes.string,

    /**
     * Provide the text that will be displayed in the tooltip when it is rendered.
     * TODO: rename this prop (will be a breaking change)
     */
    tooltipText: PropTypes.node.isRequired,

    /**
     * The event handler for the `focus` event.
     */
    onFocus: PropTypes.func,

    /**
     * The event handler for the `mouseenter` event.
     */
    onMouseEnter: PropTypes.func,

    /**
     * The event handler for the `mouseleave` event.
     */
    onMouseLeave: PropTypes.func
  };
  TooltipDefinition.defaultProps = {
    direction: 'bottom',
    align: 'start'
  };

  var prefix$1V = settings_1.prefix;
  var getInstanceId$b = setupGetInstanceId();

  var TooltipIcon = function TooltipIcon(_ref) {
    var _cx;

    var id = _ref.id,
        className = _ref.className,
        children = _ref.children,
        direction = _ref.direction,
        align = _ref.align,
        onFocus = _ref.onFocus,
        onMouseEnter = _ref.onMouseEnter,
        tooltipText = _ref.tooltipText,
        rest = _objectWithoutProperties(_ref, ["id", "className", "children", "direction", "align", "onFocus", "onMouseEnter", "tooltipText"]);

    var _useState = React.useState(true),
        _useState2 = _slicedToArray(_useState, 2),
        allowTooltipVisibility = _useState2[0],
        setAllowTooltipVisibility = _useState2[1];

    var tooltipId = id || "icon-tooltip-".concat(getInstanceId$b());
    var tooltipTriggerClasses = classnames("".concat(prefix$1V, "--tooltip__trigger"), "".concat(prefix$1V, "--tooltip--a11y"), className, (_cx = {}, _defineProperty(_cx, "".concat(prefix$1V, "--tooltip--").concat(direction), direction), _defineProperty(_cx, "".concat(prefix$1V, "--tooltip--align-").concat(align), align), _defineProperty(_cx, "".concat(prefix$1V, "--tooltip--hidden"), !allowTooltipVisibility), _cx));

    var handleFocus = function handleFocus() {
      return setAllowTooltipVisibility(true);
    };

    var handleMouseEnter = function handleMouseEnter() {
      return setAllowTooltipVisibility(true);
    };

    React.useEffect(function () {
      var handleEscKeyDown = function handleEscKeyDown(event) {
        if (matches(event, [Escape])) {
          setAllowTooltipVisibility(false);
        }
      };

      document.addEventListener('keydown', handleEscKeyDown);
      return function () {
        return document.removeEventListener('keydown', handleEscKeyDown);
      };
    }, []);
    return /*#__PURE__*/React__default.createElement("button", _extends({}, rest, {
      className: tooltipTriggerClasses,
      "aria-describedby": tooltipId,
      onMouseEnter: composeEventHandlers([onMouseEnter, handleMouseEnter]),
      onFocus: composeEventHandlers([onFocus, handleFocus])
    }), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1V, "--assistive-text"),
      id: tooltipId
    }, tooltipText), children);
  };

  TooltipIcon.propTypes = {
    /**
     * Specify an icon as children that will be used as the tooltip trigger. This
     * can be an icon from our Icon component, or a custom SVG element.
     */
    children: PropTypes.node.isRequired,

    /**
     * Specify an optional className to be applied to the trigger node
     */
    className: PropTypes.string,

    /**
     * Specify the direction of the tooltip. Can be either top or bottom.
     */
    direction: PropTypes.oneOf(['top', 'right', 'left', 'bottom']),

    /**
     * Specify the alignment (to the trigger button) of the tooltip.
     * Can be one of: start, center, or end.
     */
    align: PropTypes.oneOf(['start', 'center', 'end']),

    /**
     * Optionally specify a custom id for the tooltip. If one is not provided, we
     * generate a unique id for you.
     */
    id: PropTypes.string,

    /**
     * Provide the ARIA label for the tooltip.
     * TODO: rename this prop (will be a breaking change)
     */
    tooltipText: PropTypes.string.isRequired,

    /**
     * The event handler for the `focus` event.
     */
    onFocus: PropTypes.func,

    /**
     * The event handler for the `mouseenter` event.
     */
    onMouseEnter: PropTypes.func
  };
  TooltipIcon.defaultProps = {
    direction: 'bottom',
    align: 'center'
  };

  var prefix$1W = settings_1.prefix;

  var UnorderedList = function UnorderedList(_ref) {
    var children = _ref.children,
        className = _ref.className,
        nested = _ref.nested,
        other = _objectWithoutProperties(_ref, ["children", "className", "nested"]);

    var classNames = classnames("".concat(prefix$1W, "--list--unordered"), className, _defineProperty({}, "".concat(prefix$1W, "--list--nested"), nested));
    return /*#__PURE__*/React__default.createElement("ul", _extends({
      className: classNames
    }, other), children);
  };

  UnorderedList.propTypes = {
    /**
     * Specify a collection of ListItem's to be rendered in the UnorderedList
     */
    children: PropTypes.node,

    /**
     * Specify an optional className to be applied to the underlying <ul> node
     */
    className: PropTypes.string,

    /**
     * Specify whether the list is nested, or not
     */
    nested: PropTypes.bool
  };
  UnorderedList.defaultProps = {
    nested: false
  };

  var prefix$1X = settings_1.prefix;

  var SkeletonPlaceholder = function SkeletonPlaceholder(_ref) {
    var _classNames;

    var className = _ref.className,
        other = _objectWithoutProperties(_ref, ["className"]);

    var skeletonPlaceholderClasses = classnames((_classNames = {}, _defineProperty(_classNames, "".concat(prefix$1X, "--skeleton__placeholder"), true), _defineProperty(_classNames, className, className), _classNames));
    return /*#__PURE__*/React__default.createElement("div", _extends({
      className: skeletonPlaceholderClasses
    }, other));
  };

  SkeletonPlaceholder.propTypes = {
    /**
     * the class to be applied to the component
     */
    className: PropTypes.string
  };

  var prefix$1Y = settings_1.prefix;

  var DataTableSkeleton = function DataTableSkeleton(_ref) {
    var _cx;

    var rowCount = _ref.rowCount,
        columnCount = _ref.columnCount,
        zebra = _ref.zebra,
        compact = _ref.compact,
        className = _ref.className,
        showHeader = _ref.showHeader,
        showToolbar = _ref.showToolbar,
        rest = _objectWithoutProperties(_ref, ["rowCount", "columnCount", "zebra", "compact", "className", "showHeader", "showToolbar"]);

    var dataTableSkeletonClasses = classnames(className, (_cx = {}, _defineProperty(_cx, "".concat(prefix$1Y, "--skeleton"), true), _defineProperty(_cx, "".concat(prefix$1Y, "--data-table"), true), _defineProperty(_cx, "".concat(prefix$1Y, "--data-table--zebra"), zebra), _defineProperty(_cx, "".concat(prefix$1Y, "--data-table--compact"), compact), _cx));
    var rowRepeat = rowCount;
    var rows = Array(rowRepeat);
    var columnsArray = Array.from({
      length: columnCount
    }, function (_, index) {
      return index;
    });

    for (var i = 0; i < rowRepeat; i++) {
      rows[i] = /*#__PURE__*/React__default.createElement("tr", {
        key: i
      }, columnsArray.map(function (j) {
        return /*#__PURE__*/React__default.createElement("td", {
          key: j
        }, /*#__PURE__*/React__default.createElement("span", null));
      }));
    }

    return /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1Y, "--skeleton ").concat(prefix$1Y, "--data-table-container")
    }, showHeader ? /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1Y, "--data-table-header")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1Y, "--data-table-header__title")
    }), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1Y, "--data-table-header__description")
    })) : null, showToolbar ? /*#__PURE__*/React__default.createElement("section", {
      "aria-label": "data table toolbar",
      className: "".concat(prefix$1Y, "--table-toolbar")
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$1Y, "--toolbar-content")
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$1Y, "--skeleton ").concat(prefix$1Y, "--btn ").concat(prefix$1Y, "--btn--sm")
    }))) : null, /*#__PURE__*/React__default.createElement("table", _extends({
      className: dataTableSkeletonClasses
    }, rest), /*#__PURE__*/React__default.createElement("thead", null, /*#__PURE__*/React__default.createElement("tr", null, columnsArray.map(function (i) {
      return /*#__PURE__*/React__default.createElement("th", {
        key: i
      }, /*#__PURE__*/React__default.createElement("span", null));
    }))), /*#__PURE__*/React__default.createElement("tbody", null, rows)));
  };

  DataTableSkeleton.propTypes = {
    /**
     * Specify the number of rows that you want to render in the skeleton state
     */
    rowCount: PropTypes.number,

    /**
     * Specify the number of columns that you want to render in the skeleton state
     */
    columnCount: PropTypes.number,

    /**
     * Optionally specify whether you want the DataTable to be zebra striped
     */
    zebra: PropTypes.bool,

    /**
     * Optionally specify whether you want the Skeleton to be rendered as a
     * compact DataTable
     */
    compact: PropTypes.bool,

    /**
     * Optionally specify the displayed headers
     */
    headers: PropTypes.oneOfType([PropTypes.array, PropTypes.shape({
      key: PropTypes.string
    })]),

    /**
     * Specify an optional className to add.
     */
    className: PropTypes.string,

    /**
     * Specify if the table header should be rendered as part of the skeleton.
     */
    showHeader: PropTypes.bool,

    /**
     * Specify if the table toolbar should be rendered as part of the skeleton.
     */
    showToolbar: PropTypes.bool
  };
  DataTableSkeleton.defaultProps = {
    rowCount: 5,
    columnCount: 5,
    zebra: false,
    compact: false,
    headers: [],
    showHeader: true,
    showToolbar: true
  };

  var prefix$1Z = settings_1.prefix;

  var Content = function Content(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        tagName = _ref.tagName,
        rest = _objectWithoutProperties(_ref, ["className", "children", "tagName"]);

    var className = classnames("".concat(prefix$1Z, "--content"), customClassName);
    return /*#__PURE__*/React__default.createElement(tagName, _objectSpread2(_objectSpread2({}, rest), {}, {
      className: className
    }), children);
  };

  Content.propTypes = {
    /**
     * Optionally provide a custom class name that is applied to the container
     */
    className: PropTypes.string,

    /**
     * Provide children nodes to be rendered in the content container
     */
    children: PropTypes.node,

    /**
     * Optionally specify the tag of the content node. Defaults to `main`
     */
    tagName: PropTypes.string
  };
  Content.defaultProps = {
    tagName: 'main'
  };

  var prefix$1_ = settings_1.prefix;

  var Header = function Header(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties(_ref, ["className", "children"]);

    var className = classnames("".concat(prefix$1_, "--header"), customClassName);
    return /*#__PURE__*/React__default.createElement("header", _extends({}, rest, {
      className: className
    }), children);
  };

  Header.propTypes = _objectSpread2(_objectSpread2({}, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class name that is applied to the underlying <header>
     */
    className: PropTypes.string
  });

  var HeaderContainer = function HeaderContainer(_ref) {
    var isSideNavExpanded = _ref.isSideNavExpanded,
        Children = _ref.render;

    //state for expandable sidenav
    var _useState = React.useState(isSideNavExpanded),
        _useState2 = _slicedToArray(_useState, 2),
        isSideNavExpandedState = _useState2[0],
        setIsSideNavExpandedState = _useState2[1];

    var handleHeaderMenuButtonClick = React.useCallback(function () {
      setIsSideNavExpandedState(!isSideNavExpandedState);
    }, [isSideNavExpandedState, setIsSideNavExpandedState]);
    return /*#__PURE__*/React__default.createElement(Children, {
      isSideNavExpanded: isSideNavExpandedState,
      onClickSideNavExpand: handleHeaderMenuButtonClick
    });
  };

  HeaderContainer.propTypes = {
    /**
     * Optionally provide a custom class name that is applied to the underlying <header>
     */
    isSideNavExpanded: PropTypes.bool
  };
  HeaderContainer.defaultProps = {
    isSideNavExpanded: false
  };

  var prefix$1$ = settings_1.prefix;
  /**
   * HeaderGlobalAction is used as a part of the `HeaderGlobalBar`. It is
   * essentially an Icon Button with an additional state to indicate whether it is
   * "active". The active state comes from when a user clicks on the global action
   * which should trigger a panel to appear.
   *
   * Note: children passed to this component should be an Icon.
   */

  var HeaderGlobalAction = /*#__PURE__*/React__default.forwardRef(function HeaderGlobalAction(_ref, ref) {
    var _cx;

    var ariaLabel = _ref['aria-label'],
        ariaLabelledBy = _ref['aria-labelledby'],
        children = _ref.children,
        customClassName = _ref.className,
        onClick = _ref.onClick,
        isActive = _ref.isActive,
        rest = _objectWithoutProperties(_ref, ["aria-label", "aria-labelledby", "children", "className", "onClick", "isActive"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, customClassName, !!customClassName), _defineProperty(_cx, "".concat(prefix$1$, "--header__action"), true), _defineProperty(_cx, "".concat(prefix$1$, "--header__action--active"), isActive), _cx));
    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    return /*#__PURE__*/React__default.createElement("button", _extends({}, rest, accessibilityLabel, {
      className: className,
      onClick: onClick,
      type: "button",
      ref: ref
    }), children);
  });
  HeaderGlobalAction.propTypes = _objectSpread2(_objectSpread2({}, AriaLabelPropType), {}, {
    /**
     * Provide a custom icon for this global action
     */
    children: PropTypes.node.isRequired,

    /**
     * Optionally provide a custom class name that is applied to the underlying
     * button
     */
    className: PropTypes.string,

    /**
     * Optionally provide an onClick handler that is called when the underlying
     * button fires it's onclick event
     */
    onClick: PropTypes.func,

    /**
     * Specify whether the action is currently active
     */
    isActive: PropTypes.bool
  });
  HeaderGlobalAction.displayName = 'HeaderGlobalAction';

  var prefix$20 = settings_1.prefix;
  /**
   * Generic container for `HeaderGlobalAction` components
   */

  var HeaderGlobalBar = wrapComponent({
    name: 'HeaderGlobalBar',
    className: "".concat(prefix$20, "--header__global"),
    type: 'div'
  });

  var prefix$21 = settings_1.prefix;

  var defaultRenderMenuContent = function defaultRenderMenuContent() {
    return /*#__PURE__*/React__default.createElement(ChevronDown16, {
      className: "".concat(prefix$21, "--header__menu-arrow")
    });
  };
  /**
   * `HeaderMenu` is used to render submenu's in the `Header`. Most often children
   * will be a `HeaderMenuItem`. It handles certain keyboard events to help
   * with managing focus. It also passes along refs to each child so that it can
   * help manage focus state of its children.
   */


  var HeaderMenu = /*#__PURE__*/function (_React$Component) {
    _inherits(HeaderMenu, _React$Component);

    var _super = _createSuper(HeaderMenu);

    function HeaderMenu(props) {
      var _this;

      _classCallCheck(this, HeaderMenu);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "_subMenus", /*#__PURE__*/React__default.createRef());

      _defineProperty(_assertThisInitialized(_this), "handleOnClick", function (e) {
        var subMenusNode = _this._subMenus.current;

        if (!subMenusNode || !subMenusNode.contains(e.target)) {
          e.preventDefault();
        }

        _this.setState(function (prevState) {
          return {
            expanded: !prevState.expanded
          };
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnKeyDown", function (event) {
        // Handle enter or space key for toggling the expanded state of the menu.
        if (matches(event, [Enter, Space])) {
          event.stopPropagation();
          event.preventDefault();

          _this.setState(function (prevState) {
            return {
              expanded: !prevState.expanded
            };
          });

          return;
        }
      });

      _defineProperty(_assertThisInitialized(_this), "handleOnBlur", function (event) {
        // Rough guess for a blur event that is triggered outside of our menu or
        // menubar context
        var itemTriggeredBlur = _this.items.find(function (element) {
          return element === event.relatedTarget;
        });

        if (event.relatedTarget && (event.relatedTarget.getAttribute('href') && event.relatedTarget.getAttribute('href') !== '#' || itemTriggeredBlur)) {
          return;
        }

        _this.setState({
          expanded: false,
          selectedIndex: null
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleMenuButtonRef", function (node) {
        if (_this.props.focusRef) {
          _this.props.focusRef(node);
        }

        _this.menuButtonRef = node;
      });

      _defineProperty(_assertThisInitialized(_this), "handleItemRef", function (index) {
        return function (node) {
          _this.items[index] = node;
        };
      });

      _defineProperty(_assertThisInitialized(_this), "handleMenuClose", function (event) {
        // Handle ESC keydown for closing the expanded menu.
        if (matches(event, [Escape]) && _this.state.expanded) {
          event.stopPropagation();
          event.preventDefault();

          _this.setState(function () {
            return {
              expanded: false,
              selectedIndex: null
            };
          }); // Return focus to menu button when the user hits ESC.


          _this.menuButtonRef.focus();

          return;
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_renderMenuItem", function (item, index) {
        if ( /*#__PURE__*/React__default.isValidElement(item)) {
          return /*#__PURE__*/React__default.cloneElement(item, {
            ref: _this.handleItemRef(index)
          });
        }
      });

      _this.state = {
        // Used to manage the expansion state of the menu
        expanded: false,
        // Refers to the menuitem that is currently focused
        // Note: children should have `role="menuitem"` on node consuming ref
        selectedIndex: null
      };
      _this.items = [];
      return _this;
    }
    /**
     * Toggle the expanded state of the menu on click.
     */


    _createClass(HeaderMenu, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            ariaLabel = _this$props['aria-label'],
            ariaLabelledBy = _this$props['aria-labelledby'],
            customClassName = _this$props.className,
            children = _this$props.children,
            MenuContent = _this$props.renderMenuContent,
            menuLinkName = _this$props.menuLinkName;
        var accessibilityLabel = {
          'aria-label': ariaLabel,
          'aria-labelledby': ariaLabelledBy
        };
        var className = classnames("".concat(prefix$21, "--header__submenu"), customClassName); // Notes on eslint comments and based on the examples in:
        // https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-1/menubar-1.html#
        // - The focus is handled by the <a> menuitem, onMouseOver is for mouse
        // users
        // - aria-haspopup can definitely have the value "menu"
        // - aria-expanded is on their example node with role="menuitem"
        // - href can be set to javascript:void(0), ideally this will be a button

        return /*#__PURE__*/React__default.createElement("li", {
          // eslint-disable-line jsx-a11y/mouse-events-have-key-events,jsx-a11y/no-noninteractive-element-interactions
          className: className,
          onKeyDown: this.handleMenuClose,
          onClick: this.handleOnClick,
          onBlur: this.handleOnBlur
        }, /*#__PURE__*/React__default.createElement("a", _extends({
          // eslint-disable-line jsx-a11y/role-supports-aria-props,jsx-a11y/anchor-is-valid
          "aria-haspopup": "menu" // eslint-disable-line jsx-a11y/aria-proptypes
          ,
          "aria-expanded": this.state.expanded,
          className: "".concat(prefix$21, "--header__menu-item ").concat(prefix$21, "--header__menu-title"),
          href: "#",
          onKeyDown: this.handleOnKeyDown,
          ref: this.handleMenuButtonRef,
          tabIndex: 0
        }, accessibilityLabel), menuLinkName, /*#__PURE__*/React__default.createElement(MenuContent, null)), /*#__PURE__*/React__default.createElement("ul", _extends({}, accessibilityLabel, {
          ref: this._subMenus,
          className: "".concat(prefix$21, "--header__menu")
        }), React__default.Children.map(children, this._renderMenuItem)));
      }
      /**
       * We capture the `ref` for each child inside of `this.items` to properly
       * manage focus. In addition to this focus management, all items receive a
       * `tabIndex: -1` so the user won't hit a large number of items in their tab
       * sequence when they might not want to go through all the items.
       */

    }]);

    return HeaderMenu;
  }(React__default.Component);

  _defineProperty(HeaderMenu, "propTypes", _objectSpread2(_objectSpread2({}, AriaLabelPropType), {}, {
    /**
     * Provide a custom ref handler for the menu button
     */
    focusRef: PropTypes.func,

    /**
     * Optionally provide a tabIndex for the underlying menu button
     */
    tabIndex: PropTypes.number,

    /**
     * Provide a label for the link text
     */
    menuLinkName: PropTypes.string.isRequired,

    /**
     * Optional component to render instead of string
     */
    renderMenuContent: PropTypes.func
  }));

  _defineProperty(HeaderMenu, "defaultProps", {
    renderMenuContent: defaultRenderMenuContent
  });

  var HeaderMenuForwardRef = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
    return /*#__PURE__*/React__default.createElement(HeaderMenu, _extends({}, props, {
      focusRef: ref
    }));
  });
  HeaderMenuForwardRef.displayName = 'HeaderMenu';

  var prefix$22 = settings_1.prefix;

  var HeaderMenuButton = function HeaderMenuButton(_ref) {
    var _cx;

    var ariaLabel = _ref['aria-label'],
        ariaLabelledBy = _ref['aria-labelledby'],
        customClassName = _ref.className,
        onClick = _ref.onClick,
        isActive = _ref.isActive,
        isCollapsible = _ref.isCollapsible,
        rest = _objectWithoutProperties(_ref, ["aria-label", "aria-labelledby", "className", "onClick", "isActive", "isCollapsible"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, customClassName, !!customClassName), _defineProperty(_cx, "".concat(prefix$22, "--header__action"), true), _defineProperty(_cx, "".concat(prefix$22, "--header__menu-trigger"), true), _defineProperty(_cx, "".concat(prefix$22, "--header__action--active"), isActive), _defineProperty(_cx, "".concat(prefix$22, "--header__menu-toggle"), true), _defineProperty(_cx, "".concat(prefix$22, "--header__menu-toggle__hidden"), !isCollapsible), _cx));
    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    return /*#__PURE__*/React__default.createElement("button", _extends({}, rest, accessibilityLabel, {
      className: className,
      title: ariaLabel,
      type: "button",
      onClick: onClick
    }), isActive ? /*#__PURE__*/React__default.createElement(Close20, null) : /*#__PURE__*/React__default.createElement(Menu20, null));
  };

  HeaderMenuButton.propTypes = _objectSpread2(_objectSpread2({}, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class name that is applied to the underlying
     * button
     */
    className: PropTypes.string,

    /**
     * Optionally provide an onClick handler that is called when the underlying
     * button fires it's onclick event
     */
    onClick: PropTypes.func,
    isActive: PropTypes.bool
  });

  /**
   * Link is a custom component that allows us to supporting rendering elements
   * other than `a` in our markup. The goal is to allow users to support passing
   * in their own components to support use-cases like `react-router` or
   * `@reach/router`
   */

  var Link$1 = /*#__PURE__*/React__default.forwardRef(function Link(props, ref) {
    var element = props.element,
        rest = _objectWithoutProperties(props, ["element"]);

    return /*#__PURE__*/React__default.createElement(element, _objectSpread2(_objectSpread2({}, rest), {}, {
      ref: ref
    }));
  });
  var LinkPropTypes = {
    /**
     * The base element to use to build the link. Defaults to `a`, can also accept
     * alternative tag names or custom components like `Link` from `react-router`.
     */
    element: PropTypes.elementType,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes.bool
  };
  Link$1.displayName = 'Link';
  Link$1.propTypes = LinkPropTypes;
  Link$1.defaultProps = {
    element: 'a'
  };

  var prefix$23 = settings_1.prefix;
  var HeaderMenuItem = /*#__PURE__*/React__default.forwardRef(function HeaderMenuItem(_ref, ref) {
    var _cx;

    var className = _ref.className,
        isCurrentPage = _ref.isCurrentPage,
        ariaCurrent = _ref['aria-current'],
        children = _ref.children,
        role = _ref.role,
        rest = _objectWithoutProperties(_ref, ["className", "isCurrentPage", "aria-current", "children", "role"]);

    var linkClassName = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$23, "--header__menu-item"), true), _defineProperty(_cx, "".concat(prefix$23, "--header__menu-item--current"), isCurrentPage && ariaCurrent !== 'page'), _cx));
    return /*#__PURE__*/React__default.createElement("li", {
      className: className,
      role: role
    }, /*#__PURE__*/React__default.createElement(Link$1, _extends({}, rest, {
      "aria-current": ariaCurrent,
      className: linkClassName,
      ref: ref,
      tabIndex: 0
    }), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$23, "--text-truncate--end")
    }, children)));
  });
  HeaderMenuItem.propTypes = _objectSpread2(_objectSpread2({}, LinkPropTypes), {}, {
    /**
     * Optionally provide a custom class to apply to the underlying <li> node
     */
    className: PropTypes.string,

    /**
     * Pass in children that are either a string or can be read as a string by
     * screen readers
     */
    children: PropTypes.node.isRequired,

    /**
     * Optionally supply a role for the underlying <li> node. Useful for resetting
     * <ul> semantics for menus.
     */
    role: PropTypes.string,

    /**
     * Applies selected styles to the item if a user sets this to true and aria-current !== 'page'.
     */
    isCurrentPage: PropTypes.bool
  });

  var selectorPrefix = settings_1.prefix;

  var HeaderName = function HeaderName(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        prefix = _ref.prefix,
        href = _ref.href,
        rest = _objectWithoutProperties(_ref, ["children", "className", "prefix", "href"]);

    var className = classnames("".concat(selectorPrefix, "--header__name"), customClassName);
    return /*#__PURE__*/React__default.createElement(Link$1, _extends({}, rest, {
      className: className,
      href: href
    }), prefix && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(selectorPrefix, "--header__name--prefix")
    }, prefix), "\xA0"), children);
  };

  HeaderName.propTypes = _objectSpread2(_objectSpread2({}, LinkPropTypes), {}, {
    /**
     * Pass in children that are either a string or can be read as a string by
     * screen readers
     */
    children: PropTypes.node.isRequired,

    /**
     * Optionally provide a custom class to apply to the underlying <li> node
     */
    className: PropTypes.string,

    /**
     * Optionally specify a prefix to your header name. Useful for companies, for
     * example: IBM [Product Name] versus solely [Product Name]
     */
    prefix: PropTypes.string,

    /**
     * Provide an href for the name to link to
     */
    href: PropTypes.string
  });
  HeaderName.defaultProps = {
    prefix: 'IBM'
  };

  var prefix$24 = settings_1.prefix;

  var HeaderNavigation = /*#__PURE__*/function (_React$Component) {
    _inherits(HeaderNavigation, _React$Component);

    var _super = _createSuper(HeaderNavigation);

    function HeaderNavigation(props) {
      var _this;

      _classCallCheck(this, HeaderNavigation);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "handleItemRef", function (index) {
        return function (node) {
          _this.items[index] = node;
        };
      });

      _defineProperty(_assertThisInitialized(_this), "_renderNavItem", function (child, index) {
        if ( /*#__PURE__*/React__default.isValidElement(child)) {
          return /*#__PURE__*/React__default.cloneElement(child, {
            ref: _this.handleItemRef(index)
          });
        }
      });

      _this.items = [];
      _this.state = {
        selectedIndex: 0
      };
      return _this;
    }
    /**
     * Handles individual menuitem refs. We assign them to a class instance
     * property so that we can properly manage focus of our children.
     */


    _createClass(HeaderNavigation, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            ariaLabel = _this$props['aria-label'],
            ariaLabelledBy = _this$props['aria-labelledby'],
            children = _this$props.children,
            customClassName = _this$props.className,
            rest = _objectWithoutProperties(_this$props, ["aria-label", "aria-labelledby", "children", "className"]);

        var className = classnames("".concat(prefix$24, "--header__nav"), customClassName); // Assign both label strategies in this option, only one should be defined
        // so when we spread that should be the one that is applied to the node

        var accessibilityLabel = {
          'aria-label': ariaLabel,
          'aria-labelledby': ariaLabelledBy
        };
        return /*#__PURE__*/React__default.createElement("nav", _extends({}, rest, accessibilityLabel, {
          className: className
        }), /*#__PURE__*/React__default.createElement("ul", _extends({}, accessibilityLabel, {
          className: "".concat(prefix$24, "--header__menu-bar"),
          role: "menubar"
        }), React__default.Children.map(children, this._renderNavItem)));
      }
      /**
       * Render an individual menuitem, adding a `ref` for each child inside of
       * `this.items` to properly manage focus.
       */

    }]);

    return HeaderNavigation;
  }(React__default.Component);

  _defineProperty(HeaderNavigation, "propTypes", _objectSpread2(_objectSpread2({}, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class to apply to the underlying <nav> node
     */
    className: PropTypes.string,

    /**
     * Provide valid children of HeaderNavigation, for example `HeaderMenuItem`
     * or `HeaderMenu`
     */
    children: PropTypes.node
  }));

  var prefix$25 = settings_1.prefix;
  var HeaderPanel = /*#__PURE__*/React__default.forwardRef(function HeaderPanel(_ref, ref) {
    var _cx;

    var ariaLabel = _ref['aria-label'],
        ariaLabelledBy = _ref['aria-labelledby'],
        children = _ref.children,
        customClassName = _ref.className,
        expanded = _ref.expanded,
        other = _objectWithoutProperties(_ref, ["aria-label", "aria-labelledby", "children", "className", "expanded"]);

    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    var className = classnames("".concat(prefix$25, "--header-panel"), (_cx = {}, _defineProperty(_cx, "".concat(prefix$25, "--header-panel--expanded"), expanded), _defineProperty(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default.createElement("div", _extends({}, other, {
      className: className
    }, accessibilityLabel, {
      ref: ref
    }), children);
  });
  HeaderPanel.propTypes = _objectSpread2(_objectSpread2({}, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class to apply to the underlying <li> node
     */
    className: PropTypes.string,

    /**
     * Specify whether the panel is expanded
     */
    expanded: PropTypes.bool
  });
  HeaderPanel.displayName = 'HeaderPanel';

  var prefix$26 = settings_1.prefix;

  var HeaderSideNavItems = function HeaderSideNavItems(_ref) {
    var _cx;

    var customClassName = _ref.className,
        children = _ref.children,
        hasDivider = _ref.hasDivider;
    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$26, "--side-nav__header-navigation"), true), _defineProperty(_cx, "".concat(prefix$26, "--side-nav__header-divider"), hasDivider), _cx), customClassName);
    return /*#__PURE__*/React__default.createElement("div", {
      className: className
    }, children);
  };

  HeaderSideNavItems.propTypes = {
    /**
     * Optionally provide a custom class name that is applied to the underlying
     * button
     */
    className: PropTypes.string,

    /**
     * Optionally specify if container will have a bottom divider to differentiate
     * between original sidenav items and header menu items. False by default.
     */
    hasDivider: PropTypes.bool,

    /**
     * The child nodes to be rendered
     */
    children: PropTypes.node
  };
  HeaderSideNavItems.defaultProps = {
    hasDivider: false
  };

  var prefix$27 = settings_1.prefix;
  var Switcher = /*#__PURE__*/React__default.forwardRef(function Switcher(props, ref) {
    var ariaLabel = props['aria-label'],
        ariaLabelledBy = props['aria-labelledby'],
        customClassName = props.className,
        children = props.children;
    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    var className = classnames("".concat(prefix$27, "--switcher"), _defineProperty({}, customClassName, !!customClassName));
    return /*#__PURE__*/React__default.createElement("ul", _extends({
      ref: ref,
      className: className
    }, accessibilityLabel), children);
  });
  Switcher.propTypes = _objectSpread2(_objectSpread2({}, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class to apply to the underlying <ul> node
     */
    className: PropTypes.string,

    /**
     * expects to receive <SwitcherItem />
     */
    children: PropTypes.node.isRequired
  });

  var prefix$28 = settings_1.prefix;
  var SwitcherItem = /*#__PURE__*/React__default.forwardRef(function SwitcherItem(props, ref) {
    var ariaLabel = props['aria-label'],
        ariaLabelledBy = props['aria-labelledby'],
        customClassName = props.className,
        children = props.children,
        isSelected = props.isSelected,
        rest = _objectWithoutProperties(props, ["aria-label", "aria-labelledby", "className", "children", "isSelected"]);

    var className = classnames("".concat(prefix$28, "--switcher__item"), _defineProperty({}, customClassName, !!customClassName));
    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    var linkClassName = classnames("".concat(prefix$28, "--switcher__item-link"), _defineProperty({}, "".concat(prefix$28, "--switcher__item-link--selected"), isSelected));
    return /*#__PURE__*/React__default.createElement("li", {
      className: className
    }, /*#__PURE__*/React__default.createElement(Link$1, _extends({}, rest, {
      ref: ref,
      className: linkClassName,
      tabIndex: 0
    }, accessibilityLabel), children));
  });
  SwitcherItem.propTypes = _objectSpread2(_objectSpread2({}, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class to apply to the underlying <li> node
     */
    className: PropTypes.string,

    /**
     * Specify the text content for the link
     */
    children: PropTypes.node.isRequired
  });

  var prefix$29 = settings_1.prefix;

  var SwitcherDivider = function SwitcherDivider(_ref) {
    var customClassName = _ref.className,
        other = _objectWithoutProperties(_ref, ["className"]);

    var className = classnames("".concat(prefix$29, "--switcher__item--divider"), _defineProperty({}, customClassName, !!customClassName));
    return /*#__PURE__*/React__default.createElement("hr", _extends({}, other, {
      className: className
    }));
  };

  SwitcherDivider.propTypes = {
    /**
     * Optionally provide a custom class to apply to the underlying <li> node
     */
    className: PropTypes.string
  };

  var prefix$2a = settings_1.prefix;

  var SkipToContent = function SkipToContent(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        href = _ref.href,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties(_ref, ["children", "className", "href", "tabIndex"]);

    var className = classnames("".concat(prefix$2a, "--skip-to-content"), customClassName);
    return /*#__PURE__*/React__default.createElement("a", _extends({}, rest, {
      className: className,
      href: href,
      tabIndex: tabIndex
    }), children);
  };

  SkipToContent.propTypes = {
    className: PropTypes.string,

    /**
     * Provide text to display in the SkipToContent `a` tag
     */
    children: PropTypes.string.isRequired,

    /**
     * Provide the `href` to the id of the element on your package that is the
     * main content.
     */
    href: PropTypes.string.isRequired,

    /**
     * Optionally override the default tabindex of 0
     */
    tabIndex: PropTypes.string
  };
  SkipToContent.defaultProps = {
    children: 'Skip to main content',
    href: '#main-content',
    tabIndex: '0'
  };

  // import SideNavFooter from './SideNavFooter';

  var prefix$2b = settings_1.prefix;
  var SideNav$1 = /*#__PURE__*/React__default.forwardRef(function SideNav(props, ref) {
    var _cx, _cx2;

    var expandedProp = props.expanded,
        defaultExpanded = props.defaultExpanded,
        isChildOfHeader = props.isChildOfHeader,
        ariaLabel = props['aria-label'],
        ariaLabelledBy = props['aria-labelledby'],
        children = props.children,
        onToggle = props.onToggle,
        customClassName = props.className,
        isFixedNav = props.isFixedNav,
        isRail = props.isRail,
        isPersistent = props.isPersistent,
        addFocusListeners = props.addFocusListeners,
        addMouseListeners = props.addMouseListeners;

    var _useRef = React.useRef(expandedProp !== undefined),
        controlled = _useRef.current;

    var _useState = React.useState(defaultExpanded),
        _useState2 = _slicedToArray(_useState, 2),
        expandedState = _useState2[0],
        setExpandedState = _useState2[1];

    var _useState3 = React.useState(defaultExpanded),
        _useState4 = _slicedToArray(_useState3, 2),
        expandedViaHoverState = _useState4[0],
        setExpandedViaHoverState = _useState4[1];

    var expanded = controlled ? expandedProp : expandedState;

    var handleToggle = function handleToggle(event) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !expanded;

      if (!controlled) {
        setExpandedState(value);
      }

      if (onToggle) {
        onToggle(event, value);
      }

      if (controlled || isRail) {
        setExpandedViaHoverState(value);
      }
    };

    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    }; // TO-DO: comment back in when footer is added for rails
    // const assistiveText = expanded
    //   ? t('carbon.sidenav.state.open')
    //   : t('carbon.sidenav.state.closed');

    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$2b, "--side-nav"), true), _defineProperty(_cx, "".concat(prefix$2b, "--side-nav--expanded"), expanded || expandedViaHoverState), _defineProperty(_cx, "".concat(prefix$2b, "--side-nav--collapsed"), !expanded && isFixedNav), _defineProperty(_cx, "".concat(prefix$2b, "--side-nav--rail"), isRail), _defineProperty(_cx, customClassName, !!customClassName), _defineProperty(_cx, "".concat(prefix$2b, "--side-nav--ux"), isChildOfHeader), _defineProperty(_cx, "".concat(prefix$2b, "--side-nav--hidden"), !isPersistent), _cx));
    var overlayClassName = classnames((_cx2 = {}, _defineProperty(_cx2, "".concat(prefix$2b, "--side-nav__overlay"), true), _defineProperty(_cx2, "".concat(prefix$2b, "--side-nav__overlay-active"), expanded), _cx2));
    var childrenToRender = children; // if a rail, pass the expansion state as a prop, so children can update themselves to match

    if (isRail) {
      childrenToRender = React__default.Children.map(children, function (child) {
        // if we are controlled, check for if we have hovered over or the expanded state, else just use the expanded state (uncontrolled)
        var currentExpansionState = controlled ? expandedViaHoverState || expanded : expanded;
        return /*#__PURE__*/React__default.cloneElement(child, {
          isSideNavExpanded: currentExpansionState
        });
      });
    }

    var eventHandlers = {};

    if (addFocusListeners) {
      eventHandlers.onFocus = function (event) {
        if (!event.currentTarget.contains(event.relatedTarget)) {
          handleToggle(event, true);
        }
      };

      eventHandlers.onBlur = function (event) {
        if (!event.currentTarget.contains(event.relatedTarget)) {
          handleToggle(event, false);
        }
      };
    }

    if (addMouseListeners && isRail) {
      eventHandlers.onMouseEnter = function () {
        return handleToggle(true, true);
      };

      eventHandlers.onMouseLeave = function () {
        return handleToggle(false, false);
      };
    }

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isFixedNav ? null : /*#__PURE__*/React__default.createElement("div", {
      className: overlayClassName
    }), /*#__PURE__*/React__default.createElement("nav", _extends({
      ref: ref,
      className: "".concat(prefix$2b, "--side-nav__navigation ").concat(className)
    }, accessibilityLabel, eventHandlers), childrenToRender));
  });
  SideNav$1.defaultProps = {
    translateById: function translateById(id) {
      var translations = {
        'carbon.sidenav.state.open': 'Close',
        'carbon.sidenav.state.closed': 'Open'
      };
      return translations[id];
    },
    defaultExpanded: false,
    isChildOfHeader: true,
    isFixedNav: false,
    isPersistent: true,
    addFocusListeners: true,
    addMouseListeners: true
  };
  SideNav$1.propTypes = _objectSpread2(_objectSpread2({
    /**
     * If `true`, the SideNav will be expanded, otherwise it will be collapsed.
     * Using this prop causes SideNav to become a controled component.
     */
    expanded: PropTypes.bool,

    /**
     * If `true`, the SideNav will be open on initial render.
     */
    defaultExpanded: PropTypes.bool,

    /**
     * An optional listener that is called when an event that would cause
     * toggling the SideNav occurs.
     *
     * @param {object} event
     * @param {boolean} value
     */
    onToggle: PropTypes.func
  }, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class to apply to the underlying <li> node
     */
    className: PropTypes.string,

    /**
     * Provide a custom function for translating all message ids within this
     * component. This function will take in two arguments: the mesasge Id and the
     * state of the component. From this, you should return a string representing
     * the label you want displayed or read by screen readers.
     */
    translateById: PropTypes.func,

    /**
     * Optionally provide a custom class to apply to the underlying <li> node
     */
    isChildOfHeader: PropTypes.bool,

    /**
     * Optional prop to display the side nav rail.
     */
    isRail: PropTypes.bool,

    /**
     * Specify if sideNav is standalone
     */
    isFixedNav: PropTypes.bool,

    /**
     * Specify if the sideNav will be persistent above the lg breakpoint
     */
    isPersistent: PropTypes.bool,

    /**
     * Specify whether focus and blur listeners are added. They are by default.
     */
    addFocusListeners: PropTypes.bool,

    /**
     * Specify whether mouse entry/exit listeners are added. They are by default.
     */
    addMouseListeners: PropTypes.bool
  });

  var prefix$2c = settings_1.prefix;

  var SideNavDetails = function SideNavDetails(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        title = _ref.title;
    var className = classnames("".concat(prefix$2c, "--side-nav__details"), customClassName);
    return /*#__PURE__*/React__default.createElement("div", {
      className: className
    }, /*#__PURE__*/React__default.createElement("h2", {
      className: "".concat(prefix$2c, "--side-nav__title"),
      title: title
    }, title), children);
  };

  SideNavDetails.propTypes = {
    /**
     * Optionally provide a custom class to apply to the underlying <li> node
     */
    className: PropTypes.string,

    /**
     * Provide optional children to render in `SideNavDetails`. Useful for
     * rendering the `SideNavSwitcher` component.
     */
    children: PropTypes.node,

    /**
     * Provide the text that will be rendered as the title in the component
     */
    title: PropTypes.string.isRequired
  };

  var prefix$2d = settings_1.prefix;
  /**
   * SideNavFooter is used for rendering the button at the bottom of the side
   * navigation that is a part of the UI Shell. It is responsible for handling the
   * user interaction to expand or collapse the side navigation.
   */

  var SideNavFooter = function SideNavFooter(_ref) {
    var assistiveText = _ref.assistiveText,
        customClassName = _ref.className,
        expanded = _ref.expanded,
        onToggle = _ref.onToggle;
    var className = classnames("".concat(prefix$2d, "--side-nav__footer"), customClassName);
    return /*#__PURE__*/React__default.createElement("footer", {
      className: className
    }, /*#__PURE__*/React__default.createElement("button", {
      className: "".concat(prefix$2d, "--side-nav__toggle"),
      type: "button",
      onClick: function onClick(evt) {
        return onToggle(evt);
      },
      title: assistiveText
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$2d, "--side-nav__icon")
    }, expanded ? /*#__PURE__*/React__default.createElement(Close20, null) : /*#__PURE__*/React__default.createElement(ChevronRight20, null)), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(prefix$2d, "--assistive-text")
    }, assistiveText)));
  };

  SideNavFooter.propTypes = {
    /**
     * Provide text to be read to screen readers and shown as a tooltip when
     * interacting with the toggle button in the footer
     */
    assistiveText: PropTypes.string.isRequired,

    /**
     * Specify whether the side navigation is expanded or collapsed
     */
    expanded: PropTypes.bool.isRequired,

    /**
     * Provide a function that is called when the toggle button is interacted
     * with. Useful for controlling the expansion state of the side navigation.
     */
    onToggle: PropTypes.func.isRequired,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes.bool,
    className: PropTypes.string
  };
  SideNavFooter.defaultProps = {
    assistiveText: 'Toggle opening or closing the side navigation'
  };

  var prefix$2e = settings_1.prefix;

  var SideNavIcon = function SideNavIcon(_ref) {
    var _cx;

    var children = _ref.children,
        customClassName = _ref.className,
        small = _ref.small;
    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$2e, "--side-nav__icon"), true), _defineProperty(_cx, "".concat(prefix$2e, "--side-nav__icon--small"), small), _defineProperty(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default.createElement("div", {
      className: className
    }, children);
  };

  SideNavIcon.propTypes = {
    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Provide a single icon as the child to `SideNavIcon` to render in the
     * container
     */
    children: PropTypes.node.isRequired,

    /**
     * Specify whether the icon should be placed in a smaller bounding box
     */
    small: PropTypes.bool.isRequired
  };
  SideNavIcon.defaultProps = {
    small: false
  };

  var prefix$2f = settings_1.prefix;

  var SideNavHeader = function SideNavHeader(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        IconElement = _ref.renderIcon;
    var className = classnames("".concat(prefix$2f, "--side-nav__header"), customClassName);
    return /*#__PURE__*/React__default.createElement("header", {
      className: className
    }, /*#__PURE__*/React__default.createElement(SideNavIcon, null, /*#__PURE__*/React__default.createElement(IconElement, null)), children);
  };

  SideNavHeader.propTypes = {
    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Provide an icon to render in the header of the side navigation. Should be
     * a React class.
     */
    renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes.bool,

    /**
     * The child nodes to be rendered
     */
    children: PropTypes.node
  };

  var prefix$2g = settings_1.prefix;

  var SideNavItem = function SideNavItem(_ref) {
    var _cx;

    var customClassName = _ref.className,
        children = _ref.children,
        _ref$large = _ref.large,
        large = _ref$large === void 0 ? false : _ref$large;
    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$2g, "--side-nav__item"), true), _defineProperty(_cx, "".concat(prefix$2g, "--side-nav__item--large"), large), _defineProperty(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default.createElement("li", {
      className: className
    }, children);
  };

  SideNavItem.propTypes = {
    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Provide a single icon as the child to `SideNavIcon` to render in the
     * container
     */
    children: PropTypes.node.isRequired,

    /**
     * Specify if this is a large variation of the SideNavItem
     */
    large: PropTypes.bool
  };

  var prefix$2h = settings_1.prefix;

  var SideNavItems = function SideNavItems(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        isSideNavExpanded = _ref.isSideNavExpanded;
    var className = classnames(["".concat(prefix$2h, "--side-nav__items")], customClassName);
    var childrenWithExpandedState = React__default.Children.map(children, function (child) {
      if ( /*#__PURE__*/React__default.isValidElement(child)) {
        return /*#__PURE__*/React__default.cloneElement(child, {
          isSideNavExpanded: isSideNavExpanded
        });
      }
    });
    return /*#__PURE__*/React__default.createElement("ul", {
      className: className
    }, childrenWithExpandedState);
  };

  SideNavItems.propTypes = {
    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Provide a single icon as the child to `SideNavIcon` to render in the
     * container
     */
    children: PropTypes.node.isRequired,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes.bool
  };

  var prefix$2i = settings_1.prefix;

  var SideNavLinkText = function SideNavLinkText(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties(_ref, ["className", "children"]);

    var className = classnames("".concat(prefix$2i, "--side-nav__link-text"), customClassName);
    return /*#__PURE__*/React__default.createElement("span", _extends({}, rest, {
      className: className
    }), children);
  };

  SideNavLinkText.propTypes = {
    /**
     * Provide the content for the link text
     */
    children: PropTypes.node.isRequired,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string
  };

  var prefix$2j = settings_1.prefix;

  var SideNavLink = function SideNavLink(_ref) {
    var _cx;

    var customClassName = _ref.className,
        children = _ref.children,
        IconElement = _ref.renderIcon,
        isActive = _ref.isActive,
        large = _ref.large,
        isSideNavExpanded = _ref.isSideNavExpanded,
        rest = _objectWithoutProperties(_ref, ["className", "children", "renderIcon", "isActive", "large", "isSideNavExpanded"]);

    var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$2j, "--side-nav__link"), true), _defineProperty(_cx, "".concat(prefix$2j, "--side-nav__link--current"), isActive), _defineProperty(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default.createElement(SideNavItem, {
      large: large
    }, /*#__PURE__*/React__default.createElement(Link$1, _extends({}, rest, {
      className: className
    }), IconElement && /*#__PURE__*/React__default.createElement(SideNavIcon, {
      small: true
    }, /*#__PURE__*/React__default.createElement(IconElement, null)), /*#__PURE__*/React__default.createElement(SideNavLinkText, null, children)));
  };

  SideNavLink.propTypes = _objectSpread2(_objectSpread2({}, LinkPropTypes), {}, {
    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Provide an icon to render in the side navigation link. Should be a React class.
     */
    renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),

    /**
     * Specify the text content for the link
     */
    children: PropTypes.node.isRequired,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes.bool,

    /**
     * Specify if this is a large variation of the SideNavLink
     */
    large: PropTypes.bool
  });
  SideNavLink.defaultProps = {
    element: 'a',
    large: false
  };

  var prefix$2k = settings_1.prefix;
  var SideNavMenu = /*#__PURE__*/function (_React$Component) {
    _inherits(SideNavMenu, _React$Component);

    var _super = _createSuper(SideNavMenu);

    function SideNavMenu(props) {
      var _this;

      _classCallCheck(this, SideNavMenu);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "handleToggleExpand", function () {
        _this.setState(function (state) {
          return {
            isExpanded: !state.isExpanded
          };
        });
      });

      _defineProperty(_assertThisInitialized(_this), "handleKeyDown", function (event) {
        if (match(event, Escape)) {
          _this.setState(function () {
            return {
              isExpanded: false
            };
          });
        }
      });

      _this.state = {
        isExpanded: props.defaultExpanded || false,
        wasPreviouslyExpanded: props.defaultExpanded || false
      };
      return _this;
    }

    _createClass(SideNavMenu, [{
      key: "render",
      value: function render() {
        var _cx;

        var _this$props = this.props,
            buttonRef = _this$props.buttonRef,
            customClassName = _this$props.className,
            children = _this$props.children,
            IconElement = _this$props.renderIcon,
            isActive = _this$props.isActive,
            title = _this$props.title,
            large = _this$props.large;
        var isExpanded = this.state.isExpanded;
        var hasActiveChild;

        if (children) {
          // if we have children, either a single or multiple, find if it is active
          hasActiveChild = Array.isArray(children) ? children.some(function (child) {
            if (child.props && (child.props.isActive === true || child.props['aria-current'])) {
              return true;
            }

            return false;
          }) : children.props && (children.props.isActive === true || children.props['aria-current']);
        }

        var className = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$2k, "--side-nav__item"), true), _defineProperty(_cx, "".concat(prefix$2k, "--side-nav__item--active"), isActive || hasActiveChild && !isExpanded), _defineProperty(_cx, "".concat(prefix$2k, "--side-nav__item--icon"), IconElement), _defineProperty(_cx, "".concat(prefix$2k, "--side-nav__item--large"), large), _defineProperty(_cx, customClassName, !!customClassName), _cx));
        return (
          /*#__PURE__*/
          // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
          React__default.createElement("li", {
            className: className,
            onKeyDown: this.handleKeyDown
          }, /*#__PURE__*/React__default.createElement("button", {
            "aria-expanded": isExpanded,
            className: "".concat(prefix$2k, "--side-nav__submenu"),
            onClick: this.handleToggleExpand,
            ref: buttonRef,
            type: "button"
          }, IconElement && /*#__PURE__*/React__default.createElement(SideNavIcon, null, /*#__PURE__*/React__default.createElement(IconElement, null)), /*#__PURE__*/React__default.createElement("span", {
            className: "".concat(prefix$2k, "--side-nav__submenu-title")
          }, title), /*#__PURE__*/React__default.createElement(SideNavIcon, {
            className: "".concat(prefix$2k, "--side-nav__submenu-chevron"),
            small: true
          }, /*#__PURE__*/React__default.createElement(ChevronDown20, null))), /*#__PURE__*/React__default.createElement("ul", {
            className: "".concat(prefix$2k, "--side-nav__menu")
          }, children))
        );
      }
    }]);

    return SideNavMenu;
  }(React__default.Component);

  _defineProperty(SideNavMenu, "propTypes", {
    buttonRef: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({
      current: PropTypes.any
    })]),

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Provide <SideNavMenuItem>'s inside of the `SideNavMenu`
     */
    children: PropTypes.node,

    /**
     * Pass in a custom icon to render next to the `SideNavMenu` title
     */
    renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),

    /**
     * Specify whether the `SideNavMenu` is "active". `SideNavMenu` should be
     * considered active if one of its menu items are a link for the current
     * page.
     */
    isActive: PropTypes.bool,

    /**
     * Provide the text for the overall menu name
     */
    title: PropTypes.string.isRequired,

    /**
     * Specify whether the menu should default to expanded. By default, it will
     * be closed.
     */
    defaultExpanded: PropTypes.bool,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes.bool,

    /**
     * Specify if this is a large variation of the SideNavMenu
     */
    large: PropTypes.bool
  });

  _defineProperty(SideNavMenu, "defaultProps", {
    defaultExpanded: false,
    isActive: false,
    large: false
  });

  _defineProperty(SideNavMenu, "getDerivedStateFromProps", function (props, state) {
    var derivedState = null;

    if (props.isSideNavExpanded === false && state.isExpanded === true) {
      derivedState = {
        isExpanded: props.isSideNavExpanded,
        wasPreviouslyExpanded: true
      };
    } else if (props.isSideNavExpanded === true && state.wasPreviouslyExpanded === true) {
      derivedState = {
        isExpanded: props.isSideNavExpanded,
        wasPreviouslyExpanded: false
      };
    }

    return derivedState;
  });

  var SideNavMenuForwardRef = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
    return /*#__PURE__*/React__default.createElement(SideNavMenu, _extends({}, props, {
      buttonRef: ref
    }));
  });
  SideNavMenuForwardRef.displayName = 'SideNavMenu';

  var prefix$2l = settings_1.prefix;
  var SideNavMenuItem = /*#__PURE__*/React__default.forwardRef(function SideNavMenuItem(props, ref) {
    var _cx;

    var children = props.children,
        customClassName = props.className,
        isActive = props.isActive,
        rest = _objectWithoutProperties(props, ["children", "className", "isActive"]);

    var className = classnames("".concat(prefix$2l, "--side-nav__menu-item"), customClassName);
    var linkClassName = classnames((_cx = {}, _defineProperty(_cx, "".concat(prefix$2l, "--side-nav__link"), true), _defineProperty(_cx, "".concat(prefix$2l, "--side-nav__link--current"), isActive), _cx));
    return /*#__PURE__*/React__default.createElement("li", {
      className: className
    }, /*#__PURE__*/React__default.createElement(Link$1, _extends({}, rest, {
      className: linkClassName,
      ref: ref
    }), /*#__PURE__*/React__default.createElement(SideNavLinkText, null, children)));
  });
  SideNavMenuItem.propTypes = {
    /**
     * Specify the childrento be rendered inside of the `SideNavMenuItem`
     */
    children: PropTypes.node,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Optionally specify whether the link is "active". An active link is one that
     * has an href that is the same as the current page. Can also pass in
     * `aria-current="page"`, as well.
     */
    isActive: PropTypes.bool
  };

  var prefix$2m = settings_1.prefix;
  var SideNavSwitcher = /*#__PURE__*/React__default.forwardRef(function SideNavSwitcher(props, ref) {
    var customClassName = props.className,
        labelText = props.labelText,
        onChange = props.onChange,
        options = props.options;
    var className = classnames("".concat(prefix$2m, "--side-nav__switcher"), customClassName); // Note for usage around `onBlur`: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-onchange.md

    return /*#__PURE__*/React__default.createElement("div", {
      className: className
    }, /*#__PURE__*/React__default.createElement("label", {
      htmlFor: "side-nav-switcher",
      className: "".concat(prefix$2m, "--assistive-text")
    }, labelText), /*#__PURE__*/React__default.createElement("select", {
      id: "carbon-side-nav-switcher",
      className: "".concat(prefix$2m, "--side-nav__select"),
      defaultValue: "",
      onBlur: onChange,
      onChange: onChange,
      ref: ref
    }, /*#__PURE__*/React__default.createElement("option", {
      className: "".concat(prefix$2m, "--side-nav__option"),
      disabled: true,
      hidden: true,
      value: ""
    }, labelText), options.map(function (option) {
      return /*#__PURE__*/React__default.createElement("option", {
        key: option,
        className: "".concat(prefix$2m, "--side-nav__option"),
        value: option
      }, option);
    })), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix$2m, "--side-nav__switcher-chevron")
    }, /*#__PURE__*/React__default.createElement(ChevronDown20, null)));
  });
  SideNavSwitcher.propTypes = {
    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes.string,

    /**
     * Provide the label for the switcher. This will be the firt visible option
     * when someone views this control
     */
    labelText: PropTypes.string.isRequired,

    /**
     * Provide a callback function that is called whenever the switcher value is
     * updated
     */
    onChange: PropTypes.func,

    /**
     * Provide an array of options to be rendered in the switcher as an
     * `<option>`. The text value will be what is displayed to the user and is set
     * as the `value` prop for each `<option>`.
     */
    options: PropTypes.arrayOf(PropTypes.string).isRequired
  };

  var prefix$2n = settings_1.prefix;

  function Unstable_Pagination(_ref) {
    var backwardText = _ref.backwardText,
        children = _ref.children,
        className = _ref.className,
        disabled = _ref.disabled,
        forwardText = _ref.forwardText,
        id = _ref.id,
        initialPage = _ref.initialPage,
        itemsPerPageText = _ref.itemsPerPageText,
        itemRangeText = _ref.itemRangeText,
        itemText = _ref.itemText,
        pageRangeText = _ref.pageRangeText,
        pageSize = _ref.pageSize,
        pageSizes = _ref.pageSizes,
        pageText = _ref.pageText,
        pagesUnknown = _ref.pagesUnknown,
        totalItems = _ref.totalItems,
        other = _objectWithoutProperties(_ref, ["backwardText", "children", "className", "disabled", "forwardText", "id", "initialPage", "itemsPerPageText", "itemRangeText", "itemText", "pageRangeText", "pageSize", "pageSizes", "pageText", "pagesUnknown", "totalItems"]);

    var _useState = React.useState(initialPage),
        _useState2 = _slicedToArray(_useState, 2),
        currentPage = _useState2[0],
        setCurrentPage = _useState2[1];

    var _useState3 = React.useState(pageSize),
        _useState4 = _slicedToArray(_useState3, 2),
        currentPageSize = _useState4[0],
        setCurrentPageSize = _useState4[1];

    var totalPages = totalItems ? Math.max(Math.ceil(totalItems / currentPageSize), 1) : undefined;
    var backButtonDisabled = disabled || currentPage === 1;
    var forwardButtonDisabled = disabled || currentPage === totalPages;

    function onSetPage(newPage) {
      setCurrentPage(Number(newPage));
    }

    var namespace = "".concat(prefix$2n, "--unstable-pagination");
    return /*#__PURE__*/React__default.createElement("section", _extends({
      className: classnames(namespace, className)
    }, other), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(namespace, "__left")
    }, pageSizes && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("label", {
      id: "".concat(namespace, "__page-sizer__counter-").concat(id),
      className: "".concat(namespace, "__text"),
      htmlFor: "".concat(namespace, "__page-sizer__input-").concat(id)
    }, itemsPerPageText), /*#__PURE__*/React__default.createElement(Select, {
      id: "".concat(namespace, "__page-sizer__input-").concat(id),
      className: "".concat(namespace, "__page-sizer"),
      labelText: "",
      hideLabel: true,
      noLabel: true,
      inline: true,
      onChange: function onChange(event) {
        return setCurrentPageSize(Number(event.target.value));
      },
      value: currentPageSize
    }, pageSizes.map(function (size) {
      return /*#__PURE__*/React__default.createElement(SelectItem, {
        key: size,
        value: size,
        text: String(size)
      });
    }))), /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(namespace, "__text")
    }, totalItems && !pagesUnknown && itemRangeText(Math.min(currentPageSize * (currentPage - 1) + 1, totalItems), Math.min(currentPage * currentPageSize, totalItems), totalItems), totalItems && pagesUnknown && itemText(currentPageSize * (currentPage - 1) + 1, currentPage * currentPageSize), !totalItems && itemText(currentPageSize * (currentPage - 1) + 1, currentPage * currentPageSize))), /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(namespace, "__right")
    }, children && totalItems && children({
      currentPage: currentPage,
      currentPageSize: currentPageSize,
      onSetPage: onSetPage,
      totalPages: totalPages
    }), children && totalItems && !pagesUnknown && /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(namespace, "__text")
    }, pageRangeText('', totalPages)), children && !totalItems && /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(namespace, "__text")
    }, pageText(currentPage)), !children && /*#__PURE__*/React__default.createElement("span", {
      className: "".concat(namespace, "__text")
    }, !totalItems ? pageText(currentPage) : pageRangeText(currentPage, totalPages)), /*#__PURE__*/React__default.createElement(Button, {
      className: classnames("".concat(namespace, "__button"), "".concat(namespace, "__button--backward"), _defineProperty({}, "".concat(namespace, "__button--no-index"), backButtonDisabled)),
      onClick: function onClick() {
        return setCurrentPage(currentPage - 1);
      },
      disabled: backButtonDisabled,
      hasIconOnly: true,
      renderIcon: CaretLeft16,
      tooltipAlignment: "center",
      tooltipPosition: "top",
      iconDescription: backwardText
    }), /*#__PURE__*/React__default.createElement(Button, {
      className: classnames("".concat(namespace, "__button"), "".concat(namespace, "__button--forward"), _defineProperty({}, "".concat(namespace, "__button--no-index"), forwardButtonDisabled)),
      onClick: function onClick() {
        return setCurrentPage(currentPage + 1);
      },
      disabled: forwardButtonDisabled,
      hasIconOnly: true,
      renderIcon: CaretRight16,
      tooltipAlignment: "center",
      tooltipPosition: "top",
      iconDescription: forwardText
    })));
  }

  Unstable_Pagination.defaultProps = {
    backwardText: 'Previous page',
    className: null,
    children: undefined,
    disabled: false,
    forwardText: 'Next page',
    id: 1,
    itemsPerPageText: 'Items per page:',
    itemRangeText: function itemRangeText(min, max, total) {
      return "".concat(min, "\u2013").concat(max, " of ").concat(total, " items");
    },
    itemText: function itemText(min, max) {
      return "".concat(min, "\u2013").concat(max, " items");
    },
    initialPage: 1,
    pageRangeText: function pageRangeText(current, total) {
      return "".concat(current, " of ").concat(total, " pages");
    },
    pageSize: 10,
    pageSizes: undefined,
    pageText: function pageText(page) {
      return "page ".concat(page);
    },
    pagesUnknown: false,
    totalItems: undefined
  };
  Unstable_Pagination.propTypes = {
    /**
     * The description for the backward icon.
     */
    backwardText: PropTypes.string,

    /**
     * The children of the pagination component.
     */
    children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

    /**
     * Extra classes to add.
     */
    className: PropTypes.string,

    /**
     * `true` if the backward/forward buttons should be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * The description for the forward icon.
     */
    forwardText: PropTypes.string,

    /** The unique ID of this component instance. */
    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * The translatable text indicating the number of items per page.
     */
    itemsPerPageText: PropTypes.string,

    /**
     * The function returning a translatable text showing where the current page is,
     * in a manner of the range of items.
     */
    itemRangeText: PropTypes.func,

    /**
     * A variant of `itemRangeText`, used if the total number of items is unknown.
     */
    itemText: PropTypes.func,

    /**
     * The initial active page when the component is first mounted.
     */
    initialPage: PropTypes.number,

    /**
     * The function returning a translatable text showing where the current page is,
     * in a manner of the total number of pages.
     */
    pageRangeText: PropTypes.func,

    /**
     * The number dictating how many items a page contains.
     */
    pageSize: PropTypes.number,

    /**
     * The choices for `pageSize`.
     */
    pageSizes: PropTypes.arrayOf(PropTypes.number),

    /**
     * The translatable text showing the current page.
     */
    pageText: PropTypes.func,

    /**
     * `true` if total number of pages is unknown.
     */
    pagesUnknown: PropTypes.bool,

    /**
     * The total number of items.
     * You need to provide total items to calculate total page,
     * which is required by a child like the `PageSelector`
     * to know how many pages to display.
     */
    totalItems: PropTypes.number
  };

  var prefix$2o = settings_1.prefix;
  var getInstanceId$c = setupGetInstanceId();

  function PageSelector(_ref) {
    var className = _ref.className,
        currentPage = _ref.currentPage,
        id = _ref.id,
        labelText = _ref.labelText,
        totalPages = _ref.totalPages,
        other = _objectWithoutProperties(_ref, ["className", "currentPage", "id", "labelText", "totalPages"]);

    var namespace = "".concat(prefix$2o, "--unstable-pagination__page-selector");
    var instanceId = "".concat(namespace, "__select-").concat(getInstanceId$c());

    var renderPages = function renderPages(total) {
      var pages = [];

      for (var counter = 1; counter <= total; counter += 1) {
        pages.push( /*#__PURE__*/React__default.createElement(SelectItem, {
          key: counter,
          value: counter,
          text: String(counter)
        }));
      }

      return pages;
    };

    return /*#__PURE__*/React__default.createElement(Select, _extends({
      className: classnames(namespace, className),
      hideLabel: true,
      id: instanceId || id,
      inline: true,
      labelText: labelText,
      value: currentPage
    }, other), renderPages(totalPages));
  }

  PageSelector.propTypes = {
    /** Extra class names to add. */
    className: PropTypes.string,

    /** The current page. */
    currentPage: PropTypes.number.isRequired,

    /** The unique ID of this component instance. */
    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /** Translatable string to label the page selector element. */
    labelText: PropTypes.string,

    /**
     * Total number of pages.
     * This value is calculated using a valid `totalItems` prop passed to the parent `Unstable_Pagination`.
     */
    totalPages: PropTypes.number.isRequired
  };
  PageSelector.defaultProps = {
    className: null,
    id: 1,
    labelText: 'Current page number'
  };

  exports.Accordion = Accordion$1;
  exports.AccordionItem = AccordionItem;
  exports.AccordionSkeleton = AccordionSkeleton;
  exports.Breadcrumb = Breadcrumb;
  exports.BreadcrumbItem = BreadcrumbItem;
  exports.BreadcrumbSkeleton = BreadcrumbSkeleton;
  exports.Button = Button;
  exports.ButtonSkeleton = ButtonSkeleton;
  exports.Checkbox = Checkbox$1;
  exports.CheckboxSkeleton = CheckboxSkeleton;
  exports.ClickableTile = ClickableTile;
  exports.CodeSnippet = CodeSnippet$1;
  exports.CodeSnippetSkeleton = CodeSnippetSkeleton;
  exports.Column = Column;
  exports.ComboBox = ComboBox;
  exports.ComposedModal = ComposedModal;
  exports.Content = Content;
  exports.ContentSwitcher = ContentSwitcher$1;
  exports.Copy = Copy;
  exports.CopyButton = CopyButton$1;
  exports.DangerButton = DangerButton;
  exports.DataTable = DataTable$1;
  exports.DataTableSkeleton = DataTableSkeleton;
  exports.DatePicker = DatePicker$1;
  exports.DatePickerInput = DatePickerInput;
  exports.DatePickerSkeleton = DatePickerSkeleton;
  exports.Dropdown = Dropdown$1;
  exports.DropdownSkeleton = DropdownSkeleton;
  exports.ErrorBoundary = ErrorBoundary;
  exports.ErrorBoundaryContext = ErrorBoundaryContext;
  exports.ExpandableTile = ExpandableTile;
  exports.FileUploader = FileUploader$1;
  exports.FileUploaderButton = FileUploaderButton;
  exports.FileUploaderDropContainer = FileUploaderDropContainer;
  exports.FileUploaderItem = FileUploaderItem;
  exports.FileUploaderSkeleton = FileUploaderSkeleton;
  exports.Filename = Filename;
  exports.FluidForm = FluidForm;
  exports.Form = Form;
  exports.FormGroup = FormGroup;
  exports.FormItem = FormItem;
  exports.FormLabel = FormLabel;
  exports.Grid = Grid;
  exports.Header = Header;
  exports.HeaderContainer = HeaderContainer;
  exports.HeaderGlobalAction = HeaderGlobalAction;
  exports.HeaderGlobalBar = HeaderGlobalBar;
  exports.HeaderMenu = HeaderMenuForwardRef;
  exports.HeaderMenuButton = HeaderMenuButton;
  exports.HeaderMenuItem = HeaderMenuItem;
  exports.HeaderName = HeaderName;
  exports.HeaderNavigation = HeaderNavigation;
  exports.HeaderPanel = HeaderPanel;
  exports.HeaderSideNavItems = HeaderSideNavItems;
  exports.Icon = Icon$1;
  exports.IconSkeleton = IconSkeleton;
  exports.InlineLoading = InlineLoading$1;
  exports.InlineNotification = InlineNotification;
  exports.Link = Link;
  exports.ListItem = ListItem;
  exports.Loading = Loading$1;
  exports.Modal = Modal$1;
  exports.ModalBody = ModalBody;
  exports.ModalFooter = ModalFooter;
  exports.ModalHeader = ModalHeader;
  exports.ModalWrapper = ModalWrapper;
  exports.MultiSelect = MultiSelect;
  exports.NotificationActionButton = NotificationActionButton;
  exports.NotificationButton = NotificationButton;
  exports.NotificationTextDetails = NotificationTextDetails;
  exports.NumberInput = NumberInput$2;
  exports.NumberInputSkeleton = NumberInputSkeleton;
  exports.OrderedList = OrderedList;
  exports.OverflowMenu = OverflowMenu$2;
  exports.OverflowMenuItem = OverflowMenuItem;
  exports.PageSelector = PageSelector;
  exports.Pagination = Pagination$1;
  exports.PaginationSkeleton = PaginationSkeleton;
  exports.PrimaryButton = PrimaryButton;
  exports.ProgressIndicator = ProgressIndicator$1;
  exports.ProgressIndicatorSkeleton = ProgressIndicatorSkeleton;
  exports.ProgressStep = ProgressStep;
  exports.RadioButton = RadioButton$1;
  exports.RadioButtonGroup = RadioButtonGroup;
  exports.RadioButtonSkeleton = RadioButtonSkeleton;
  exports.RadioTile = RadioTile;
  exports.Row = Row;
  exports.Search = Search$1;
  exports.SearchFilterButton = SearchFilterButton;
  exports.SearchLayoutButton = SearchLayoutButton;
  exports.SearchSkeleton = SearchSkeleton;
  exports.SecondaryButton = SecondaryButton;
  exports.Select = Select;
  exports.SelectItem = SelectItem;
  exports.SelectItemGroup = SelectItemGroup;
  exports.SelectSkeleton = SelectSkeleton;
  exports.SelectableTile = SelectableTile;
  exports.SideNav = SideNav$1;
  exports.SideNavDetails = SideNavDetails;
  exports.SideNavFooter = SideNavFooter;
  exports.SideNavHeader = SideNavHeader;
  exports.SideNavIcon = SideNavIcon;
  exports.SideNavItem = SideNavItem;
  exports.SideNavItems = SideNavItems;
  exports.SideNavLink = SideNavLink;
  exports.SideNavLinkText = SideNavLinkText;
  exports.SideNavMenu = SideNavMenuForwardRef;
  exports.SideNavMenuItem = SideNavMenuItem;
  exports.SideNavSwitcher = SideNavSwitcher;
  exports.SkeletonPlaceholder = SkeletonPlaceholder;
  exports.SkeletonText = SkeletonText;
  exports.SkipToContent = SkipToContent;
  exports.Slider = Slider$1;
  exports.SliderSkeleton = SliderSkeleton;
  exports.StructuredListBody = StructuredListBody;
  exports.StructuredListCell = StructuredListCell;
  exports.StructuredListHead = StructuredListHead;
  exports.StructuredListInput = StructuredListInput;
  exports.StructuredListRow = StructuredListRow;
  exports.StructuredListSkeleton = StructuredListSkeleton;
  exports.StructuredListWrapper = StructuredListWrapper;
  exports.Switch = Switch;
  exports.Switcher = Switcher;
  exports.SwitcherDivider = SwitcherDivider;
  exports.SwitcherItem = SwitcherItem;
  exports.Tab = Tab;
  exports.TabContent = TabContent;
  exports.Table = Table;
  exports.TableActionList = TableActionList;
  exports.TableBatchAction = TableBatchAction;
  exports.TableBatchActions = TableBatchActions;
  exports.TableBody = TableBody;
  exports.TableCell = TableCell;
  exports.TableContainer = TableContainer;
  exports.TableExpandHeader = TableExpandHeader;
  exports.TableExpandRow = TableExpandRow;
  exports.TableExpandedRow = TableExpandedRow;
  exports.TableHead = TableHead;
  exports.TableHeader = TableHeader;
  exports.TableRow = TableRow;
  exports.TableSelectAll = TableSelectAll;
  exports.TableSelectRow = TableSelectRow;
  exports.TableToolbar = TableToolbar;
  exports.TableToolbarAction = TableToolbarAction;
  exports.TableToolbarContent = TableToolbarContent;
  exports.TableToolbarMenu = TableToolbarMenu;
  exports.TableToolbarSearch = TableToolbarSearch;
  exports.Tabs = Tabs;
  exports.TabsSkeleton = TabsSkeleton;
  exports.Tag = Tag;
  exports.TagSkeleton = TagSkeleton;
  exports.TextArea = TextArea;
  exports.TextAreaSkeleton = TextAreaSkeleton;
  exports.TextInput = TextInput$1;
  exports.TextInputSkeleton = TextInputSkeleton;
  exports.Tile = Tile$1;
  exports.TileAboveTheFoldContent = TileAboveTheFoldContent;
  exports.TileBelowTheFoldContent = TileBelowTheFoldContent;
  exports.TileGroup = TileGroup;
  exports.TimePicker = TimePicker;
  exports.TimePickerSelect = TimePickerSelect;
  exports.ToastNotification = ToastNotification;
  exports.Toggle = Toggle;
  exports.ToggleSkeleton = ToggleSkeleton;
  exports.ToggleSmall = ToggleSmall;
  exports.ToggleSmallSkeleton = ToggleSmallSkeleton;
  exports.Toolbar = Toolbar$1;
  exports.ToolbarDivider = ToolbarDivider;
  exports.ToolbarItem = ToolbarItem;
  exports.ToolbarOption = ToolbarOption;
  exports.ToolbarSearch = ToolbarSearch;
  exports.ToolbarTitle = ToolbarTitle;
  exports.Tooltip = Tooltip$2;
  exports.TooltipDefinition = TooltipDefinition;
  exports.TooltipIcon = TooltipIcon;
  exports.UnorderedList = UnorderedList;
  exports.Unstable_Pagination = Unstable_Pagination;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
